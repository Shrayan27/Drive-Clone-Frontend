"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/protobufjs";
exports.ids = ["vendor-chunks/protobufjs"];
exports.modules = {

/***/ "(ssr)/../node_modules/protobufjs/ext/descriptor/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/protobufjs/ext/descriptor/index.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar $protobuf = __webpack_require__(/*! ../.. */ \"(ssr)/../node_modules/protobufjs/index.js\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(__webpack_require__(/*! ../../google/protobuf/descriptor.json */ \"(ssr)/../node_modules/protobufjs/google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace, Root = $protobuf.Root, Enum = $protobuf.Enum, Type = $protobuf.Type, Field = $protobuf.Field, MapField = $protobuf.MapField, OneOf = $protobuf.OneOf, Service = $protobuf.Service, Method = $protobuf.Method;\n// --- Root ---\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */ /**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n * @property {IEdition} [edition] Edition\n */ /**\n * Values of the Edition enum.\n * @typedef IEdition\n * @type {number}\n * @property {number} EDITION_UNKNOWN=0\n * @property {number} EDITION_LEGACY=900\n * @property {number} EDITION_PROTO2=998\n * @property {number} EDITION_PROTO3=999\n * @property {number} EDITION_2023=1000\n * @property {number} EDITION_2024=1001\n * @property {number} EDITION_1_TEST_ONLY=1\n * @property {number} EDITION_2_TEST_ONLY=2\n * @property {number} EDITION_99997_TEST_ONLY=99997\n * @property {number} EDITION_99998_TEST_ONLY=99998\n * @property {number} EDITION_99998_TEST_ONLY=99999\n * @property {number} EDITION_MAX=2147483647\n */ /**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */ /**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */ /**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */ Root.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n    var root = new Root();\n    if (descriptor.file) {\n        var fileDescriptor, filePackage;\n        for(var j = 0, i; j < descriptor.file.length; ++j){\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n            var edition = editionFromDescriptor(fileDescriptor);\n            if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType) for(i = 0; i < fileDescriptor.messageType.length; ++i)filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], edition));\n            if (fileDescriptor.enumType) for(i = 0; i < fileDescriptor.enumType.length; ++i)filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i], edition));\n            if (fileDescriptor.extension) for(i = 0; i < fileDescriptor.extension.length; ++i)filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i], edition));\n            if (fileDescriptor.service) for(i = 0; i < fileDescriptor.service.length; ++i)filePackage.add(Service.fromDescriptor(fileDescriptor.service[i], edition));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for(i = 0; i < ks.length; ++i)filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n    return root.resolveAll();\n};\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Root.prototype.toDescriptor = function toDescriptor(edition) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, edition);\n    return set;\n};\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, edition) {\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({\n        name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n    });\n    editionToDescriptor(edition, file);\n    if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n    // Add nested types\n    for(var i = 0, nested; i < ns.nestedArray.length; ++i)if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(edition));\n    else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());\n    else if (nested instanceof Field) file.extension.push(nested.toDescriptor(edition));\n    else if (nested instanceof Service) file.service.push(nested.toDescriptor());\n    else if (nested instanceof /* plain */ Namespace) Root_toDescriptorRecursive(nested, files, edition); // requires new file\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n// --- Type ---\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */ /**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */ /**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ /**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ var unnamedMessageIndex = 0;\n/**\n * Creates a type from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a nested object\n * @returns {Type} Type instance\n */ Type.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)), i;\n    if (!nested) type._edition = edition;\n    /* Oneofs */ if (descriptor.oneofDecl) for(i = 0; i < descriptor.oneofDecl.length; ++i)type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field) for(i = 0; i < descriptor.field.length; ++i){\n        var field = Field.fromDescriptor(descriptor.field[i], edition, true);\n        type.add(field);\n        if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n    }\n    /* Extension fields */ if (descriptor.extension) for(i = 0; i < descriptor.extension.length; ++i)type.add(Field.fromDescriptor(descriptor.extension[i], edition, true));\n    /* Nested types */ if (descriptor.nestedType) for(i = 0; i < descriptor.nestedType.length; ++i){\n        type.add(Type.fromDescriptor(descriptor.nestedType[i], edition, true));\n        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n    }\n    /* Nested enums */ if (descriptor.enumType) for(i = 0; i < descriptor.enumType.length; ++i)type.add(Enum.fromDescriptor(descriptor.enumType[i], edition, true));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for(i = 0; i < descriptor.extensionRange.length; ++i)type.extensions.push([\n            descriptor.extensionRange[i].start,\n            descriptor.extensionRange[i].end\n        ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange) for(i = 0; i < descriptor.reservedRange.length; ++i)type.reserved.push([\n            descriptor.reservedRange[i].start,\n            descriptor.reservedRange[i].end\n        ]);\n        /* Names */ if (descriptor.reservedName) for(i = 0; i < descriptor.reservedName.length; ++i)type.reserved.push(descriptor.reservedName[i]);\n    }\n    return type;\n};\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Type.prototype.toDescriptor = function toDescriptor(edition) {\n    var descriptor = exports.DescriptorProto.create({\n        name: this.name\n    }), i;\n    /* Fields */ for(i = 0; i < this.fieldsArray.length; ++i){\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(edition));\n        if (this._fieldsArray[i] instanceof MapField) {\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType, false), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType, false), valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({\n                        name: \"key\",\n                        number: 1,\n                        label: 1,\n                        type: keyType\n                    }),\n                    exports.FieldDescriptorProto.create({\n                        name: \"value\",\n                        number: 2,\n                        label: 1,\n                        type: valueType,\n                        typeName: valueTypeName\n                    })\n                ],\n                options: exports.MessageOptions.create({\n                    mapEntry: true\n                })\n            }));\n        }\n    }\n    /* Oneofs */ for(i = 0; i < this.oneofsArray.length; ++i)descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for(i = 0; i < this.nestedArray.length; ++i){\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(edition));\n        else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(edition));\n        else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions) for(i = 0; i < this.extensions.length; ++i)descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n        start: this.extensions[i][0],\n        end: this.extensions[i][1]\n    }));\n    /* Reserved... */ if (this.reserved) for(i = 0; i < this.reserved.length; ++i)/* Names */ if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n    else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n        start: this.reserved[i][0],\n        end: this.reserved[i][1]\n    }));\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n    return descriptor;\n};\n// --- Field ---\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */ /**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */ /**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */ /**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */ /**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */ // copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\n * Creates a field from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Field} Field instance\n */ Field.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;\n    else fieldType = fromDescriptorType(descriptor.type);\n    // Rewire field rule\n    var fieldRule;\n    switch(descriptor.label){\n        // 0 is reserved for errors\n        case 1:\n            fieldRule = undefined;\n            break;\n        case 2:\n            fieldRule = \"required\";\n            break;\n        case 3:\n            fieldRule = \"repeated\";\n            break;\n        default:\n            throw Error(\"illegal label: \" + descriptor.label);\n    }\n    var extendee = descriptor.extendee;\n    if (descriptor.extendee !== undefined) {\n        extendee = extendee.length ? extendee : undefined;\n    }\n    var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n    if (!nested) field._edition = edition;\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n    if (descriptor.proto3_optional) field.options.proto3_optional = true;\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch(defaultValue){\n            case \"true\":\n            case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\":\n            case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n    if (packableDescriptorType(descriptor.type)) {\n        if (edition === \"proto3\") {\n            if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n        } else if ((!edition || edition === \"proto2\") && descriptor.options && descriptor.options.packed) field.setOption(\"packed\", true);\n    }\n    return field;\n};\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Field.prototype.toDescriptor = function toDescriptor(edition) {\n    var descriptor = exports.FieldDescriptorProto.create({\n        name: this.name,\n        number: this.id\n    });\n    if (this.map) {\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n    } else {\n        // Rewire field type\n        switch(descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType, this.delimited)){\n            case 10:\n            case 11:\n            case 14:\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n        // Rewire field rule\n        if (this.rule === \"repeated\") {\n            descriptor.label = 3;\n        } else if (this.required && edition === \"proto2\") {\n            descriptor.label = 2;\n        } else {\n            descriptor.label = 1;\n        }\n    }\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n    // Handle part of oneof\n    if (this.partOf) {\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n    }\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n        if (this.options.proto3_optional) descriptor.proto3_optional = true;\n    }\n    if (edition === \"proto3\") {\n        if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if ((!edition || edition === \"proto2\") && this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n    return descriptor;\n};\n// --- Enum ---\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */ /**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */ /**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */ var unnamedEnumIndex = 0;\n/**\n * Creates an enum from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Enum} Enum instance\n */ Enum.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n    // Construct values object\n    var values = {};\n    if (descriptor.value) for(var i = 0; i < descriptor.value.length; ++i){\n        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;\n        values[name && name.length ? name : \"NAME\" + value] = value;\n    }\n    var enm = new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n    if (!nested) enm._edition = edition;\n    return enm;\n};\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */ Enum.prototype.toDescriptor = function toDescriptor() {\n    // Values\n    var values = [];\n    for(var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)values.push(exports.EnumValueDescriptorProto.create({\n        name: ks[i],\n        number: this.values[ks[i]]\n    }));\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n// --- OneOf ---\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */ var unnamedOneofIndex = 0;\n/**\n * Creates a oneof from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */ OneOf.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n    return new OneOf(// unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++);\n};\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */ OneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n    });\n};\n// --- Service ---\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */ /**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */ var unnamedServiceIndex = 0;\n/**\n * Creates a service from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Service} Service instance\n */ Service.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (!nested) service._edition = edition;\n    if (descriptor.method) for(var i = 0; i < descriptor.method.length; ++i)service.add(Method.fromDescriptor(descriptor.method[i]));\n    return service;\n};\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */ Service.prototype.toDescriptor = function toDescriptor() {\n    // Methods\n    var methods = [];\n    for(var i = 0; i < this.methodsArray.length; ++i)methods.push(this._methodsArray[i].toDescriptor());\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n// --- Method ---\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */ /**\n * Properties of a MethodOptions message.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */ var unnamedMethodIndex = 0;\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */ Method.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n    return new Method(// unnamedMethodIndex is global, not per service, because we have no ref to a service here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */ Method.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n// --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch(type){\n        // 0 is reserved for errors\n        case 1:\n            return \"double\";\n        case 2:\n            return \"float\";\n        case 3:\n            return \"int64\";\n        case 4:\n            return \"uint64\";\n        case 5:\n            return \"int32\";\n        case 6:\n            return \"fixed64\";\n        case 7:\n            return \"fixed32\";\n        case 8:\n            return \"bool\";\n        case 9:\n            return \"string\";\n        case 12:\n            return \"bytes\";\n        case 13:\n            return \"uint32\";\n        case 15:\n            return \"sfixed32\";\n        case 16:\n            return \"sfixed64\";\n        case 17:\n            return \"sint32\";\n        case 18:\n            return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch(type){\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n            return true;\n    }\n    return false;\n}\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType, delimited) {\n    switch(type){\n        // 0 is reserved for errors\n        case \"double\":\n            return 1;\n        case \"float\":\n            return 2;\n        case \"int64\":\n            return 3;\n        case \"uint64\":\n            return 4;\n        case \"int32\":\n            return 5;\n        case \"fixed64\":\n            return 6;\n        case \"fixed32\":\n            return 7;\n        case \"bool\":\n            return 8;\n        case \"string\":\n            return 9;\n        case \"bytes\":\n            return 12;\n        case \"uint32\":\n            return 13;\n        case \"sfixed32\":\n            return 15;\n        case \"sfixed64\":\n            return 16;\n        case \"sint32\":\n            return 17;\n        case \"sint64\":\n            return 18;\n    }\n    if (resolvedType instanceof Enum) return 14;\n    if (resolvedType instanceof Type) return delimited ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\nfunction fromDescriptorOptionsRecursive(obj, type) {\n    var val = {};\n    for(var i = 0, field, key; i < type.fieldsArray.length; ++i){\n        if ((key = (field = type._fieldsArray[i]).name) === \"uninterpretedOption\") continue;\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;\n        var newKey = underScore(key);\n        if (field.resolvedType instanceof Type) {\n            val[newKey] = fromDescriptorOptionsRecursive(obj[key], field.resolvedType);\n        } else if (field.resolvedType instanceof Enum) {\n            val[newKey] = field.resolvedType.valuesById[obj[key]];\n        } else {\n            val[newKey] = obj[key];\n        }\n    }\n    return val;\n}\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    return fromDescriptorOptionsRecursive(type.toObject(options), type);\n}\nfunction toDescriptorOptionsRecursive(obj, type) {\n    var val = {};\n    var keys = Object.keys(obj);\n    for(var i = 0; i < keys.length; ++i){\n        var key = keys[i];\n        var newKey = $protobuf.util.camelCase(key);\n        if (!Object.prototype.hasOwnProperty.call(type.fields, newKey)) continue;\n        var field = type.fields[newKey];\n        if (field.resolvedType instanceof Type) {\n            val[newKey] = toDescriptorOptionsRecursive(obj[key], field.resolvedType);\n        } else {\n            val[newKey] = obj[key];\n        }\n        if (field.repeated && !Array.isArray(val[newKey])) {\n            val[newKey] = [\n                val[newKey]\n            ];\n        }\n    }\n    return val;\n}\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    return type.fromObject(toDescriptorOptionsRecursive(options, type));\n}\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"), toPath = to.fullName.split(\".\"), i = 0, j = 0, k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace) while(i < fromPath.length && j < k && fromPath[i] === toPath[j]){\n        var other = to.lookup(fromPath[i++], true);\n        if (other !== null && other !== to) break;\n        ++j;\n    }\n    else for(; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {\n        return \"_\" + $1.toLowerCase();\n    });\n}\nfunction editionFromDescriptor(fileDescriptor) {\n    if (fileDescriptor.syntax === \"editions\") {\n        switch(fileDescriptor.edition){\n            case exports.Edition.EDITION_2023:\n                return \"2023\";\n            default:\n                throw new Error(\"Unsupported edition \" + fileDescriptor.edition);\n        }\n    }\n    if (fileDescriptor.syntax === \"proto3\") {\n        return \"proto3\";\n    }\n    return \"proto2\";\n}\nfunction editionToDescriptor(edition, fileDescriptor) {\n    if (!edition) return;\n    if (edition === \"proto2\" || edition === \"proto3\") {\n        fileDescriptor.syntax = edition;\n    } else {\n        fileDescriptor.syntax = \"editions\";\n        switch(edition){\n            case \"2023\":\n                fileDescriptor.edition = exports.Edition.EDITION_2023;\n                break;\n            default:\n                throw new Error(\"Unsupported edition \" + edition);\n        }\n    }\n} // --- exports ---\n /**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */  /**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */  /**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */  /**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */  /**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQyx3REFBTztBQUMvQkMsT0FBT0MsT0FBTyxHQUFHQSxVQUFVSCxVQUFVSSxVQUFVLEdBQUdKLFVBQVVLLElBQUksQ0FBQ0MsUUFBUSxDQUFDTCxtQkFBT0EsQ0FBQywrR0FBdUMsR0FBR00sTUFBTSxDQUFDO0FBRW5JLElBQUlDLFlBQVlSLFVBQVVRLFNBQVMsRUFDL0JILE9BQVlMLFVBQVVLLElBQUksRUFDMUJJLE9BQVlULFVBQVVTLElBQUksRUFDMUJDLE9BQVlWLFVBQVVVLElBQUksRUFDMUJDLFFBQVlYLFVBQVVXLEtBQUssRUFDM0JDLFdBQVlaLFVBQVVZLFFBQVEsRUFDOUJDLFFBQVliLFVBQVVhLEtBQUssRUFDM0JDLFVBQVlkLFVBQVVjLE9BQU8sRUFDN0JDLFNBQVlmLFVBQVVlLE1BQU07QUFFaEMsZUFBZTtBQUVmOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUVEOzs7O0NBSUMsR0FDRFYsS0FBS1csY0FBYyxHQUFHLFNBQVNBLGVBQWVaLFVBQVU7SUFFcEQsMERBQTBEO0lBQzFELElBQUksT0FBT0EsV0FBV2EsTUFBTSxLQUFLLFVBQzdCYixhQUFhRCxRQUFRZSxpQkFBaUIsQ0FBQ0MsTUFBTSxDQUFDZjtJQUVsRCxJQUFJZ0IsT0FBTyxJQUFJZjtJQUVmLElBQUlELFdBQVdpQixJQUFJLEVBQUU7UUFDakIsSUFBSUMsZ0JBQ0FDO1FBQ0osSUFBSyxJQUFJQyxJQUFJLEdBQUdDLEdBQUdELElBQUlwQixXQUFXaUIsSUFBSSxDQUFDSixNQUFNLEVBQUUsRUFBRU8sRUFBRztZQUNoREQsY0FBY0g7WUFDZCxJQUFJLENBQUNF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Ozs7Ozs7Ozs7O0NBV0MsSUFFRDs7Ozs7Ozs7Ozs7Q0FXQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Ozs7Q0FTQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Ozs7OztDQVdDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7Ozs7OztDQVNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3IvaW5kZXguanM/YTdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwiLi4vLi5cIik7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSAkcHJvdG9idWYuZGVzY3JpcHRvciA9ICRwcm90b2J1Zi5Sb290LmZyb21KU09OKHJlcXVpcmUoXCIuLi8uLi9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5qc29uXCIpKS5sb29rdXAoXCIuZ29vZ2xlLnByb3RvYnVmXCIpO1xuXG52YXIgTmFtZXNwYWNlID0gJHByb3RvYnVmLk5hbWVzcGFjZSxcbiAgICBSb290ICAgICAgPSAkcHJvdG9idWYuUm9vdCxcbiAgICBFbnVtICAgICAgPSAkcHJvdG9idWYuRW51bSxcbiAgICBUeXBlICAgICAgPSAkcHJvdG9idWYuVHlwZSxcbiAgICBGaWVsZCAgICAgPSAkcHJvdG9idWYuRmllbGQsXG4gICAgTWFwRmllbGQgID0gJHByb3RvYnVmLk1hcEZpZWxkLFxuICAgIE9uZU9mICAgICA9ICRwcm90b2J1Zi5PbmVPZixcbiAgICBTZXJ2aWNlICAgPSAkcHJvdG9idWYuU2VydmljZSxcbiAgICBNZXRob2QgICAgPSAkcHJvdG9idWYuTWV0aG9kO1xuXG4vLyAtLS0gUm9vdCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZURlc2NyaXB0b3JTZXQgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpbGVEZXNjcmlwdG9yU2V0XG4gKiBAcHJvcGVydHkge0lGaWxlRGVzY3JpcHRvclByb3RvW119IGZpbGUgRmlsZXNcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWxlRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWxlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEZpbGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYWNrYWdlXSBQYWNrYWdlXG4gKiBAcHJvcGVydHkgeyp9IFtkZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkgeyp9IFtwdWJsaWNEZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkgeyp9IFt3ZWFrRGVwZW5kZW5jeV0gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvW119IFttZXNzYWdlVHlwZV0gTmVzdGVkIG1lc3NhZ2UgdHlwZXNcbiAqIEBwcm9wZXJ0eSB7SUVudW1EZXNjcmlwdG9yUHJvdG9bXX0gW2VudW1UeXBlXSBOZXN0ZWQgZW51bXNcbiAqIEBwcm9wZXJ0eSB7SVNlcnZpY2VEZXNjcmlwdG9yUHJvdG9bXX0gW3NlcnZpY2VdIE5lc3RlZCBzZXJ2aWNlc1xuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gTmVzdGVkIGV4dGVuc2lvbiBmaWVsZHNcbiAqIEBwcm9wZXJ0eSB7SUZpbGVPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uc1xuICogQHByb3BlcnR5IHsqfSBbc291cmNlQ29kZUluZm9dIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxuICogQHByb3BlcnR5IHtJRWRpdGlvbn0gW2VkaXRpb25dIEVkaXRpb25cbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiB0aGUgRWRpdGlvbiBlbnVtLlxuICogQHR5cGVkZWYgSUVkaXRpb25cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl9VTktOT1dOPTBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OX0xFR0FDWT05MDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OX1BST1RPMj05OThcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OX1BST1RPMz05OTlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OXzIwMjM9MTAwMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fMjAyND0xMDAxXG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl8xX1RFU1RfT05MWT0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl8yX1RFU1RfT05MWT0yXG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl85OTk5N19URVNUX09OTFk9OTk5OTdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OXzk5OTk4X1RFU1RfT05MWT05OTk5OFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fOTk5OThfVEVTVF9PTkxZPTk5OTk5XG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl9NQVg9MjE0NzQ4MzY0N1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpbGVPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtqYXZhUGFja2FnZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbamF2YU91dGVyQ2xhc3NuYW1lXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YU11bHRpcGxlRmlsZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YVN0cmluZ0NoZWNrVXRmOF1cbiAqIEBwcm9wZXJ0eSB7SUZpbGVPcHRpb25zT3B0aW1pemVNb2RlfSBbb3B0aW1pemVGb3I9MV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ29QYWNrYWdlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2NHZW5lcmljU2VydmljZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhR2VuZXJpY1NlcnZpY2VzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHlHZW5lcmljU2VydmljZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXByZWNhdGVkXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2NFbmFibGVBcmVuYXNdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29iamNDbGFzc1ByZWZpeF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3NoYXJwTmFtZXNwYWNlXVxuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIGhlIEZpbGVPcHRpb25zLk9wdGltaXplTW9kZSBlbnVtLlxuICogQHR5cGVkZWYgSUZpbGVPcHRpb25zT3B0aW1pemVNb2RlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFNQRUVEPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0RFX1NJWkU9MlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJVEVfUlVOVElNRT0zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm9vdCBmcm9tIGEgZGVzY3JpcHRvciBzZXQuXG4gKiBAcGFyYW0ge0lGaWxlRGVzY3JpcHRvclNldHxSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBpbnN0YW5jZVxuICovXG5Sb290LmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIHZhciByb290ID0gbmV3IFJvb3QoKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLmZpbGUpIHtcbiAgICAgICAgdmFyIGZpbGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgZmlsZVBhY2thZ2U7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBpOyBqIDwgZGVzY3JpcHRvci5maWxlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBmaWxlUGFja2FnZSA9IHJvb3Q7XG4gICAgICAgICAgICBpZiAoKGZpbGVEZXNjcmlwdG9yID0gZGVzY3JpcHRvci5maWxlW2pdKVtcInBhY2thZ2VcIl0gJiYgZmlsZURlc2NyaXB0b3JbXCJwYWNrYWdlXCJdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmaWxlUGFja2FnZSA9IHJvb3QuZGVmaW5lKGZpbGVEZXNjcmlwdG9yW1wicGFja2FnZVwiXSk7XG4gICAgICAgICAgICB2YXIgZWRpdGlvbiA9IGVkaXRpb25Gcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvcik7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IubmFtZSAmJiBmaWxlRGVzY3JpcHRvci5uYW1lLmxlbmd0aClcbiAgICAgICAgICAgICAgICByb290LmZpbGVzLnB1c2goZmlsZVBhY2thZ2UuZmlsZW5hbWUgPSBmaWxlRGVzY3JpcHRvci5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5tZXNzYWdlVHlwZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChUeXBlLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLm1lc3NhZ2VUeXBlW2ldLCBlZGl0aW9uKSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IuZW51bVR5cGUpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9yLmVudW1UeXBlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoRW51bS5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5lbnVtVHlwZVtpXSwgZWRpdGlvbikpO1xuICAgICAgICAgICAgaWYgKGZpbGVEZXNjcmlwdG9yLmV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoRmllbGQuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uW2ldLCBlZGl0aW9uKSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3Iuc2VydmljZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3Iuc2VydmljZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKFNlcnZpY2UuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3Iuc2VydmljZVtpXSwgZWRpdGlvbikpO1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZmlsZURlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5GaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgICAgIHZhciBrcyA9IE9iamVjdC5rZXlzKG9wdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2Uuc2V0T3B0aW9uKGtzW2ldLCBvcHRzW2tzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdC5yZXNvbHZlQWxsKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcm9vdCB0byBhIGRlc2NyaXB0b3Igc2V0LlxuICogQHJldHVybnMge01lc3NhZ2U8SUZpbGVEZXNjcmlwdG9yU2V0Pn0gRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtlZGl0aW9uPVwicHJvdG8yXCJdIFRoZSBzeW50YXggb3IgZWRpdGlvbiB0byB1c2VcbiAqL1xuUm9vdC5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKGVkaXRpb24pIHtcbiAgICB2YXIgc2V0ID0gZXhwb3J0cy5GaWxlRGVzY3JpcHRvclNldC5jcmVhdGUoKTtcbiAgICBSb290X3RvRGVzY3JpcHRvclJlY3Vyc2l2ZSh0aGlzLCBzZXQuZmlsZSwgZWRpdGlvbik7XG4gICAgcmV0dXJuIHNldDtcbn07XG5cbi8vIFRyYXZlcnNlcyBhIG5hbWVzcGFjZSBhbmQgYXNzZW1ibGVzIHRoZSBkZXNjcmlwdG9yIHNldFxuZnVuY3Rpb24gUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUobnMsIGZpbGVzLCBlZGl0aW9uKSB7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgZmlsZVxuICAgIHZhciBmaWxlID0gZXhwb3J0cy5GaWxlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IG5zLmZpbGVuYW1lIHx8IChucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvXFwuL2csIFwiX1wiKSB8fCBcInJvb3RcIikgKyBcIi5wcm90b1wiIH0pO1xuICAgIGVkaXRpb25Ub0Rlc2NyaXB0b3IoZWRpdGlvbiwgZmlsZSk7XG4gICAgaWYgKCEobnMgaW5zdGFuY2VvZiBSb290KSlcbiAgICAgICAgZmlsZVtcInBhY2thZ2VcIl0gPSBucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSk7XG5cbiAgICAvLyBBZGQgbmVzdGVkIHR5cGVzXG4gICAgZm9yICh2YXIgaSA9IDAsIG5lc3RlZDsgaSA8IG5zLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKG5lc3RlZCA9IG5zLl9uZXN0ZWRBcnJheVtpXSkgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICAgICAgZmlsZS5tZXNzYWdlVHlwZS5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3IoZWRpdGlvbikpO1xuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICAgICAgZmlsZS5lbnVtVHlwZS5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3IoKSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEZpZWxkKVxuICAgICAgICAgICAgZmlsZS5leHRlbnNpb24ucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKGVkaXRpb24pKTtcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgU2VydmljZSlcbiAgICAgICAgICAgIGZpbGUuc2VydmljZS5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3IoKSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIC8qIHBsYWluICovIE5hbWVzcGFjZSlcbiAgICAgICAgICAgIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKG5lc3RlZCwgZmlsZXMsIGVkaXRpb24pOyAvLyByZXF1aXJlcyBuZXcgZmlsZVxuXG4gICAgLy8gS2VlcCBwYWNrYWdlLWxldmVsIG9wdGlvbnNcbiAgICBmaWxlLm9wdGlvbnMgPSB0b0Rlc2NyaXB0b3JPcHRpb25zKG5zLm9wdGlvbnMsIGV4cG9ydHMuRmlsZU9wdGlvbnMpO1xuXG4gICAgLy8gQW5kIGtlZXAgdGhlIGZpbGUgb25seSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbmVzdGVkIG9iamVjdFxuICAgIGlmIChmaWxlLm1lc3NhZ2VUeXBlLmxlbmd0aCArIGZpbGUuZW51bVR5cGUubGVuZ3RoICsgZmlsZS5leHRlbnNpb24ubGVuZ3RoICsgZmlsZS5zZXJ2aWNlLmxlbmd0aClcbiAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbn1cblxuLy8gLS0tIFR5cGUgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIERlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE1lc3NhZ2UgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1tdfSBbZmllbGRdIEZpZWxkc1xuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gRXh0ZW5zaW9uIGZpZWxkc1xuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvW119IFtuZXN0ZWRUeXBlXSBOZXN0ZWQgbWVzc2FnZSB0eXBlc1xuICogQHByb3BlcnR5IHtJRW51bURlc2NyaXB0b3JQcm90b1tdfSBbZW51bVR5cGVdIE5lc3RlZCBlbnVtc1xuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvRXh0ZW5zaW9uUmFuZ2VbXX0gW2V4dGVuc2lvblJhbmdlXSBFeHRlbnNpb24gcmFuZ2VzXG4gKiBAcHJvcGVydHkge0lPbmVvZkRlc2NyaXB0b3JQcm90b1tdfSBbb25lb2ZEZWNsXSBPbmVvZnNcbiAqIEBwcm9wZXJ0eSB7SU1lc3NhZ2VPcHRpb25zfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvUmVzZXJ2ZWRSYW5nZVtdfSBbcmVzZXJ2ZWRSYW5nZV0gUmVzZXJ2ZWQgcmFuZ2VzXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbcmVzZXJ2ZWROYW1lXSBSZXNlcnZlZCBuYW1lc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE1lc3NhZ2VPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElNZXNzYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbbWFwRW50cnk9ZmFsc2VdIFdoZXRoZXIgdGhpcyBtZXNzYWdlIGlzIGEgbWFwIGVudHJ5XG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEV4dGVuc2lvblJhbmdlIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9FeHRlbnNpb25SYW5nZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdGFydF0gU3RhcnQgZmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZW5kXSBFbmQgZmllbGQgaWRcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBSZXNlcnZlZFJhbmdlIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9SZXNlcnZlZFJhbmdlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0YXJ0XSBTdGFydCBmaWVsZCBpZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbmRdIEVuZCBmaWVsZCBpZFxuICovXG5cbnZhciB1bm5hbWVkTWVzc2FnZUluZGV4ID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdHlwZSBmcm9tIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBXYXJuaW5nOiB0aGlzIGlzIG5vdCBzYWZlIHRvIHVzZSB3aXRoIGVkaXRpb25zIHByb3Rvcywgc2luY2UgaXQgZGlzY2FyZHMgcmVsZXZhbnQgZmlsZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7SURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VkaXRpb249XCJwcm90bzJcIl0gVGhlIHN5bnRheCBvciBlZGl0aW9uIHRvIHVzZVxuICogQHBhcmFtIHtib29sZWFufSBbbmVzdGVkPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGEgbmVzdGVkIG9iamVjdFxuICogQHJldHVybnMge1R5cGV9IFR5cGUgaW5zdGFuY2VcbiAqL1xuVHlwZS5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IsIGVkaXRpb24sIG5lc3RlZCkge1xuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBtZXNzYWdlIHR5cGVcbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIlR5cGVcIiArIHVubmFtZWRNZXNzYWdlSW5kZXgrKywgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucykpLFxuICAgICAgICBpO1xuXG4gICAgaWYgKCFuZXN0ZWQpXG4gICAgICAgIHR5cGUuX2VkaXRpb24gPSBlZGl0aW9uO1xuXG4gICAgLyogT25lb2ZzICovIGlmIChkZXNjcmlwdG9yLm9uZW9mRGVjbClcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3Iub25lb2ZEZWNsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5hZGQoT25lT2YuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5vbmVvZkRlY2xbaV0pKTtcbiAgICAvKiBGaWVsZHMgKi8gaWYgKGRlc2NyaXB0b3IuZmllbGQpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmZpZWxkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBGaWVsZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLmZpZWxkW2ldLCBlZGl0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHR5cGUuYWRkKGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmZpZWxkW2ldLmhhc093blByb3BlcnR5KFwib25lb2ZJbmRleFwiKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICB0eXBlLm9uZW9mc0FycmF5W2Rlc2NyaXB0b3IuZmllbGRbaV0ub25lb2ZJbmRleF0uYWRkKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIC8qIEV4dGVuc2lvbiBmaWVsZHMgKi8gaWYgKGRlc2NyaXB0b3IuZXh0ZW5zaW9uKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChGaWVsZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLmV4dGVuc2lvbltpXSwgZWRpdGlvbiwgdHJ1ZSkpO1xuICAgIC8qIE5lc3RlZCB0eXBlcyAqLyBpZiAoZGVzY3JpcHRvci5uZXN0ZWRUeXBlKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5uZXN0ZWRUeXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlLmFkZChUeXBlLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IubmVzdGVkVHlwZVtpXSwgZWRpdGlvbiwgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IubmVzdGVkVHlwZVtpXS5vcHRpb25zICYmIGRlc2NyaXB0b3IubmVzdGVkVHlwZVtpXS5vcHRpb25zLm1hcEVudHJ5KVxuICAgICAgICAgICAgICAgIHR5cGUuc2V0T3B0aW9uKFwibWFwX2VudHJ5XCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgLyogTmVzdGVkIGVudW1zICovIGlmIChkZXNjcmlwdG9yLmVudW1UeXBlKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5lbnVtVHlwZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKEVudW0uZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5lbnVtVHlwZVtpXSwgZWRpdGlvbiwgdHJ1ZSkpO1xuICAgIC8qIEV4dGVuc2lvbiByYW5nZXMgKi8gaWYgKGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UgJiYgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgdHlwZS5leHRlbnNpb25zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5leHRlbnNpb25zLnB1c2goWyBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlW2ldLnN0YXJ0LCBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlW2ldLmVuZCBdKTtcbiAgICB9XG4gICAgLyogUmVzZXJ2ZWQuLi4gKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZSAmJiBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UubGVuZ3RoIHx8IGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lICYmIGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLmxlbmd0aCkge1xuICAgICAgICB0eXBlLnJlc2VydmVkID0gW107XG4gICAgICAgIC8qIFJhbmdlcyAqLyBpZiAoZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlKVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0eXBlLnJlc2VydmVkLnB1c2goWyBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2VbaV0uc3RhcnQsIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZVtpXS5lbmQgXSk7XG4gICAgICAgIC8qIE5hbWVzICovIGlmIChkZXNjcmlwdG9yLnJlc2VydmVkTmFtZSlcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0eXBlLnJlc2VydmVkLnB1c2goZGVzY3JpcHRvci5yZXNlcnZlZE5hbWVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHR5cGUgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SURlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWRpdGlvbj1cInByb3RvMlwiXSBUaGUgc3ludGF4IG9yIGVkaXRpb24gdG8gdXNlXG4gKi9cblR5cGUucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcihlZGl0aW9uKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBleHBvcnRzLkRlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiB0aGlzLm5hbWUgfSksXG4gICAgICAgIGk7XG5cbiAgICAvKiBGaWVsZHMgKi8gZm9yIChpID0gMDsgaSA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkRGVzY3JpcHRvcjtcbiAgICAgICAgZGVzY3JpcHRvci5maWVsZC5wdXNoKGZpZWxkRGVzY3JpcHRvciA9IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnRvRGVzY3JpcHRvcihlZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNBcnJheVtpXSBpbnN0YW5jZW9mIE1hcEZpZWxkKSB7IC8vIG1hcCBmaWVsZHMgYXJlIHJlcGVhdGVkIEZpZWxkTmFtZUVudHJ5XG4gICAgICAgICAgICB2YXIga2V5VHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy5fZmllbGRzQXJyYXlbaV0ua2V5VHlwZSwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRLZXlUeXBlLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gdG9EZXNjcmlwdG9yVHlwZSh0aGlzLl9maWVsZHNBcnJheVtpXS50eXBlLCB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZFR5cGUsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlID09PSAvKiB0eXBlICovIDExIHx8IHZhbHVlVHlwZSA9PT0gLyogZW51bSAqLyAxNFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSAmJiBzaG9ydG5hbWUodGhpcy5wYXJlbnQsIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSkgfHwgdGhpcy5fZmllbGRzQXJyYXlbaV0udHlwZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubmVzdGVkVHlwZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGREZXNjcmlwdG9yLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBbXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRmllbGREZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogXCJrZXlcIiwgbnVtYmVyOiAxLCBsYWJlbDogMSwgdHlwZToga2V5VHlwZSB9KSwgLy8gY2FuJ3QgcmVmZXJlbmNlIGEgdHlwZSBvciBlbnVtXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRmllbGREZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogXCJ2YWx1ZVwiLCBudW1iZXI6IDIsIGxhYmVsOiAxLCB0eXBlOiB2YWx1ZVR5cGUsIHR5cGVOYW1lOiB2YWx1ZVR5cGVOYW1lIH0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBvcnRzLk1lc3NhZ2VPcHRpb25zLmNyZWF0ZSh7IG1hcEVudHJ5OiB0cnVlIH0pXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogT25lb2ZzICovIGZvciAoaSA9IDA7IGkgPCB0aGlzLm9uZW9mc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBkZXNjcmlwdG9yLm9uZW9mRGVjbC5wdXNoKHRoaXMuX29uZW9mc0FycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcbiAgICAvKiBOZXN0ZWQuLi4gKi8gZm9yIChpID0gMDsgaSA8IHRoaXMubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLyogRXh0ZW5zaW9uIGZpZWxkcyAqLyBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBGaWVsZClcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZmllbGQucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3IoZWRpdGlvbikpO1xuICAgICAgICAvKiBUeXBlcyAqLyBlbHNlIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLm5lc3RlZFR5cGUucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3IoZWRpdGlvbikpO1xuICAgICAgICAvKiBFbnVtcyAqLyBlbHNlIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1UeXBlLnB1c2godGhpcy5fbmVzdGVkQXJyYXlbaV0udG9EZXNjcmlwdG9yKCkpO1xuICAgICAgICAvLyBwbGFpbiBuZXN0ZWQgbmFtZXNwYWNlcyBiZWNvbWUgcGFja2FnZXMgaW5zdGVhZCBpbiBSb290I3RvRGVzY3JpcHRvclxuICAgIH1cbiAgICAvKiBFeHRlbnNpb24gcmFuZ2VzICovIGlmICh0aGlzLmV4dGVuc2lvbnMpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLnB1c2goZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uRXh0ZW5zaW9uUmFuZ2UuY3JlYXRlKHsgc3RhcnQ6IHRoaXMuZXh0ZW5zaW9uc1tpXVswXSwgZW5kOiB0aGlzLmV4dGVuc2lvbnNbaV1bMV0gfSkpO1xuICAgIC8qIFJlc2VydmVkLi4uICovIGlmICh0aGlzLnJlc2VydmVkKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZXNlcnZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIC8qIE5hbWVzICovIGlmICh0eXBlb2YgdGhpcy5yZXNlcnZlZFtpXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5wdXNoKHRoaXMucmVzZXJ2ZWRbaV0pO1xuICAgICAgICAgICAgLyogUmFuZ2VzICovIGVsc2VcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UucHVzaChleHBvcnRzLkRlc2NyaXB0b3JQcm90by5SZXNlcnZlZFJhbmdlLmNyZWF0ZSh7IHN0YXJ0OiB0aGlzLnJlc2VydmVkW2ldWzBdLCBlbmQ6IHRoaXMucmVzZXJ2ZWRbaV1bMV0gfSkpO1xuXG4gICAgZGVzY3JpcHRvci5vcHRpb25zID0gdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuTWVzc2FnZU9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG4vLyAtLS0gRmllbGQgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpZWxkRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWVsZERlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBGaWVsZCBuYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlcl0gRmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvTGFiZWx9IFtsYWJlbF0gRmllbGQgcnVsZVxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9UeXBlfSBbdHlwZV0gRmllbGQgYmFzaWMgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlTmFtZV0gRmllbGQgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2V4dGVuZGVlXSBFeHRlbmRlZCB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZGVmYXVsdFZhbHVlXSBMaXRlcmFsIGRlZmF1bHQgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb25lb2ZJbmRleF0gT25lb2YgaW5kZXggaWYgcGFydCBvZiBhIG9uZW9mXG4gKiBAcHJvcGVydHkgeyp9IFtqc29uTmFtZV0gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtJRmllbGRPcHRpb25zfSBbb3B0aW9uc10gRmllbGQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBGaWVsZERlc2NyaXB0b3JQcm90by5MYWJlbCBlbnVtLlxuICogQHR5cGVkZWYgSUZpZWxkRGVzY3JpcHRvclByb3RvTGFiZWxcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfT1BUSU9OQUw9MVxuICogQHByb3BlcnR5IHtudW1iZXJ9IExBQkVMX1JFUVVJUkVEPTJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMQUJFTF9SRVBFQVRFRD0zXG4gKi9cblxuLyoqXG4gKiBWYWx1ZXMgb2YgdGhlIEZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgZW51bS5cbiAqIEB0eXBlZGVmIElGaWVsZERlc2NyaXB0b3JQcm90b1R5cGVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9ET1VCTEU9MVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRkxPQVQ9MlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfSU5UNjQ9M1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfVUlOVDY0PTRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0lOVDMyPTVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0ZJWEVENjQ9NlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRklYRUQzMj03XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9CT09MPThcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NUUklORz05XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9HUk9VUD0xMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfTUVTU0FHRT0xMVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfQllURVM9MTJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1VJTlQzMj0xM1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRU5VTT0xNFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0ZJWEVEMzI9MTVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NGSVhFRDY0PTE2XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TSU5UMzI9MTdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NJTlQ2ND0xOFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpZWxkT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRmllbGRPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwYWNrZWRdIFdoZXRoZXIgcGFja2VkIG9yIG5vdCAoZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgcHJvdG8yIGFuZCBgdHJ1ZWAgZm9yIHByb3RvMylcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkT3B0aW9uc0pTVHlwZX0gW2pzdHlwZV0gSmF2YVNjcmlwdCB2YWx1ZSB0eXBlIChub3QgdXNlZCBieSBwcm90b2J1Zi5qcylcbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiB0aGUgRmllbGRPcHRpb25zLkpTVHlwZSBlbnVtLlxuICogQHR5cGVkZWYgSUZpZWxkT3B0aW9uc0pTVHlwZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKU19OT1JNQUw9MFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEpTX1NUUklORz0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gSlNfTlVNQkVSPTJcbiAqL1xuXG4vLyBjb3BpZWQgaGVyZSBmcm9tIHBhcnNlLmpzXG52YXIgbnVtYmVyUmUgPSAvXig/IVtlRV0pWzAtOV0qKD86XFwuWzAtOV0qKT8oPzpbZUVdWystXT9bMC05XSspPyQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmaWVsZCBmcm9tIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBXYXJuaW5nOiB0aGlzIGlzIG5vdCBzYWZlIHRvIHVzZSB3aXRoIGVkaXRpb25zIHByb3Rvcywgc2luY2UgaXQgZGlzY2FyZHMgcmVsZXZhbnQgZmlsZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7SUZpZWxkRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWRpdGlvbj1cInByb3RvMlwiXSBUaGUgc3ludGF4IG9yIGVkaXRpb24gdG8gdXNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXN0ZWQ9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYSB0b3AtbGV2ZWwgb2JqZWN0XG4gKiBAcmV0dXJucyB7RmllbGR9IEZpZWxkIGluc3RhbmNlXG4gKi9cbkZpZWxkLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgZWRpdGlvbiwgbmVzdGVkKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5udW1iZXIgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwibWlzc2luZyBmaWVsZCBpZFwiKTtcblxuICAgIC8vIFJld2lyZSBmaWVsZCB0eXBlXG4gICAgdmFyIGZpZWxkVHlwZTtcbiAgICBpZiAoZGVzY3JpcHRvci50eXBlTmFtZSAmJiBkZXNjcmlwdG9yLnR5cGVOYW1lLmxlbmd0aClcbiAgICAgICAgZmllbGRUeXBlID0gZGVzY3JpcHRvci50eXBlTmFtZTtcbiAgICBlbHNlXG4gICAgICAgIGZpZWxkVHlwZSA9IGZyb21EZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yLnR5cGUpO1xuXG4gICAgLy8gUmV3aXJlIGZpZWxkIHJ1bGVcbiAgICB2YXIgZmllbGRSdWxlO1xuICAgIHN3aXRjaCAoZGVzY3JpcHRvci5sYWJlbCkge1xuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcbiAgICAgICAgY2FzZSAxOiBmaWVsZFJ1bGUgPSB1bmRlZmluZWQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGZpZWxkUnVsZSA9IFwicmVxdWlyZWRcIjsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogZmllbGRSdWxlID0gXCJyZXBlYXRlZFwiOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGxhYmVsOiBcIiArIGRlc2NyaXB0b3IubGFiZWwpO1xuICAgIH1cblxuXHR2YXIgZXh0ZW5kZWUgPSBkZXNjcmlwdG9yLmV4dGVuZGVlO1xuXHRpZiAoZGVzY3JpcHRvci5leHRlbmRlZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ZXh0ZW5kZWUgPSBleHRlbmRlZS5sZW5ndGggPyBleHRlbmRlZSA6IHVuZGVmaW5lZDtcblx0fVxuICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiZmllbGRcIiArIGRlc2NyaXB0b3IubnVtYmVyLFxuICAgICAgICBkZXNjcmlwdG9yLm51bWJlcixcbiAgICAgICAgZmllbGRUeXBlLFxuICAgICAgICBmaWVsZFJ1bGUsXG4gICAgICAgIGV4dGVuZGVlXG4gICAgKTtcblxuICAgIGlmICghbmVzdGVkKVxuICAgICAgICBmaWVsZC5fZWRpdGlvbiA9IGVkaXRpb247XG5cbiAgICBmaWVsZC5vcHRpb25zID0gZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5GaWVsZE9wdGlvbnMpO1xuICAgIGlmIChkZXNjcmlwdG9yLnByb3RvM19vcHRpb25hbClcbiAgICAgICAgZmllbGQub3B0aW9ucy5wcm90bzNfb3B0aW9uYWwgPSB0cnVlO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlICYmIGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZGVzY3JpcHRvci5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiBjYXNlIFwiVFJVRVwiOlxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogY2FzZSBcIkZBTFNFXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bWJlclJlLmV4ZWMoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmFkaXhcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJkZWZhdWx0XCIsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhY2thYmxlRGVzY3JpcHRvclR5cGUoZGVzY3JpcHRvci50eXBlKSkge1xuICAgICAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzNcIikgeyAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSAoaW50ZXJuYWwgcHJlc2V0IGlzIHBhY2tlZD10cnVlKVxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iub3B0aW9ucyAmJiAhZGVzY3JpcHRvci5vcHRpb25zLnBhY2tlZClcbiAgICAgICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCghZWRpdGlvbiB8fCBlZGl0aW9uID09PSBcInByb3RvMlwiKSAmJiBkZXNjcmlwdG9yLm9wdGlvbnMgJiYgZGVzY3JpcHRvci5vcHRpb25zLnBhY2tlZCkgLy8gZGVmYXVsdHMgdG8gcGFja2VkPWZhbHNlXG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGZpZWxkIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElGaWVsZERlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWRpdGlvbj1cInByb3RvMlwiXSBUaGUgc3ludGF4IG9yIGVkaXRpb24gdG8gdXNlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoZWRpdGlvbikge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5GaWVsZERlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiB0aGlzLm5hbWUsIG51bWJlcjogdGhpcy5pZCB9KTtcblxuICAgIGlmICh0aGlzLm1hcCkge1xuXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZSA9IDExOyAvLyBtZXNzYWdlXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZU5hbWUgPSAkcHJvdG9idWYudXRpbC51Y0ZpcnN0KHRoaXMubmFtZSk7IC8vIGZpZWxkTmFtZSAtPiBGaWVsZE5hbWVFbnRyeSAoYnVpbHQgaW4gVHlwZSN0b0Rlc2NyaXB0b3IpXG4gICAgICAgIGRlc2NyaXB0b3IubGFiZWwgPSAzOyAvLyByZXBlYXRlZFxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBSZXdpcmUgZmllbGQgdHlwZVxuICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3IudHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy50eXBlLCB0aGlzLnJlc29sdmUoKS5yZXNvbHZlZFR5cGUsIHRoaXMuZGVsaW1pdGVkKSkge1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gZ3JvdXBcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIHR5cGVcbiAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVudW1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnR5cGVOYW1lID0gdGhpcy5yZXNvbHZlZFR5cGUgPyBzaG9ydG5hbWUodGhpcy5wYXJlbnQsIHRoaXMucmVzb2x2ZWRUeXBlKSA6IHRoaXMudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJld2lyZSBmaWVsZCBydWxlXG4gICAgICAgIGlmICh0aGlzLnJ1bGUgPT09IFwicmVwZWF0ZWRcIikge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5sYWJlbCA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1aXJlZCAmJiBlZGl0aW9uID09PSBcInByb3RvMlwiKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmxhYmVsID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubGFiZWwgPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGV4dGVuc2lvbiBmaWVsZFxuICAgIGRlc2NyaXB0b3IuZXh0ZW5kZWUgPSB0aGlzLmV4dGVuc2lvbkZpZWxkID8gdGhpcy5leHRlbnNpb25GaWVsZC5wYXJlbnQuZnVsbE5hbWUgOiB0aGlzLmV4dGVuZDtcblxuICAgIC8vIEhhbmRsZSBwYXJ0IG9mIG9uZW9mXG4gICAgaWYgKHRoaXMucGFydE9mKVxuICAgICAgICBpZiAoKGRlc2NyaXB0b3Iub25lb2ZJbmRleCA9IHRoaXMucGFyZW50Lm9uZW9mc0FycmF5LmluZGV4T2YodGhpcy5wYXJ0T2YpKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1pc3Npbmcgb25lb2ZcIik7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGRlc2NyaXB0b3Iub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLkZpZWxkT3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdICE9IG51bGwpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSA9IFN0cmluZyh0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm90bzNfb3B0aW9uYWwpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnByb3RvM19vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVkaXRpb24gPT09IFwicHJvdG8zXCIpIHsgLy8gZGVmYXVsdHMgdG8gcGFja2VkPXRydWVcbiAgICAgICAgaWYgKCF0aGlzLnBhY2tlZClcbiAgICAgICAgICAgIChkZXNjcmlwdG9yLm9wdGlvbnMgfHwgKGRlc2NyaXB0b3Iub3B0aW9ucyA9IGV4cG9ydHMuRmllbGRPcHRpb25zLmNyZWF0ZSgpKSkucGFja2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgoIWVkaXRpb24gfHwgZWRpdGlvbiA9PT0gXCJwcm90bzJcIikgJiYgdGhpcy5wYWNrZWQpIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD1mYWxzZVxuICAgICAgICAoZGVzY3JpcHRvci5vcHRpb25zIHx8IChkZXNjcmlwdG9yLm9wdGlvbnMgPSBleHBvcnRzLkZpZWxkT3B0aW9ucy5jcmVhdGUoKSkpLnBhY2tlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIC0tLSBFbnVtIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYW4gRW51bURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBFbnVtIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SUVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1tdfSBbdmFsdWVdIEVudW0gdmFsdWVzXG4gKiBAcHJvcGVydHkge0lFbnVtT3B0aW9uc30gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBOYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlcl0gVmFsdWVcbiAqIEBwcm9wZXJ0eSB7Kn0gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYW4gRW51bU9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUVudW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbGxvd0FsaWFzXSBXaGV0aGVyIGFsaWFzZXMgYXJlIGFsbG93ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRFbnVtSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW51bSBmcm9tIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBXYXJuaW5nOiB0aGlzIGlzIG5vdCBzYWZlIHRvIHVzZSB3aXRoIGVkaXRpb25zIHByb3Rvcywgc2luY2UgaXQgZGlzY2FyZHMgcmVsZXZhbnQgZmlsZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7SUVudW1EZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtlZGl0aW9uPVwicHJvdG8yXCJdIFRoZSBzeW50YXggb3IgZWRpdGlvbiB0byB1c2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25lc3RlZD1mYWxzZV0gV2hldGhlciBvciBub3QgdGhpcyBpcyBhIHRvcC1sZXZlbCBvYmplY3RcbiAqIEByZXR1cm5zIHtFbnVtfSBFbnVtIGluc3RhbmNlXG4gKi9cbkVudW0uZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCBlZGl0aW9uLCBuZXN0ZWQpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5FbnVtRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIC8vIENvbnN0cnVjdCB2YWx1ZXMgb2JqZWN0XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2NyaXB0b3IudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYW1lICA9IGRlc2NyaXB0b3IudmFsdWVbaV0ubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWVbaV0ubnVtYmVyIHx8IDA7XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZSAmJiBuYW1lLmxlbmd0aCA/IG5hbWUgOiBcIk5BTUVcIiArIHZhbHVlXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB2YXIgZW5tID0gbmV3IEVudW0oXG4gICAgICAgIGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJFbnVtXCIgKyB1bm5hbWVkRW51bUluZGV4KyssXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5FbnVtT3B0aW9ucylcbiAgICApO1xuXG4gICAgaWYgKCFuZXN0ZWQpXG4gICAgICAgIGVubS5fZWRpdGlvbiA9IGVkaXRpb247XG5cbiAgICByZXR1cm4gZW5tO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBlbnVtIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElFbnVtRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICovXG5FbnVtLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG5cbiAgICAvLyBWYWx1ZXNcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGtzID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgIHZhbHVlcy5wdXNoKGV4cG9ydHMuRW51bVZhbHVlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IGtzW2ldLCBudW1iZXI6IHRoaXMudmFsdWVzW2tzW2ldXSB9KSk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5FbnVtRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlcyxcbiAgICAgICAgb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuRW51bU9wdGlvbnMpXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gT25lT2YgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE9uZW9mRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElPbmVvZkRlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBPbmVvZiBuYW1lXG4gKiBAcHJvcGVydHkgeyp9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXG4gKi9cblxudmFyIHVubmFtZWRPbmVvZkluZGV4ID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgb25lb2YgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKlxuICogV2FybmluZzogdGhpcyBpcyBub3Qgc2FmZSB0byB1c2Ugd2l0aCBlZGl0aW9ucyBwcm90b3MsIHNpbmNlIGl0IGRpc2NhcmRzIHJlbGV2YW50IGZpbGUgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0lPbmVvZkRlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7T25lT2Z9IE9uZU9mIGluc3RhbmNlXG4gKi9cbk9uZU9mLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLk9uZW9mRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIHJldHVybiBuZXcgT25lT2YoXG4gICAgICAgIC8vIHVubmFtZWRPbmVPZkluZGV4IGlzIGdsb2JhbCwgbm90IHBlciB0eXBlLCBiZWNhdXNlIHdlIGhhdmUgbm8gcmVmIHRvIGEgdHlwZSBoZXJlXG4gICAgICAgIGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJvbmVvZlwiICsgdW5uYW1lZE9uZW9mSW5kZXgrK1xuICAgICAgICAvLyBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk9uZW9mT3B0aW9ucykgLSBvbmx5IHVuaW50ZXJwcmV0ZWRfb3B0aW9uXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBvbmVvZiB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJT25lb2ZEZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cbk9uZU9mLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICAgIC8vIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLk9uZW9mT3B0aW9ucykgLSBvbmx5IHVuaW50ZXJwcmV0ZWRfb3B0aW9uXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gU2VydmljZSAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgU2VydmljZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJU2VydmljZURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBTZXJ2aWNlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b1tdfSBbbWV0aG9kXSBNZXRob2RzXG4gKiBAcHJvcGVydHkge0lTZXJ2aWNlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBTZXJ2aWNlT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJU2VydmljZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRTZXJ2aWNlSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXJ2aWNlIGZyb20gYSBkZXNjcmlwdG9yLlxuICpcbiAqIFdhcm5pbmc6IHRoaXMgaXMgbm90IHNhZmUgdG8gdXNlIHdpdGggZWRpdGlvbnMgcHJvdG9zLCBzaW5jZSBpdCBkaXNjYXJkcyByZWxldmFudCBmaWxlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtJU2VydmljZURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VkaXRpb249XCJwcm90bzJcIl0gVGhlIHN5bnRheCBvciBlZGl0aW9uIHRvIHVzZVxuICogQHBhcmFtIHtib29sZWFufSBbbmVzdGVkPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGEgdG9wLWxldmVsIG9iamVjdFxuICogQHJldHVybnMge1NlcnZpY2V9IFNlcnZpY2UgaW5zdGFuY2VcbiAqL1xuU2VydmljZS5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IsIGVkaXRpb24sIG5lc3RlZCkge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZShkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiU2VydmljZVwiICsgdW5uYW1lZFNlcnZpY2VJbmRleCsrLCBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLlNlcnZpY2VPcHRpb25zKSk7XG4gICAgaWYgKCFuZXN0ZWQpXG4gICAgICAgIHNlcnZpY2UuX2VkaXRpb24gPSBlZGl0aW9uO1xuICAgIGlmIChkZXNjcmlwdG9yLm1ldGhvZClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjcmlwdG9yLm1ldGhvZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLm1ldGhvZFtpXSkpO1xuXG4gICAgcmV0dXJuIHNlcnZpY2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2VydmljZSB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJU2VydmljZURlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqL1xuU2VydmljZS5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKCkge1xuXG4gICAgLy8gTWV0aG9kc1xuICAgIHZhciBtZXRob2RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1ldGhvZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgbWV0aG9kcy5wdXNoKHRoaXMuX21ldGhvZHNBcnJheVtpXS50b0Rlc2NyaXB0b3IoKSk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5TZXJ2aWNlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWV0aG9kOiBtZXRob2RzLFxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5TZXJ2aWNlT3B0aW9ucylcbiAgICB9KTtcbn07XG5cbi8vIC0tLSBNZXRob2QgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE1ldGhvZERlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJTWV0aG9kRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE1ldGhvZCBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2lucHV0VHlwZV0gUmVxdWVzdCB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3V0cHV0VHlwZV0gUmVzcG9uc2UgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge0lNZXRob2RPcHRpb25zfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2xpZW50U3RyZWFtaW5nPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2VydmVyU3RyZWFtaW5nPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBNZXRob2RPcHRpb25zIG1lc3NhZ2UuXG4gKlxuICogV2FybmluZzogdGhpcyBpcyBub3Qgc2FmZSB0byB1c2Ugd2l0aCBlZGl0aW9ucyBwcm90b3MsIHNpbmNlIGl0IGRpc2NhcmRzIHJlbGV2YW50IGZpbGUgY29udGV4dC5cbiAqXG4gKiBAaW50ZXJmYWNlIElNZXRob2RPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXByZWNhdGVkXVxuICovXG5cbnZhciB1bm5hbWVkTWV0aG9kSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtZXRob2QgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lNZXRob2REZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gUmVmbGVjdGVkIG1ldGhvZCBpbnN0YW5jZVxuICovXG5NZXRob2QuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuTWV0aG9kRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIHJldHVybiBuZXcgTWV0aG9kKFxuICAgICAgICAvLyB1bm5hbWVkTWV0aG9kSW5kZXggaXMgZ2xvYmFsLCBub3QgcGVyIHNlcnZpY2UsIGJlY2F1c2Ugd2UgaGF2ZSBubyByZWYgdG8gYSBzZXJ2aWNlIGhlcmVcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIk1ldGhvZFwiICsgdW5uYW1lZE1ldGhvZEluZGV4KyssXG4gICAgICAgIFwicnBjXCIsXG4gICAgICAgIGRlc2NyaXB0b3IuaW5wdXRUeXBlLFxuICAgICAgICBkZXNjcmlwdG9yLm91dHB1dFR5cGUsXG4gICAgICAgIEJvb2xlYW4oZGVzY3JpcHRvci5jbGllbnRTdHJlYW1pbmcpLFxuICAgICAgICBCb29sZWFuKGRlc2NyaXB0b3Iuc2VydmVyU3RyZWFtaW5nKSxcbiAgICAgICAgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5NZXRob2RPcHRpb25zKVxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbWV0aG9kIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElNZXRob2REZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKCkge1xuICAgIHJldHVybiBleHBvcnRzLk1ldGhvZERlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIGlucHV0VHlwZTogdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID8gdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlLmZ1bGxOYW1lIDogdGhpcy5yZXF1ZXN0VHlwZSxcbiAgICAgICAgb3V0cHV0VHlwZTogdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA/IHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUuZnVsbE5hbWUgOiB0aGlzLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgY2xpZW50U3RyZWFtaW5nOiB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIHNlcnZlclN0cmVhbWluZzogdGhpcy5yZXNwb25zZVN0cmVhbSxcbiAgICAgICAgb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuTWV0aG9kT3B0aW9ucylcbiAgICB9KTtcbn07XG5cbi8vIC0tLSB1dGlsaXR5IC0tLVxuXG4vLyBDb252ZXJ0cyBhIGRlc2NyaXB0b3IgdHlwZSB0byBhIHByb3RvYnVmLmpzIGJhc2ljIHR5cGVcbmZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yVHlwZSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xuICAgICAgICBjYXNlIDE6IHJldHVybiBcImRvdWJsZVwiO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBcImZsb2F0XCI7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIFwiaW50NjRcIjtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gXCJ1aW50NjRcIjtcbiAgICAgICAgY2FzZSA1OiByZXR1cm4gXCJpbnQzMlwiO1xuICAgICAgICBjYXNlIDY6IHJldHVybiBcImZpeGVkNjRcIjtcbiAgICAgICAgY2FzZSA3OiByZXR1cm4gXCJmaXhlZDMyXCI7XG4gICAgICAgIGNhc2UgODogcmV0dXJuIFwiYm9vbFwiO1xuICAgICAgICBjYXNlIDk6IHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICBjYXNlIDEyOiByZXR1cm4gXCJieXRlc1wiO1xuICAgICAgICBjYXNlIDEzOiByZXR1cm4gXCJ1aW50MzJcIjtcbiAgICAgICAgY2FzZSAxNTogcmV0dXJuIFwic2ZpeGVkMzJcIjtcbiAgICAgICAgY2FzZSAxNjogcmV0dXJuIFwic2ZpeGVkNjRcIjtcbiAgICAgICAgY2FzZSAxNzogcmV0dXJuIFwic2ludDMyXCI7XG4gICAgICAgIGNhc2UgMTg6IHJldHVybiBcInNpbnQ2NFwiO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0eXBlKTtcbn1cblxuLy8gVGVzdHMgaWYgYSBkZXNjcmlwdG9yIHR5cGUgaXMgcGFja2FibGVcbmZ1bmN0aW9uIHBhY2thYmxlRGVzY3JpcHRvclR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE6IC8vIGRvdWJsZVxuICAgICAgICBjYXNlIDI6IC8vIGZsb2F0XG4gICAgICAgIGNhc2UgMzogLy8gaW50NjRcbiAgICAgICAgY2FzZSA0OiAvLyB1aW50NjRcbiAgICAgICAgY2FzZSA1OiAvLyBpbnQzMlxuICAgICAgICBjYXNlIDY6IC8vIGZpeGVkNjRcbiAgICAgICAgY2FzZSA3OiAvLyBmaXhlZDMyXG4gICAgICAgIGNhc2UgODogLy8gYm9vbFxuICAgICAgICBjYXNlIDEzOiAvLyB1aW50MzJcbiAgICAgICAgY2FzZSAxNDogLy8gZW51bSAoISlcbiAgICAgICAgY2FzZSAxNTogLy8gc2ZpeGVkMzJcbiAgICAgICAgY2FzZSAxNjogLy8gc2ZpeGVkNjRcbiAgICAgICAgY2FzZSAxNzogLy8gc2ludDMyXG4gICAgICAgIGNhc2UgMTg6IC8vIHNpbnQ2NFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ29udmVydHMgYSBwcm90b2J1Zi5qcyBiYXNpYyB0eXBlIHRvIGEgZGVzY3JpcHRvciB0eXBlXG5mdW5jdGlvbiB0b0Rlc2NyaXB0b3JUeXBlKHR5cGUsIHJlc29sdmVkVHlwZSwgZGVsaW1pdGVkKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xuICAgICAgICBjYXNlIFwiZG91YmxlXCI6IHJldHVybiAxO1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjogcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgXCJpbnQ2NFwiOiByZXR1cm4gMztcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOiByZXR1cm4gNDtcbiAgICAgICAgY2FzZSBcImludDMyXCI6IHJldHVybiA1O1xuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOiByZXR1cm4gNjtcbiAgICAgICAgY2FzZSBcImZpeGVkMzJcIjogcmV0dXJuIDc7XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiA4O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiA5O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIDEyO1xuICAgICAgICBjYXNlIFwidWludDMyXCI6IHJldHVybiAxMztcbiAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IHJldHVybiAxNTtcbiAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IHJldHVybiAxNjtcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOiByZXR1cm4gMTc7XG4gICAgICAgIGNhc2UgXCJzaW50NjRcIjogcmV0dXJuIDE4O1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgcmV0dXJuIDE0O1xuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICByZXR1cm4gZGVsaW1pdGVkID8gMTAgOiAxMTtcbiAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZnJvbURlc2NyaXB0b3JPcHRpb25zUmVjdXJzaXZlKG9iaiwgdHlwZSkge1xuICAgIHZhciB2YWwgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQsIGtleTsgaSA8IHR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKChrZXkgPSAoZmllbGQgPSB0eXBlLl9maWVsZHNBcnJheVtpXSkubmFtZSkgPT09IFwidW5pbnRlcnByZXRlZE9wdGlvblwiKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbmV3S2V5ID0gdW5kZXJTY29yZShrZXkpO1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgdmFsW25ld0tleV0gPSBmcm9tRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUob2JqW2tleV0sIGZpZWxkLnJlc29sdmVkVHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZihmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7XG4gICAgICAgICAgICB2YWxbbmV3S2V5XSA9IGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW29ialtrZXldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbFtuZXdLZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gQ29udmVydHMgZGVzY3JpcHRvciBvcHRpb25zIHRvIGFuIG9wdGlvbnMgb2JqZWN0XG5mdW5jdGlvbiBmcm9tRGVzY3JpcHRvck9wdGlvbnMob3B0aW9ucywgdHlwZSkge1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbURlc2NyaXB0b3JPcHRpb25zUmVjdXJzaXZlKHR5cGUudG9PYmplY3Qob3B0aW9ucyksIHR5cGUpO1xufVxuXG5mdW5jdGlvbiB0b0Rlc2NyaXB0b3JPcHRpb25zUmVjdXJzaXZlKG9iaiwgdHlwZSkge1xuICAgIHZhciB2YWwgPSB7fTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3S2V5ID0gJHByb3RvYnVmLnV0aWwuY2FtZWxDYXNlKGtleSk7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuZmllbGRzLCBuZXdLZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGZpZWxkID0gdHlwZS5maWVsZHNbbmV3S2V5XTtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIHZhbFtuZXdLZXldID0gdG9EZXNjcmlwdG9yT3B0aW9uc1JlY3Vyc2l2ZShvYmpba2V5XSwgZmllbGQucmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbFtuZXdLZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkICYmICFBcnJheS5pc0FycmF5KHZhbFtuZXdLZXldKSkge1xuICAgICAgICAgICAgdmFsW25ld0tleV0gPSBbdmFsW25ld0tleV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8vIENvbnZlcnRzIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGRlc2NyaXB0b3Igb3B0aW9uc1xuZnVuY3Rpb24gdG9EZXNjcmlwdG9yT3B0aW9ucyhvcHRpb25zLCB0eXBlKSB7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0eXBlLmZyb21PYmplY3QodG9EZXNjcmlwdG9yT3B0aW9uc1JlY3Vyc2l2ZShvcHRpb25zLCB0eXBlKSk7XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIHNob3J0ZXN0IHJlbGF0aXZlIHBhdGggZnJvbSBgZnJvbWAgdG8gYHRvYC5cbmZ1bmN0aW9uIHNob3J0bmFtZShmcm9tLCB0bykge1xuICAgIHZhciBmcm9tUGF0aCA9IGZyb20uZnVsbE5hbWUuc3BsaXQoXCIuXCIpLFxuICAgICAgICB0b1BhdGggPSB0by5mdWxsTmFtZS5zcGxpdChcIi5cIiksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgayA9IHRvUGF0aC5sZW5ndGggLSAxO1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBSb290KSAmJiB0byBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcbiAgICAgICAgd2hpbGUgKGkgPCBmcm9tUGF0aC5sZW5ndGggJiYgaiA8IGsgJiYgZnJvbVBhdGhbaV0gPT09IHRvUGF0aFtqXSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdG8ubG9va3VwKGZyb21QYXRoW2krK10sIHRydWUpO1xuICAgICAgICAgICAgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgIGVsc2VcbiAgICAgICAgZm9yICg7IGkgPCBmcm9tUGF0aC5sZW5ndGggJiYgaiA8IGsgJiYgZnJvbVBhdGhbaV0gPT09IHRvUGF0aFtqXTsgKytpLCArK2opO1xuICAgIHJldHVybiB0b1BhdGguc2xpY2Uoaikuam9pbihcIi5cIik7XG59XG5cbi8vIGNvcGllZCBoZXJlIGZyb20gY2xpL3RhcmdldHMvcHJvdG8uanNcbmZ1bmN0aW9uIHVuZGVyU2NvcmUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvKFtBLVpdKSg/PVthLXpdfCQpL2csIGZ1bmN0aW9uKCQwLCAkMSkgeyByZXR1cm4gXCJfXCIgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTtcbn1cblxuZnVuY3Rpb24gZWRpdGlvbkZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKSB7XG4gICAgaWYgKGZpbGVEZXNjcmlwdG9yLnN5bnRheCA9PT0gXCJlZGl0aW9uc1wiKSB7XG4gICAgICAgIHN3aXRjaChmaWxlRGVzY3JpcHRvci5lZGl0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRWRpdGlvbi5FRElUSU9OXzIwMjM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMjAyM1wiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBlZGl0aW9uIFwiICsgZmlsZURlc2NyaXB0b3IuZWRpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbGVEZXNjcmlwdG9yLnN5bnRheCA9PT0gXCJwcm90bzNcIikge1xuICAgICAgICByZXR1cm4gXCJwcm90bzNcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwicHJvdG8yXCI7XG59XG5cbmZ1bmN0aW9uIGVkaXRpb25Ub0Rlc2NyaXB0b3IoZWRpdGlvbiwgZmlsZURlc2NyaXB0b3IpIHtcbiAgICBpZiAoIWVkaXRpb24pIHJldHVybjtcbiAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzJcIiB8fCBlZGl0aW9uID09PSBcInByb3RvM1wiKSB7XG4gICAgICAgIGZpbGVEZXNjcmlwdG9yLnN5bnRheCA9IGVkaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZURlc2NyaXB0b3Iuc3ludGF4ID0gXCJlZGl0aW9uc1wiO1xuICAgICAgICBzd2l0Y2goZWRpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcIjIwMjNcIjpcbiAgICAgICAgICAgICAgICBmaWxlRGVzY3JpcHRvci5lZGl0aW9uID0gZXhwb3J0cy5FZGl0aW9uLkVESVRJT05fMjAyMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZWRpdGlvbiBcIiArIGVkaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyAtLS0gZXhwb3J0cyAtLS1cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmlsZSBkZXNjcmlwdG9yIHNldC5cbiAqIEBuYW1lIEZpbGVEZXNjcmlwdG9yU2V0XG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpbGUgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEZpbGVEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIERlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IEV4dGVuc2lvblJhbmdlXG4gKiBAcHJvcGVydHkge1R5cGV9IFJlc2VydmVkUmFuZ2VcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBFeHRlbnNpb25SYW5nZTogJHByb3RvYnVmLlR5cGUsXG4gKiAgICAgUmVzZXJ2ZWRSYW5nZTogJHByb3RvYnVmLlR5cGVcbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWVsZCBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRmllbGREZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtFbnVtfSBMYWJlbFxuICogQHByb3BlcnR5IHtFbnVtfSBUeXBlXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgTGFiZWw6ICRwcm90b2J1Zi5FbnVtLFxuICogICAgIFR5cGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgb25lb2YgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIE9uZW9mRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGVudW0gZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEVudW1EZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgc2VydmljZSBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgU2VydmljZURlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIHZhbHVlIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgbWV0aG9kIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBNZXRob2REZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmlsZSBvcHRpb25zLlxuICogQG5hbWUgRmlsZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtFbnVtfSBPcHRpbWl6ZU1vZGVcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBPcHRpbWl6ZU1vZGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgbWVzc2FnZSBvcHRpb25zLlxuICogQG5hbWUgTWVzc2FnZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmllbGQgb3B0aW9ucy5cbiAqIEBuYW1lIEZpZWxkT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge0VudW19IENUeXBlXG4gKiBAcHJvcGVydHkge0VudW19IEpTVHlwZVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIENUeXBlOiAkcHJvdG9idWYuRW51bSxcbiAqICAgICBKU1R5cGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgb25lb2Ygb3B0aW9ucy5cbiAqIEBuYW1lIE9uZW9mT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIG9wdGlvbnMuXG4gKiBAbmFtZSBFbnVtT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIHZhbHVlIG9wdGlvbnMuXG4gKiBAbmFtZSBFbnVtVmFsdWVPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHNlcnZpY2Ugb3B0aW9ucy5cbiAqIEBuYW1lIFNlcnZpY2VPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG1ldGhvZCBvcHRpb25zLlxuICogQG5hbWUgTWV0aG9kT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCB1bmludGVycHJldGV0IG9wdGlvbi5cbiAqIEBuYW1lIFVuaW50ZXJwcmV0ZWRPcHRpb25cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtUeXBlfSBOYW1lUGFydFxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIE5hbWVQYXJ0OiAkcHJvdG9idWYuVHlwZVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHNvdXJjZSBjb2RlIGluZm8uXG4gKiBAbmFtZSBTb3VyY2VDb2RlSW5mb1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IExvY2F0aW9uXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgTG9jYXRpb246ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZ2VuZXJhdGVkIGNvZGUgaW5mby5cbiAqIEBuYW1lIEdlbmVyYXRlZENvZGVJbmZvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7VHlwZX0gQW5ub3RhdGlvblxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIEFubm90YXRpb246ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cbiJdLCJuYW1lcyI6WyIkcHJvdG9idWYiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlc2NyaXB0b3IiLCJSb290IiwiZnJvbUpTT04iLCJsb29rdXAiLCJOYW1lc3BhY2UiLCJFbnVtIiwiVHlwZSIsIkZpZWxkIiwiTWFwRmllbGQiLCJPbmVPZiIsIlNlcnZpY2UiLCJNZXRob2QiLCJmcm9tRGVzY3JpcHRvciIsImxlbmd0aCIsIkZpbGVEZXNjcmlwdG9yU2V0IiwiZGVjb2RlIiwicm9vdCIsImZpbGUiLCJmaWxlRGVzY3JpcHRvciIsImZpbGVQYWNrYWdlIiwiaiIsImkiLCJkZWZpbmUiLCJlZGl0aW9uIiwiZWRpdGlvbkZyb21EZXNjcmlwdG9yIiwibmFtZSIsImZpbGVzIiwicHVzaCIsImZpbGVuYW1lIiwibWVzc2FnZVR5cGUiLCJhZGQiLCJlbnVtVHlwZSIsImV4dGVuc2lvbiIsInNlcnZpY2UiLCJvcHRzIiwiZnJvbURlc2NyaXB0b3JPcHRpb25zIiwib3B0aW9ucyIsIkZpbGVPcHRpb25zIiwia3MiLCJPYmplY3QiLCJrZXlzIiwic2V0T3B0aW9uIiwicmVzb2x2ZUFsbCIsInByb3RvdHlwZSIsInRvRGVzY3JpcHRvciIsInNldCIsImNyZWF0ZSIsIlJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlIiwibnMiLCJGaWxlRGVzY3JpcHRvclByb3RvIiwiZnVsbE5hbWUiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwiZWRpdGlvblRvRGVzY3JpcHRvciIsIm5lc3RlZCIsIm5lc3RlZEFycmF5IiwiX25lc3RlZEFycmF5IiwidG9EZXNjcmlwdG9yT3B0aW9ucyIsInVubmFtZWRNZXNzYWdlSW5kZXgiLCJEZXNjcmlwdG9yUHJvdG8iLCJ0eXBlIiwiTWVzc2FnZU9wdGlvbnMiLCJfZWRpdGlvbiIsIm9uZW9mRGVjbCIsImZpZWxkIiwiaGFzT3duUHJvcGVydHkiLCJvbmVvZnNBcnJheSIsIm9uZW9mSW5kZXgiLCJuZXN0ZWRUeXBlIiwibWFwRW50cnkiLCJleHRlbnNpb25SYW5nZSIsImV4dGVuc2lvbnMiLCJzdGFydCIsImVuZCIsInJlc2VydmVkUmFuZ2UiLCJyZXNlcnZlZE5hbWUiLCJyZXNlcnZlZCIsImZpZWxkc0FycmF5IiwiZmllbGREZXNjcmlwdG9yIiwiX2ZpZWxkc0FycmF5Iiwia2V5VHlwZSIsInRvRGVzY3JpcHRvclR5cGUiLCJyZXNvbHZlZEtleVR5cGUiLCJ2YWx1ZVR5cGUiLCJyZXNvbHZlZFR5cGUiLCJ2YWx1ZVR5cGVOYW1lIiwic2hvcnRuYW1lIiwicGFyZW50IiwidW5kZWZpbmVkIiwidHlwZU5hbWUiLCJGaWVsZERlc2NyaXB0b3JQcm90byIsIm51bWJlciIsImxhYmVsIiwiX29uZW9mc0FycmF5IiwiRXh0ZW5zaW9uUmFuZ2UiLCJSZXNlcnZlZFJhbmdlIiwibnVtYmVyUmUiLCJFcnJvciIsImZpZWxkVHlwZSIsImZyb21EZXNjcmlwdG9yVHlwZSIsImZpZWxkUnVsZSIsImV4dGVuZGVlIiwiRmllbGRPcHRpb25zIiwicHJvdG8zX29wdGlvbmFsIiwiZGVmYXVsdFZhbHVlIiwibWF0Y2giLCJleGVjIiwicGFyc2VJbnQiLCJwYWNrYWJsZURlc2NyaXB0b3JUeXBlIiwicGFja2VkIiwiaWQiLCJtYXAiLCJ1dGlsIiwidWNGaXJzdCIsInJlc29sdmUiLCJkZWxpbWl0ZWQiLCJydWxlIiwicmVxdWlyZWQiLCJleHRlbnNpb25GaWVsZCIsImV4dGVuZCIsInBhcnRPZiIsImluZGV4T2YiLCJTdHJpbmciLCJ1bm5hbWVkRW51bUluZGV4IiwiRW51bURlc2NyaXB0b3JQcm90byIsInZhbHVlcyIsInZhbHVlIiwiZW5tIiwiRW51bU9wdGlvbnMiLCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8iLCJ1bm5hbWVkT25lb2ZJbmRleCIsIk9uZW9mRGVzY3JpcHRvclByb3RvIiwidW5uYW1lZFNlcnZpY2VJbmRleCIsIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8iLCJTZXJ2aWNlT3B0aW9ucyIsIm1ldGhvZCIsIm1ldGhvZHMiLCJtZXRob2RzQXJyYXkiLCJfbWV0aG9kc0FycmF5IiwidW5uYW1lZE1ldGhvZEluZGV4IiwiTWV0aG9kRGVzY3JpcHRvclByb3RvIiwiaW5wdXRUeXBlIiwib3V0cHV0VHlwZSIsIkJvb2xlYW4iLCJjbGllbnRTdHJlYW1pbmciLCJzZXJ2ZXJTdHJlYW1pbmciLCJNZXRob2RPcHRpb25zIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXNwb25zZVR5cGUiLCJyZXNwb25zZVR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJmcm9tRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUiLCJvYmoiLCJ2YWwiLCJrZXkiLCJjYWxsIiwibmV3S2V5IiwidW5kZXJTY29yZSIsInZhbHVlc0J5SWQiLCJ0b09iamVjdCIsInRvRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUiLCJjYW1lbENhc2UiLCJmaWVsZHMiLCJyZXBlYXRlZCIsIkFycmF5IiwiaXNBcnJheSIsImZyb21PYmplY3QiLCJmcm9tIiwidG8iLCJmcm9tUGF0aCIsInNwbGl0IiwidG9QYXRoIiwiayIsIm90aGVyIiwic2xpY2UiLCJqb2luIiwic3RyIiwiJDAiLCIkMSIsInRvTG93ZXJDYXNlIiwic3ludGF4IiwiRWRpdGlvbiIsIkVESVRJT05fMjAyMyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/ext/descriptor/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/index.js":
/*!*******************************************!*\
  !*** ../node_modules/protobufjs/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// full library entry point.\n\nmodule.exports = __webpack_require__(/*! ./src/index */ \"(ssr)/../node_modules/protobufjs/src/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsNEJBQTRCO0FBRWY7QUFDYkEsd0dBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanM/MWFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdWxsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXhcIik7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/common.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/common.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nmodule.exports = common;\nvar commonRe = /\\/|\\./;\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */ function common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = {\n            nested: {\n                google: {\n                    nested: {\n                        protobuf: {\n                            nested: json\n                        }\n                    }\n                }\n            }\n        };\n    }\n    common[name] = json;\n}\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\ncommon(\"any\", {\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */ Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\nvar timeType;\ncommon(\"duration\", {\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\ncommon(\"timestamp\", {\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Timestamp: timeType\n});\ncommon(\"empty\", {\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */ Empty: {\n        fields: {}\n    }\n});\ncommon(\"struct\", {\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */ Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [nullValue]\n     * @property {number} [numberValue]\n     * @property {string} [stringValue]\n     * @property {boolean} [boolValue]\n     * @property {IStruct} [structValue]\n     * @property {IListValue} [listValue]\n     * @memberof common\n     */ Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"nullValue\",\n                    \"numberValue\",\n                    \"stringValue\",\n                    \"boolValue\",\n                    \"structValue\",\n                    \"listValue\"\n                ]\n            }\n        },\n        fields: {\n            nullValue: {\n                type: \"NullValue\",\n                id: 1\n            },\n            numberValue: {\n                type: \"double\",\n                id: 2\n            },\n            stringValue: {\n                type: \"string\",\n                id: 3\n            },\n            boolValue: {\n                type: \"bool\",\n                id: 4\n            },\n            structValue: {\n                type: \"Struct\",\n                id: 5\n            },\n            listValue: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */ ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"wrappers\", {\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */ BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */ StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */ BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"field_mask\", {\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */ common.get = function get(file) {\n    return common[file] || null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLFdBQVc7QUFFZjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNELE9BQU9FLElBQUksRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNGLFNBQVNHLElBQUksQ0FBQ0YsT0FBTztRQUN0QkEsT0FBTyxxQkFBcUJBLE9BQU87UUFDbkNDLE9BQU87WUFBRUUsUUFBUTtnQkFBRUMsUUFBUTtvQkFBRUQsUUFBUTt3QkFBRUUsVUFBVTs0QkFBRUYsUUFBUUY7d0JBQUs7b0JBQUU7Z0JBQUU7WUFBRTtRQUFFO0lBQzVFO0lBQ0FILE1BQU0sQ0FBQ0UsS0FBSyxHQUFHQztBQUNuQjtBQUVBLHFGQUFxRjtBQUNyRixFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2Qyw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGLCtGQUErRjtBQUMvRixrRUFBa0U7QUFFbEVILE9BQU8sT0FBTztJQUVWOzs7Ozs7O0tBT0MsR0FDRFEsS0FBSztRQUNEQyxRQUFRO1lBQ0pDLFVBQVU7Z0JBQ05DLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtZQUNBQyxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQSxJQUFJRTtBQUVKZCxPQUFPLFlBQVk7SUFFZjs7Ozs7OztLQU9DLEdBQ0RlLFVBQVVELFdBQVc7UUFDakJMLFFBQVE7WUFDSk8sU0FBUztnQkFDTEwsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FLLE9BQU87Z0JBQ0hOLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUVBWixPQUFPLGFBQWE7SUFFaEI7Ozs7Ozs7S0FPQyxHQUNEa0IsV0FBV0o7QUFDZjtBQUVBZCxPQUFPLFNBQVM7SUFFWjs7OztLQUlDLEdBQ0RtQixPQUFPO1FBQ0hWLFFBQVEsQ0FBQztJQUNiO0FBQ0o7QUFFQVQsT0FBTyxVQUFVO0lBRWI7Ozs7OztLQU1DLEdBQ0RvQixRQUFRO1FBQ0pYLFFBQVE7WUFDSkEsUUFBUTtnQkFDSlksU0FBUztnQkFDVFYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNEVSxPQUFPO1FBQ0hDLFFBQVE7WUFDSkMsTUFBTTtnQkFDRkMsT0FBTztvQkFDSDtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDSDtZQUNMO1FBQ0o7UUFDQWhCLFFBQVE7WUFDSmlCLFdBQVc7Z0JBQ1BmLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtZQUNBZSxhQUFhO2dCQUNUaEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FnQixhQUFhO2dCQUNUakIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FpQixXQUFXO2dCQUNQbEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FrQixhQUFhO2dCQUNUbkIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FtQixXQUFXO2dCQUNQcEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBb0IsV0FBVztRQUNQQyxRQUFRO1lBQ0pDLFlBQVk7UUFDaEI7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEQyxXQUFXO1FBQ1AxQixRQUFRO1lBQ0p3QixRQUFRO2dCQUNKRyxNQUFNO2dCQUNOekIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sWUFBWTtJQUVmOzs7Ozs7S0FNQyxHQUNEcUMsYUFBYTtRQUNUNUIsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0QwQixZQUFZO1FBQ1I3QixRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDJCLFlBQVk7UUFDUjlCLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNENEIsYUFBYTtRQUNUL0IsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0Q2QixZQUFZO1FBQ1JoQyxRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDhCLGFBQWE7UUFDVGpDLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEK0IsV0FBVztRQUNQbEMsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0RnQyxhQUFhO1FBQ1RuQyxRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRGlDLFlBQVk7UUFDUnBDLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sY0FBYztJQUVqQjs7Ozs7O0tBTUMsR0FDRDhDLFdBQVc7UUFDUHJDLFFBQVE7WUFDSnNDLE9BQU87Z0JBQ0hYLE1BQU07Z0JBQ056QixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEWixPQUFPZ0QsR0FBRyxHQUFHLFNBQVNBLElBQUlDLElBQUk7SUFDMUIsT0FBT2pELE1BQU0sQ0FBQ2lELEtBQUssSUFBSTtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb21tb24uanM/YjJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gY29tbW9uO1xuXG52YXIgY29tbW9uUmUgPSAvXFwvfFxcLi87XG5cbi8qKlxuICogUHJvdmlkZXMgY29tbW9uIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBnb29nbGUgdHlwZXMgb3IgeW91ciBvd24gY3VzdG9tIHR5cGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2hvcnQgbmFtZSBhcyBpbiBgZ29vZ2xlL3Byb3RvYnVmL1tuYW1lXS5wcm90b2Agb3IgZnVsbCBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gSlNPTiBkZWZpbml0aW9uIHdpdGhpbiBgZ29vZ2xlLnByb3RvYnVmYCBpZiBhIHNob3J0IG5hbWUsIG90aGVyd2lzZSB0aGUgZmlsZSdzIHJvb3QgZGVmaW5pdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90byBBbnlcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvIER1cmF0aW9uXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90byBFbXB0eVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90byBGaWVsZE1hc2tcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90byBTdHJ1Y3QsIFZhbHVlLCBOdWxsVmFsdWUgYW5kIExpc3RWYWx1ZVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8gV3JhcHBlcnNcbiAqIEBleGFtcGxlXG4gKiAvLyBtYW51YWxseSBwcm92aWRlcyBkZXNjcmlwdG9yLnByb3RvIChhc3N1bWVzIGdvb2dsZS9wcm90b2J1Zi8gbmFtZXNwYWNlIGFuZCAucHJvdG8gZXh0ZW5zaW9uKVxuICogcHJvdG9idWYuY29tbW9uKFwiZGVzY3JpcHRvclwiLCBkZXNjcmlwdG9ySnNvbik7XG4gKlxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgYSBjdXN0b20gZGVmaW5pdGlvbiAodXNlcyBteS5mb28gbmFtZXNwYWNlKVxuICogcHJvdG9idWYuY29tbW9uKFwibXkvZm9vL2Jhci5wcm90b1wiLCBteUZvb0Jhckpzb24pO1xuICovXG5mdW5jdGlvbiBjb21tb24obmFtZSwganNvbikge1xuICAgIGlmICghY29tbW9uUmUudGVzdChuYW1lKSkge1xuICAgICAgICBuYW1lID0gXCJnb29nbGUvcHJvdG9idWYvXCIgKyBuYW1lICsgXCIucHJvdG9cIjtcbiAgICAgICAganNvbiA9IHsgbmVzdGVkOiB7IGdvb2dsZTogeyBuZXN0ZWQ6IHsgcHJvdG9idWY6IHsgbmVzdGVkOiBqc29uIH0gfSB9IH0gfTtcbiAgICB9XG4gICAgY29tbW9uW25hbWVdID0ganNvbjtcbn1cblxuLy8gTm90IHByb3ZpZGVkIGJlY2F1c2Ugb2YgbGltaXRlZCB1c2UgKGZlZWwgZnJlZSB0byBkaXNjdXNzIG9yIHRvIHByb3ZpZGUgeW91cnNlbGYpOlxuLy9cbi8vIGdvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLnByb3RvXG4vLyBnb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQucHJvdG9cbi8vIGdvb2dsZS9wcm90b2J1Zi90eXBlLnByb3RvXG4vL1xuLy8gU3RyaXBwZWQgYW5kIHByZS1wYXJzZWQgdmVyc2lvbnMgb2YgdGhlc2Ugbm9uLWJ1bmRsZWQgZmlsZXMgYXJlIGluc3RlYWQgYXZhaWxhYmxlIGFzIHBhcnQgb2Zcbi8vIHRoZSByZXBvc2l0b3J5IG9yIHBhY2thZ2Ugd2l0aGluIHRoZSBnb29nbGUvcHJvdG9idWYgZGlyZWN0b3J5LlxuXG5jb21tb24oXCJhbnlcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5BbnkgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElBbnlcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZVVybF1cbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtieXRlc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQW55OiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdHlwZV91cmw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgdGltZVR5cGU7XG5cbmNvbW1vbihcImR1cmF0aW9uXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRHVyYXRpb24gbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEdXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3NlY29uZHNdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtuYW5vc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRHVyYXRpb246IHRpbWVUeXBlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHNlY29uZHM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW5vczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcInRpbWVzdGFtcFwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVRpbWVzdGFtcFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3NlY29uZHNdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtuYW5vc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVGltZXN0YW1wOiB0aW1lVHlwZVxufSk7XG5cbmNvbW1vbihcImVtcHR5XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRW1wdHkgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElFbXB0eVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBFbXB0eToge1xuICAgICAgICBmaWVsZHM6IHt9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcInN0cnVjdFwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVN0cnVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJVmFsdWU+fSBbZmllbGRzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBTdHJ1Y3Q6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtraW5kXVxuICAgICAqIEBwcm9wZXJ0eSB7MH0gW251bGxWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlclZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RyaW5nVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYm9vbFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7SVN0cnVjdH0gW3N0cnVjdFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7SUxpc3RWYWx1ZX0gW2xpc3RWYWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVmFsdWU6IHtcbiAgICAgICAgb25lb2ZzOiB7XG4gICAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICAgICAgb25lb2Y6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJudWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1ZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYm9vbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RydWN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaXN0VmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBudWxsVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIk51bGxWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtYmVyVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyaW5nVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9vbFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJ1Y3RWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU3RydWN0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkxpc3RWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiA2XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgTnVsbFZhbHVlOiB7XG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgTlVMTF9WQUxVRTogMFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJTGlzdFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxJVmFsdWU+fSBbdmFsdWVzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBMaXN0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwid3JhcHBlcnNcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSURvdWJsZVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBEb3VibGVWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUZsb2F0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEZsb2F0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUludDY0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgSW50NjRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVVJbnQ2NFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFVJbnQ2NFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJSW50MzJWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgSW50MzJWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVVJbnQzMlZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBVSW50MzJWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQm9vbFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQm9vbFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgU3RyaW5nVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElCeXRlc1ZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQnl0ZXNWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwiZmllbGRfbWFza1wiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSURvdWJsZVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBGaWVsZE1hc2s6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBwYXRoczoge1xuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSByb290IGRlZmluaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb21tb24gcHJvdG8gZmlsZS5cbiAqXG4gKiBCdW5kbGVkIGRlZmluaXRpb25zIGFyZTpcbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2VtcHR5LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSBQcm90byBmaWxlIG5hbWVcbiAqIEByZXR1cm5zIHtJTmFtZXNwYWNlfG51bGx9IFJvb3QgZGVmaW5pdGlvbiBvciBgbnVsbGAgaWYgbm90IGRlZmluZWRcbiAqL1xuY29tbW9uLmdldCA9IGZ1bmN0aW9uIGdldChmaWxlKSB7XG4gICAgcmV0dXJuIGNvbW1vbltmaWxlXSB8fCBudWxsO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiY29tbW9uIiwiY29tbW9uUmUiLCJuYW1lIiwianNvbiIsInRlc3QiLCJuZXN0ZWQiLCJnb29nbGUiLCJwcm90b2J1ZiIsIkFueSIsImZpZWxkcyIsInR5cGVfdXJsIiwidHlwZSIsImlkIiwidmFsdWUiLCJ0aW1lVHlwZSIsIkR1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwiVGltZXN0YW1wIiwiRW1wdHkiLCJTdHJ1Y3QiLCJrZXlUeXBlIiwiVmFsdWUiLCJvbmVvZnMiLCJraW5kIiwib25lb2YiLCJudWxsVmFsdWUiLCJudW1iZXJWYWx1ZSIsInN0cmluZ1ZhbHVlIiwiYm9vbFZhbHVlIiwic3RydWN0VmFsdWUiLCJsaXN0VmFsdWUiLCJOdWxsVmFsdWUiLCJ2YWx1ZXMiLCJOVUxMX1ZBTFVFIiwiTGlzdFZhbHVlIiwicnVsZSIsIkRvdWJsZVZhbHVlIiwiRmxvYXRWYWx1ZSIsIkludDY0VmFsdWUiLCJVSW50NjRWYWx1ZSIsIkludDMyVmFsdWUiLCJVSW50MzJWYWx1ZSIsIkJvb2xWYWx1ZSIsIlN0cmluZ1ZhbHVlIiwiQnl0ZXNWYWx1ZSIsIkZpZWxkTWFzayIsInBhdGhzIiwiZ2V0IiwiZmlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/common.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/converter.js":
/*!***************************************************!*\
  !*** ../node_modules/protobufjs/src/converter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */ var converter = exports;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(d%s){\", prop);\n            for(var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i){\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {\n                    gen(\"default:\")('if(typeof(d%s)===\"number\"){m%s=d%s;break}', prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                    (\"break\"); // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen(\"case%j:\", keys[i])(\"case %i:\", values[keys[i]])(\"m%s=%j\", prop, values[keys[i]])(\"break\");\n            }\n            gen(\"}\");\n        } else gen('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\":\n                gen(\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\":\n                gen(\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)('else if(typeof d%s===\"string\")', prop)(\"m%s=parseInt(d%s,10)\", prop, prop)('else if(typeof d%s===\"number\")', prop)(\"m%s=d%s\", prop, prop)('else if(typeof d%s===\"object\")', prop)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\":\n                gen('if(typeof d%s===\"string\")', prop)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)(\"else if(d%s.length >= 0)\", prop)(\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\":\n                gen(\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\":\n                gen(\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray;\n    var gen = util.codegen([\n        \"d\"\n    ], mtype.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");\n    if (!fields.length) return gen(\"return new this.ctor\");\n    gen(\"var m=new this.ctor\");\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), prop = util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(d%s){\", prop)('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s={}\", prop)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(d%s){\", prop)(\"if(!Array.isArray(d%s))\", prop)(\"throw TypeError(%j)\", field.fullName + \": array expected\")(\"m%s=[]\", prop)(\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")(\"}\")(\"}\");\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n            (\"if(d%s!=null){\", prop); // !== undefined && !== null\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen(\"}\");\n        }\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen(\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen('if(typeof m%s===\"number\")', prop)(\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)(\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\" : \"\", prop);\n                break;\n            case \"bytes\":\n                gen(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default:\n                gen(\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length) return util.codegen()(\"return {}\");\n    var gen = util.codegen([\n        \"m\",\n        \"o\"\n    ], mtype.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\");\n    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;\n    for(; i < fields.length; ++i)if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);\n    if (repeatedFields.length) {\n        gen(\"if(o.arrays||o.defaults){\");\n        for(i = 0; i < repeatedFields.length; ++i)gen(\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen(\"}\");\n    }\n    if (mapFields.length) {\n        gen(\"if(o.objects||o.defaults){\");\n        for(i = 0; i < mapFields.length; ++i)gen(\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen(\"}\");\n    }\n    if (normalFields.length) {\n        gen(\"if(o.defaults){\");\n        for(i = 0; i < normalFields.length; ++i){\n            var field = normalFields[i], prop = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)(\"}else\")(\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen(\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))(\"else{\")(\"d%s=%s\", prop, arrayDefault)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)(\"}\");\n            } else gen(\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        }\n        gen(\"}\");\n    }\n    var hasKs2 = false;\n    for(i = 0; i < fields.length; ++i){\n        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) {\n                hasKs2 = true;\n                gen(\"var ks2\");\n            }\n            gen(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)(\"d%s={}\", prop)(\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")(\"}\");\n        } else if (field.repeated) {\n            gen(\"if(m%s&&m%s.length){\", prop, prop)(\"d%s=[]\", prop)(\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")(\"}\");\n        } else {\n            gen(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n            if (field.partOf) gen(\"if(o.oneofs)\")(\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen(\"}\");\n    }\n    return gen(\"return d\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Q0FHQyxHQUNELElBQUlBLFlBQVlDO0FBRWhCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDREQUFRLEdBQ3ZCQyxPQUFPRCxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNFLDJCQUEyQkMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtJQUM1RCxJQUFJQyx3QkFBd0I7SUFDNUIsMEVBQTBFLEdBQzFFLElBQUlILE1BQU1JLFlBQVksRUFBRTtRQUNwQixJQUFJSixNQUFNSSxZQUFZLFlBQVlULE1BQU07WUFBRUksSUFDckMsZ0JBQWdCRztZQUNqQixJQUFLLElBQUlHLFNBQVNMLE1BQU1JLFlBQVksQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNELFNBQVNHLElBQUksR0FBR0EsSUFBSUYsS0FBS0csTUFBTSxFQUFFLEVBQUVELEVBQUc7Z0JBQ2xHLGtDQUFrQztnQkFDbEMsSUFBSUgsTUFBTSxDQUFDQyxJQUFJLENBQUNFLEVBQUUsQ0FBQyxLQUFLUixNQUFNVSxXQUFXLElBQUksQ0FBQ1AsdUJBQXVCO29CQUFFSixJQUNsRSxZQUNJLDZDQUErQ0csTUFBTUEsTUFBTUE7b0JBQ2hFLElBQUksQ0FBQ0YsTUFBTVcsUUFBUSxFQUFFWixJQUFJLHFDQUFxQztxQkFFekQsVUFBb0IsdUNBQXVDO29CQUNoRUksd0JBQXdCO2dCQUM1QjtnQkFDQUosSUFDQyxXQUFXTyxJQUFJLENBQUNFLEVBQUUsRUFDbEIsWUFBWUgsTUFBTSxDQUFDQyxJQUFJLENBQUNFLEVBQUUsQ0FBQyxFQUN2QixVQUFVTixNQUFNRyxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEVBQy9CO1lBQ1Q7WUFBRVQsSUFDRDtRQUNMLE9BQU9BLElBQ0YsNkJBQStCRyxNQUMzQix1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TztZQUFFQSxJQUNULDJDQUEyQ0csTUFBTUEsTUFDN0MsVUFBVUEsTUFDVjtZQUNHc0IseUJBQXlCekIsS0FBS0MsT0FBTyxVQUFVLEdBQUdtRCxPQUFPakQsT0FBTyxZQUNuRTtRQUNELE9BQU8sSUFBSUYsTUFBTVcsUUFBUSxFQUFFO1lBQUVaLElBQ2hDLHdCQUF3QkcsTUFBTUEsTUFDMUIsVUFBVUEsTUFDVixrQ0FBa0NBO1lBQy9Cc0IseUJBQXlCekIsS0FBS0MsT0FBTyxVQUFVLEdBQUdtRCxPQUFPakQsT0FBTyxPQUNuRTtRQUNELE9BQU87WUFBRUgsSUFDWix3Q0FBd0NHLE1BQU1GLE1BQU1vQixJQUFJLEdBQUcsNEJBQTRCO1lBQ3BGSSx5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRDtZQUN6RCxJQUFJRixNQUFNZ0MsTUFBTSxFQUFFakMsSUFDakIsZ0JBQ0ksVUFBVUYsS0FBS3lCLFFBQVEsQ0FBQ3RCLE1BQU1nQyxNQUFNLENBQUNaLElBQUksR0FBR3BCLE1BQU1vQixJQUFJO1FBQzNEO1FBQ0FyQixJQUNIO0lBQ0Q7SUFDQSxPQUFPQSxJQUNOO0FBQ0QseUVBQXlFLEdBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbnZlcnRlci5qcz9kZjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSdW50aW1lIG1lc3NhZ2UgZnJvbS90byBwbGFpbiBvYmplY3QgY29udmVydGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGNvbnZlcnRlciA9IGV4cG9ydHM7XG5cbnZhciBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIGZyb21PYmplY3QgY29udmV0ZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICB2YXIgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gZmFsc2U7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goZCVzKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBmb3IgKHZhciB2YWx1ZXMgPSBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzLCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW51bSB1bmtub3duIHZhbHVlcyBwYXNzdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5c1tpXV0gPT09IGZpZWxkLnR5cGVEZWZhdWx0ICYmICFkZWZhdWx0QWxyZWFkeUVtaXR0ZWQpIHsgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YoZCVzKT09PVxcXCJudW1iZXJcXFwiKXttJXM9ZCVzO2JyZWFrfVwiLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZCkgZ2VuIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgdmFsdWUgb25seSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5cywgdG8gYXZvaWQgbGVhdmluZyBob2xlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpOyAgICAgICAgICAgLy8gZm9yIG5vbi1yZXBlYXRlZCBmaWVsZHMsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBbHJlYWR5RW1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImNhc2UlajpcIiwga2V5c1tpXSlcbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz0lalwiLCBwcm9wLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAgICAgKFwibSVzPXR5cGVzWyVpXS5mcm9tT2JqZWN0KGQlcylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPU51bWJlcihkJXMpXCIsIHByb3AsIHByb3ApOyAvLyBhbHNvIGNhdGNoZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzPj4+MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXN8MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih1dGlsLkxvbmcpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIihtJXM9dXRpbC5Mb25nLmZyb21WYWx1ZShkJXMpKS51bnNpZ25lZD0lalwiLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9cGFyc2VJbnQoZCVzLDEwKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1uZXcgdXRpbC5Mb25nQml0cyhkJXMubG93Pj4+MCxkJXMuaGlnaD4+PjApLnRvTnVtYmVyKCVzKVwiLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzPT09XFxcInN0cmluZ1xcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcInV0aWwuYmFzZTY0LmRlY29kZShkJXMsbSVzPXV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aChkJXMpKSwwKVwiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYoZCVzLmxlbmd0aCA+PSAwKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9U3RyaW5nKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9Qm9vbGVhbihkJXMpXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhazsgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBsYWluIG9iamVjdCB0byBydW50aW1lIG1lc3NhZ2UgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXk7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJkXCJdLCBtdHlwZS5uYW1lICsgXCIkZnJvbU9iamVjdFwiKVxuICAgIChcImlmKGQgaW5zdGFuY2VvZiB0aGlzLmN0b3IpXCIpXG4gICAgICAgIChcInJldHVybiBkXCIpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aCkgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBuZXcgdGhpcy5jdG9yXCIpO1xuICAgIGdlblxuICAgIChcInZhciBtPW5ldyB0aGlzLmN0b3JcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBwcm9wICAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyhkJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2tzW2ldXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheShkJXMpKVwiLCBwcm9wKVxuICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBhcnJheSBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTxkJXMubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJbaV1cIilcbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlbiAvLyBubyBuZWVkIHRvIHRlc3QgZm9yIG51bGwvdW5kZWZpbmVkIGlmIGFuIGVudW0gKHVzZXMgc3dpdGNoKVxuICAgIChcImlmKGQlcyE9bnVsbCl7XCIsIHByb3ApOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCk7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuXG4gICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHRvT2JqZWN0IGNvbnZlcnRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8odHlwZXNbJWldLnZhbHVlc1ttJXNdPT09dW5kZWZpbmVkP20lczp0eXBlc1slaV0udmFsdWVzW20lc10pOm0lc1wiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wKTtcbiAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcImQlcz10eXBlc1slaV0udG9PYmplY3QobSVzLG8pXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uanNvbiYmIWlzRmluaXRlKG0lcyk/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgKFwiaWYodHlwZW9mIG0lcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgKFwiZWxzZVwiKSAvLyBMb25nLWxpa2VcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz91dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobSVzKTpvLmxvbmdzPT09TnVtYmVyP25ldyB1dGlsLkxvbmdCaXRzKG0lcy5sb3c+Pj4wLG0lcy5oaWdoPj4+MCkudG9OdW1iZXIoJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCI6IFwiXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uYnl0ZXM9PT1TdHJpbmc/dXRpbC5iYXNlNjQuZW5jb2RlKG0lcywwLG0lcy5sZW5ndGgpOm8uYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW0lc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSB0byBwbGFpbiBvYmplY3QgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheS5zbGljZSgpLnNvcnQodXRpbC5jb21wYXJlRmllbGRzQnlJZCk7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdXRpbC5jb2RlZ2VuKCkoXCJyZXR1cm4ge31cIik7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwib1wiXSwgbXR5cGUubmFtZSArIFwiJHRvT2JqZWN0XCIpXG4gICAgKFwiaWYoIW8pXCIpXG4gICAgICAgIChcIm89e31cIilcbiAgICAoXCJ2YXIgZD17fVwiKTtcblxuICAgIHZhciByZXBlYXRlZEZpZWxkcyA9IFtdLFxuICAgICAgICBtYXBGaWVsZHMgPSBbXSxcbiAgICAgICAgbm9ybWFsRmllbGRzID0gW10sXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoIWZpZWxkc1tpXS5wYXJ0T2YpXG4gICAgICAgICAgICAoIGZpZWxkc1tpXS5yZXNvbHZlKCkucmVwZWF0ZWQgPyByZXBlYXRlZEZpZWxkc1xuICAgICAgICAgICAgOiBmaWVsZHNbaV0ubWFwID8gbWFwRmllbGRzXG4gICAgICAgICAgICA6IG5vcm1hbEZpZWxkcykucHVzaChmaWVsZHNbaV0pO1xuXG4gICAgaWYgKHJlcGVhdGVkRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLmFycmF5c3x8by5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0ZWRGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9W11cIiwgdXRpbC5zYWZlUHJvcChyZXBlYXRlZEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG1hcEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5vYmplY3RzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXBGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9e31cIiwgdXRpbC5zYWZlUHJvcChtYXBGaWVsZHNbaV0ubmFtZSkpO1xuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vcm1hbEZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbm9ybWFsRmllbGRzW2ldLFxuICAgICAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgKFwiZCVzPW8uZW51bXM9PT1TdHJpbmc/JWo6JWpcIiwgcHJvcCwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbZmllbGQudHlwZURlZmF1bHRdLCBmaWVsZC50eXBlRGVmYXVsdCk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5sb25nKSBnZW5cbiAgICAgICAgKFwiaWYodXRpbC5Mb25nKXtcIilcbiAgICAgICAgICAgIChcInZhciBuPW5ldyB1dGlsLkxvbmcoJWksJWksJWopXCIsIGZpZWxkLnR5cGVEZWZhdWx0LmxvdywgZmllbGQudHlwZURlZmF1bHQuaGlnaCwgZmllbGQudHlwZURlZmF1bHQudW5zaWduZWQpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9uLnRvU3RyaW5nKCk6by5sb25ncz09PU51bWJlcj9uLnRvTnVtYmVyKCk6blwiLCBwcm9wKVxuICAgICAgICAoXCJ9ZWxzZVwiKVxuICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/JWo6JWlcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQudG9TdHJpbmcoKSwgZmllbGQudHlwZURlZmF1bHQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5ieXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHQgPSBcIltcIiArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpZWxkLnR5cGVEZWZhdWx0KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAoXCJpZihvLmJ5dGVzPT09U3RyaW5nKWQlcz0lalwiLCBwcm9wLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZmllbGQudHlwZURlZmF1bHQpKVxuICAgICAgICAoXCJlbHNle1wiKVxuICAgICAgICAgICAgKFwiZCVzPSVzXCIsIHByb3AsIGFycmF5RGVmYXVsdClcbiAgICAgICAgICAgIChcImlmKG8uYnl0ZXMhPT1BcnJheSlkJXM9dXRpbC5uZXdCdWZmZXIoZCVzKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGdlblxuICAgICAgICAoXCJkJXM9JWpcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQpOyAvLyBhbHNvIG1lc3NhZ2VzICg9bnVsbClcbiAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICB2YXIgaGFzS3MyID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV0sXG4gICAgICAgICAgICBpbmRleCA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICAgICAgaWYgKCFoYXNLczIpIHsgaGFzS3MyID0gdHJ1ZTsgZ2VuXG4gICAgKFwidmFyIGtzMlwiKTtcbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwiaWYobSVzJiYoa3MyPU9iamVjdC5rZXlzKG0lcykpLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPGtzMi5sZW5ndGg7KytqKXtcIik7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJba3MyW2pdXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKG0lcyYmbSVzLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPG0lcy5sZW5ndGg7KytqKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJbal1cIilcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHsgZ2VuXG4gICAgKFwiaWYobSVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHByb3AsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3ApO1xuICAgICAgICBpZiAoZmllbGQucGFydE9mKSBnZW5cbiAgICAgICAgKFwiaWYoby5vbmVvZnMpXCIpXG4gICAgICAgICAgICAoXCJkJXM9JWpcIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5wYXJ0T2YubmFtZSksIGZpZWxkLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gZFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn07XG4iXSwibmFtZXMiOlsiY29udmVydGVyIiwiZXhwb3J0cyIsIkVudW0iLCJyZXF1aXJlIiwidXRpbCIsImdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0IiwiZ2VuIiwiZmllbGQiLCJmaWVsZEluZGV4IiwicHJvcCIsImRlZmF1bHRBbHJlYWR5RW1pdHRlZCIsInJlc29sdmVkVHlwZSIsInZhbHVlcyIsImtleXMiLCJPYmplY3QiLCJpIiwibGVuZ3RoIiwidHlwZURlZmF1bHQiLCJyZXBlYXRlZCIsImZ1bGxOYW1lIiwiaXNVbnNpZ25lZCIsInR5cGUiLCJmcm9tT2JqZWN0IiwibXR5cGUiLCJmaWVsZHMiLCJmaWVsZHNBcnJheSIsImNvZGVnZW4iLCJuYW1lIiwicmVzb2x2ZSIsInNhZmVQcm9wIiwibWFwIiwiZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0IiwidG9PYmplY3QiLCJzbGljZSIsInNvcnQiLCJjb21wYXJlRmllbGRzQnlJZCIsInJlcGVhdGVkRmllbGRzIiwibWFwRmllbGRzIiwibm9ybWFsRmllbGRzIiwicGFydE9mIiwicHVzaCIsInZhbHVlc0J5SWQiLCJsb25nIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwidG9TdHJpbmciLCJ0b051bWJlciIsImJ5dGVzIiwiYXJyYXlEZWZhdWx0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiam9pbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiaGFzS3MyIiwiaW5kZXgiLCJfZmllbGRzQXJyYXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/converter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/decoder.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/decoder.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = decoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"r\",\n        \"l\",\n        \"e\"\n    ], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) {\n        return field.map;\n    }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\")(\"if(t===e)\")(\"break\")(\"switch(t>>>3){\");\n    var i = 0;\n    for(; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, ref = \"m\" + util.safeProp(field.name);\n        gen(\"case %i: {\", field.id);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n            if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);\n            else gen(\"k=null\");\n            if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);\n            else gen(\"value=null\");\n            gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n            if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen(\"value=r.%s()\", type);\n            gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n            if (types.long[field.keyType] !== undefined) gen('%s[typeof k===\"object\"?util.longToHash(k):k]=value', ref);\n            else gen(\"%s[k]=value\", ref);\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref);\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\");\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.delimited ? \"%s.push(types[%i].decode(r,undefined,((t&~7)|4)))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen(\"%s.push(r.%s())\", ref, type);\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.delimited ? \"%s=types[%i].decode(r,undefined,((t&~7)|4))\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen(\"%s=r.%s()\", ref, type);\n        gen(\"break\")(\"}\");\n    // Unknown fields\n    }\n    gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\");\n    // Field presence\n    for(i = 0; i < mtype._fieldsArray.length; ++i){\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFVQyxtQkFBT0EsQ0FBQyw0REFBUSxHQUMxQkMsUUFBVUQsbUJBQU9BLENBQUMsOERBQVMsR0FDM0JFLE9BQVVGLG1CQUFPQSxDQUFDLDREQUFRO0FBRTlCLFNBQVNHLFFBQVFDLEtBQUs7SUFDbEIsT0FBTyx1QkFBdUJBLE1BQU1DLElBQUksR0FBRztBQUMvQztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTUCxRQUFRUSxLQUFLO0lBQ2xCLDBDQUEwQyxHQUMxQyxJQUFJQyxNQUFNTCxLQUFLTSxPQUFPLENBQUM7UUFBQztRQUFLO1FBQUs7S0FBSSxFQUFFRixNQUFNRCxJQUFJLEdBQUcsV0FDcEQsOEJBQ0ksc0JBQ0osc0RBQXVEQyxDQUFBQSxNQUFNRyxXQUFXLENBQUNDLE1BQU0sQ0FBQyxTQUFTTixLQUFLO1FBQUksT0FBT0EsTUFBTU8sR0FBRztJQUFFLEdBQUdDLE1BQU0sR0FBRyxhQUFhLEVBQUMsR0FDOUksbUJBQ0ksb0JBQ0EsYUFDSSxTQUNKO0lBRUwsSUFBSUMsSUFBSTtJQUNSLE1BQU9BLElBQUksZUFBZSxHQUFHUCxNQUFNRyxXQUFXLENBQUNHLE1BQU0sRUFBRSxFQUFFQyxFQUFHO1FBQ3hELElBQUlULFFBQVFFLE1BQU1RLFlBQVksQ0FBQ0QsRUFBRSxDQUFDRSxPQUFPLElBQ3JDQyxPQUFRWixNQUFNYSxZQUFZLFlBQVlsQixPQUFPLFVBQVVLLE1BQU1ZLElBQUksRUFDakVFLE1BQVEsTUFBTWhCLEtBQUtpQixRQUFRLENBQUNmLE1BQU1DLElBQUk7UUFBR0UsSUFDeEMsY0FBY0gsTUFBTWdCLEVBQUU7UUFFM0IsYUFBYTtRQUNiLElBQUloQixNQUFNTyxHQUFHLEVBQUU7WUFBRUosSUFDUiw2QkFBNkJXLEtBQ3pCLFNBQVNBLEtBQ2I7WUFFTCxJQUFJakIsTUFBTW9CLFFBQVEsQ0FBQ2pCLE1BQU1rQixPQUFPLENBQUMsS0FBS0MsV0FBV2hCLElBQzVDLFFBQVFOLE1BQU1vQixRQUFRLENBQUNqQixNQUFNa0IsT0FBTyxDQUFDO2lCQUNyQ2YsSUFDQTtZQUVMLElBQUlOLE1BQU1vQixRQUFRLENBQUNMLEtBQUssS0FBS08sV0FBV2hCLElBQ25DLFlBQVlOLE1BQU1vQixRQUFRLENBQUNMLEtBQUs7aUJBQ2hDVCxJQUNBO1lBRUxBLElBQ0ssb0JBQ0ksdUJBQ0EscUJBQ0ksMkJBQTJCSCxNQUFNa0IsT0FBTyxFQUN4QztZQUViLElBQUlyQixNQUFNdUIsS0FBSyxDQUFDUixLQUFLLEtBQUtPLFdBQVdoQixJQUNwQix3Q0FBd0NNLElBQUksa0JBQWtCO2lCQUMxRU4sSUFDWSxnQkFBZ0JTO1lBRWpDVCxJQUNpQixTQUNKLFlBQ0ksc0JBQ0EsU0FDUixLQUNKO1lBRUwsSUFBSU4sTUFBTXdCLElBQUksQ0FBQ3JCLE1BQU1rQixPQUFPLENBQUMsS0FBS0MsV0FBV2hCLElBQ3hDLHNEQUF3RFc7aUJBQ3hEWCxJQUNBLGVBQWVXO1FBRXhCLGtCQUFrQjtRQUNsQixPQUFPLElBQUlkLE1BQU1zQixRQUFRLEVBQUU7WUFBRW5CLElBRXBCLHdCQUF3QlcsS0FBS0EsS0FDekIsU0FBU0E7WUFFbEIsZ0VBQWdFO1lBQ2hFLElBQUlqQixNQUFNMEIsTUFBTSxDQUFDWCxLQUFLLEtBQUtPLFdBQVdoQixJQUNqQyxrQkFDSSwyQkFDQSxtQkFDSSxtQkFBbUJXLEtBQUtGLE1BQ2hDO1lBRUwsYUFBYTtZQUNiLElBQUlmLE1BQU11QixLQUFLLENBQUNSLEtBQUssS0FBS08sV0FBV2hCLElBQUlILE1BQU13QixTQUFTLEdBQzlDLHNEQUNBLDJDQUEyQ1YsS0FBS0w7aUJBQ3JETixJQUNJLG1CQUFtQlcsS0FBS0Y7UUFFckMsZUFBZTtRQUNmLE9BQU8sSUFBSWYsTUFBTXVCLEtBQUssQ0FBQ1IsS0FBSyxLQUFLTyxXQUFXaEIsSUFBSUgsTUFBTXdCLFNBQVMsR0FDckQsZ0RBQ0EscUNBQXFDVixLQUFLTDthQUMvQ04sSUFDSSxhQUFhVyxLQUFLRjtRQUMzQlQsSUFDUyxTQUNKO0lBQ0wsaUJBQWlCO0lBQ3JCO0lBQUVBLElBQ08sWUFDSSxtQkFDQSxTQUVSLEtBQ0o7SUFFRCxpQkFBaUI7SUFDakIsSUFBS00sSUFBSSxHQUFHQSxJQUFJUCxNQUFNUSxZQUFZLENBQUNGLE1BQU0sRUFBRSxFQUFFQyxFQUFHO1FBQzVDLElBQUlnQixTQUFTdkIsTUFBTVEsWUFBWSxDQUFDRCxFQUFFO1FBQ2xDLElBQUlnQixPQUFPQyxRQUFRLEVBQUV2QixJQUN4Qiw2QkFBNkJzQixPQUFPeEIsSUFBSSxFQUNwQyw2Q0FBNkNGLFFBQVEwQjtJQUMxRDtJQUVBLE9BQU90QixJQUNOO0FBQ0QseUNBQXlDLEdBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2RlY29kZXIuanM/ODE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlcjtcblxudmFyIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBcIm1pc3NpbmcgcmVxdWlyZWQgJ1wiICsgZmllbGQubmFtZSArIFwiJ1wiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29kZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJyXCIsIFwibFwiLCBcImVcIl0sIG10eXBlLm5hbWUgKyBcIiRkZWNvZGVcIilcbiAgICAoXCJpZighKHIgaW5zdGFuY2VvZiBSZWFkZXIpKVwiKVxuICAgICAgICAoXCJyPVJlYWRlci5jcmVhdGUocilcIilcbiAgICAoXCJ2YXIgYz1sPT09dW5kZWZpbmVkP3IubGVuOnIucG9zK2wsbT1uZXcgdGhpcy5jdG9yXCIgKyAobXR5cGUuZmllbGRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGZpZWxkKSB7IHJldHVybiBmaWVsZC5tYXA7IH0pLmxlbmd0aCA/IFwiLGssdmFsdWVcIiA6IFwiXCIpKVxuICAgIChcIndoaWxlKHIucG9zPGMpe1wiKVxuICAgICAgICAoXCJ2YXIgdD1yLnVpbnQzMigpXCIpXG4gICAgICAgIChcImlmKHQ9PT1lKVwiKVxuICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgKFwic3dpdGNoKHQ+Pj4zKXtcIik7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgdHlwZSAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpOyBnZW5cbiAgICAgICAgICAgIChcImNhc2UgJWk6IHtcIiwgZmllbGQuaWQpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZiglcz09PXV0aWwuZW1wdHlPYmplY3QpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwiJXM9e31cIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInZhciBjMiA9IHIudWludDMyKCkrci5wb3NcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJrPSVqXCIsIHR5cGVzLmRlZmF1bHRzW2ZpZWxkLmtleVR5cGVdKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaz1udWxsXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwidmFsdWU9JWpcIiwgdHlwZXMuZGVmYXVsdHNbdHlwZV0pO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT1udWxsXCIpO1xuXG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMil7XCIpXG4gICAgICAgICAgICAgICAgICAgIChcInZhciB0YWcyPXIudWludDMyKClcIilcbiAgICAgICAgICAgICAgICAgICAgKFwic3dpdGNoKHRhZzI+Pj4zKXtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMTogaz1yLiVzKCk7IGJyZWFrXCIsIGZpZWxkLmtleVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjYXNlIDI6XCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwidmFsdWU9dHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpXCIsIGkpOyAvLyBjYW4ndCBiZSBncm91cHNcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwidmFsdWU9ci4lcygpXCIsIHR5cGUpO1xuXG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJyLnNraXBUeXBlKHRhZzImNylcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ9XCIpXG4gICAgICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmxvbmdbZmllbGQua2V5VHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXNbdHlwZW9mIGs9PT1cXFwib2JqZWN0XFxcIj91dGlsLmxvbmdUb0hhc2goayk6a109dmFsdWVcIiwgcmVmKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXNba109dmFsdWVcIiwgcmVmKTtcblxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cblxuICAgICAgICAgICAgICAgIChcImlmKCEoJXMmJiVzLmxlbmd0aCkpXCIsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCIlcz1bXVwiLCByZWYpO1xuXG4gICAgICAgICAgICAvLyBQYWNrYWJsZSAoYWx3YXlzIGNoZWNrIGZvciBmb3J3YXJkIGFuZCBiYWNrd2FyZCBjb21wYXRpYmxpdHkpXG4gICAgICAgICAgICBpZiAodHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcImlmKCh0JjcpPT09Mil7XCIpXG4gICAgICAgICAgICAgICAgICAgIChcInZhciBjMj1yLnVpbnQzMigpK3IucG9zXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIndoaWxlKHIucG9zPGMyKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiJXMucHVzaChyLiVzKCkpXCIsIHJlZiwgdHlwZSlcbiAgICAgICAgICAgICAgICAoXCJ9ZWxzZVwiKTtcblxuICAgICAgICAgICAgLy8gTm9uLXBhY2tlZFxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5kZWxpbWl0ZWRcbiAgICAgICAgICAgICAgICAgICAgPyBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHVuZGVmaW5lZCwoKHQmfjcpfDQpKSlcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiJXMucHVzaCh0eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSkpXCIsIHJlZiwgaSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgICAgICAoXCIlcy5wdXNoKHIuJXMoKSlcIiwgcmVmLCB0eXBlKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW4oZmllbGQuZGVsaW1pdGVkXG4gICAgICAgICAgICAgICAgPyBcIiVzPXR5cGVzWyVpXS5kZWNvZGUocix1bmRlZmluZWQsKCh0Jn43KXw0KSlcIlxuICAgICAgICAgICAgICAgIDogXCIlcz10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgcmVmLCBpKTtcbiAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlcz1yLiVzKClcIiwgcmVmLCB0eXBlKTtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIC8vIFVua25vd24gZmllbGRzXG4gICAgfSBnZW5cbiAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0JjcpXCIpXG4gICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcblxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgIC8vIEZpZWxkIHByZXNlbmNlXG4gICAgZm9yIChpID0gMDsgaSA8IG10eXBlLl9maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldO1xuICAgICAgICBpZiAocmZpZWxkLnJlcXVpcmVkKSBnZW5cbiAgICAoXCJpZighbS5oYXNPd25Qcm9wZXJ0eSglaikpXCIsIHJmaWVsZC5uYW1lKVxuICAgICAgICAoXCJ0aHJvdyB1dGlsLlByb3RvY29sRXJyb3IoJWose2luc3RhbmNlOm19KVwiLCBtaXNzaW5nKHJmaWVsZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImRlY29kZXIiLCJFbnVtIiwicmVxdWlyZSIsInR5cGVzIiwidXRpbCIsIm1pc3NpbmciLCJmaWVsZCIsIm5hbWUiLCJtdHlwZSIsImdlbiIsImNvZGVnZW4iLCJmaWVsZHNBcnJheSIsImZpbHRlciIsIm1hcCIsImxlbmd0aCIsImkiLCJfZmllbGRzQXJyYXkiLCJyZXNvbHZlIiwidHlwZSIsInJlc29sdmVkVHlwZSIsInJlZiIsInNhZmVQcm9wIiwiaWQiLCJkZWZhdWx0cyIsImtleVR5cGUiLCJ1bmRlZmluZWQiLCJiYXNpYyIsImxvbmciLCJyZXBlYXRlZCIsInBhY2tlZCIsImRlbGltaXRlZCIsInJmaWVsZCIsInJlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/encoder.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/encoder.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = encoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genTypePartial(gen, field, fieldIndex, ref) {\n    return field.delimited ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var gen = util.codegen([\n        \"m\",\n        \"w\"\n    ], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n    var i, ref;\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, wireType = types.basic[type];\n        ref = \"m\" + util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n            (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) {\n                gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n            // Non-packed\n            } else {\n                gen(\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n            }\n            gen(\"}\");\n        // Non-repeated\n        } else {\n            if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n            if (wireType === undefined) genTypePartial(gen, field, index, ref);\n            else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n        }\n    }\n    return gen(\"return w\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFXQyxtQkFBT0EsQ0FBQyw0REFBUSxHQUMzQkMsUUFBV0QsbUJBQU9BLENBQUMsOERBQVMsR0FDNUJFLE9BQVdGLG1CQUFPQSxDQUFDLDREQUFRO0FBRS9COzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0csZUFBZUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRztJQUMvQyxPQUFPRixNQUFNRyxTQUFTLEdBQ2hCSixJQUFJLGdEQUFnREUsWUFBWUMsS0FBSyxDQUFDRixNQUFNSSxFQUFFLElBQUksSUFBSSxPQUFPLEdBQUcsQ0FBQ0osTUFBTUksRUFBRSxJQUFJLElBQUksT0FBTyxLQUN4SEwsSUFBSSxxREFBcURFLFlBQVlDLEtBQUssQ0FBQ0YsTUFBTUksRUFBRSxJQUFJLElBQUksT0FBTztBQUM1RztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTWCxRQUFRWSxLQUFLO0lBQ2xCLDBFQUEwRSxHQUMxRSxJQUFJTixNQUFNRixLQUFLUyxPQUFPLENBQUM7UUFBQztRQUFLO0tBQUksRUFBRUQsTUFBTUUsSUFBSSxHQUFHLFdBQy9DLFVBQ0k7SUFFTCxJQUFJQyxHQUFHTjtJQUVQLGlHQUFpRztJQUNqRyxJQUFJTyxTQUFTLGVBQWUsR0FBR0osTUFBTUssV0FBVyxDQUFDQyxLQUFLLEdBQUdDLElBQUksQ0FBQ2YsS0FBS2dCLGlCQUFpQjtJQUVwRixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSUMsT0FBT0ssTUFBTSxFQUFFLEVBQUVOLEVBQUc7UUFDcEMsSUFBSVIsUUFBV1MsTUFBTSxDQUFDRCxFQUFFLENBQUNPLE9BQU8sSUFDNUJDLFFBQVdYLE1BQU1ZLFlBQVksQ0FBQ0MsT0FBTyxDQUFDbEIsUUFDdENtQixPQUFXbkIsTUFBTW9CLFlBQVksWUFBWTFCLE9BQU8sVUFBVU0sTUFBTW1CLElBQUksRUFDcEVFLFdBQVd6QixNQUFNMEIsS0FBSyxDQUFDSCxLQUFLO1FBQzVCakIsTUFBVyxNQUFNTCxLQUFLMEIsUUFBUSxDQUFDdkIsTUFBTU8sSUFBSTtRQUU3QyxhQUFhO1FBQ2IsSUFBSVAsTUFBTXdCLEdBQUcsRUFBRTtZQUNYekIsSUFDUCxtREFBbURHLEtBQUtGLE1BQU1PLElBQUksRUFBRSw0QkFBNEI7YUFDNUYsb0RBQW9ETCxLQUNoRCw0Q0FBNEMsQ0FBQ0YsTUFBTUksRUFBRSxJQUFJLElBQUksT0FBTyxHQUFHLElBQUlSLE1BQU02QixNQUFNLENBQUN6QixNQUFNMEIsT0FBTyxDQUFDLEVBQUUxQixNQUFNMEIsT0FBTztZQUN0SCxJQUFJTCxhQUFhTSxXQUFXNUIsSUFDM0IscUVBQXFFaUIsT0FBT2QsTUFBTSxrQkFBa0I7aUJBQ2hHSCxJQUNKLHNDQUFzQyxLQUFLc0IsVUFBVUYsTUFBTWpCO1lBQzVESCxJQUNILEtBQ0o7UUFFTyxrQkFBa0I7UUFDdEIsT0FBTyxJQUFJQyxNQUFNNEIsUUFBUSxFQUFFO1lBQUU3QixJQUNoQyw0QkFBNEJHLEtBQUtBLE1BQU0sNEJBQTRCO1lBRTVELGtCQUFrQjtZQUNsQixJQUFJRixNQUFNNkIsTUFBTSxJQUFJakMsTUFBTWlDLE1BQU0sQ0FBQ1YsS0FBSyxLQUFLUSxXQUFXO2dCQUFFNUIsSUFFM0QsdUJBQXVCLENBQUNDLE1BQU1JLEVBQUUsSUFBSSxJQUFJLE9BQU8sR0FDL0MsZ0NBQWdDRixLQUM1QixlQUFlaUIsTUFBTWpCLEtBQ3pCO1lBRUcsYUFBYTtZQUNiLE9BQU87Z0JBQUVILElBRVosZ0NBQWdDRztnQkFDekIsSUFBSW1CLGFBQWFNLFdBQ3JCN0IsZUFBZUMsS0FBS0MsT0FBT2dCLE9BQU9kLE1BQU07cUJBQy9CSCxJQUNSLDBCQUEwQixDQUFDQyxNQUFNSSxFQUFFLElBQUksSUFBSWlCLFFBQU8sTUFBTyxHQUFHRixNQUFNakI7WUFFbkU7WUFBRUgsSUFDVDtRQUVHLGVBQWU7UUFDZixPQUFPO1lBQ0gsSUFBSUMsTUFBTThCLFFBQVEsRUFBRS9CLElBQzNCLGtEQUFrREcsS0FBS0YsTUFBTU8sSUFBSSxHQUFHLDRCQUE0QjtZQUV6RixJQUFJYyxhQUFhTSxXQUNyQjdCLGVBQWVDLEtBQUtDLE9BQU9nQixPQUFPZDtpQkFDekJILElBQ1IsdUJBQXVCLENBQUNDLE1BQU1JLEVBQUUsSUFBSSxJQUFJaUIsUUFBTyxNQUFPLEdBQUdGLE1BQU1qQjtRQUVoRTtJQUNKO0lBRUEsT0FBT0gsSUFDTjtBQUNELHlFQUF5RSxHQUM3RSIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9lbmNvZGVyLmpzPzcwODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZXI7XG5cbnZhciBFbnVtICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBtZXNzYWdlIHR5cGUgZW5jb2Rlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICByZXR1cm4gZmllbGQuZGVsaW1pdGVkXG4gICAgICAgID8gZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkpLnVpbnQzMiglaSlcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDMpID4+PiAwLCAoZmllbGQuaWQgPDwgMyB8IDQpID4+PiAwKVxuICAgICAgICA6IGdlbihcInR5cGVzWyVpXS5lbmNvZGUoJXMsdy51aW50MzIoJWkpLmZvcmsoKSkubGRlbGltKClcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gZW5jb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBlbmNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIndcIl0sIG10eXBlLm5hbWUgKyBcIiRlbmNvZGVcIilcbiAgICAoXCJpZighdylcIilcbiAgICAgICAgKFwidz1Xcml0ZXIuY3JlYXRlKClcIik7XG5cbiAgICB2YXIgaSwgcmVmO1xuXG4gICAgLy8gXCJ3aGVuIGEgbWVzc2FnZSBpcyBzZXJpYWxpemVkIGl0cyBrbm93biBmaWVsZHMgc2hvdWxkIGJlIHdyaXR0ZW4gc2VxdWVudGlhbGx5IGJ5IGZpZWxkIG51bWJlclwiXG4gICAgdmFyIGZpZWxkcyA9IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCAgICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBpbmRleCAgICA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHR5cGUgICAgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICB3aXJlVHlwZSA9IHR5cGVzLmJhc2ljW3R5cGVdO1xuICAgICAgICAgICAgcmVmICAgICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpe1wiLCByZWYsIGZpZWxkLm5hbWUpIC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyglcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHJlZilcbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKCkudWludDMyKCVpKS4lcyhrc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCwgOCB8IHR5cGVzLm1hcEtleVtmaWVsZC5rZXlUeXBlXSwgZmllbGQua2V5VHlwZSk7XG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0eXBlc1slaV0uZW5jb2RlKCVzW2tzW2ldXSx3LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKS5sZGVsaW0oKVwiLCBpbmRleCwgcmVmKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwiLnVpbnQzMiglaSkuJXMoJXNba3NbaV1dKS5sZGVsaW0oKVwiLCAxNiB8IHdpcmVUeXBlLCB0eXBlLCByZWYpO1xuICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmJXMubGVuZ3RoKXtcIiwgcmVmLCByZWYpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIC8vIFBhY2tlZCByZXBlYXRlZFxuICAgICAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCAmJiB0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgeyBnZW5cblxuICAgICAgICAoXCJ3LnVpbnQzMiglaSkuZm9yaygpXCIsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy4lcyglc1tpXSlcIiwgdHlwZSwgcmVmKVxuICAgICAgICAoXCJ3LmxkZWxpbSgpXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICB9IGVsc2UgeyBnZW5cblxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmICsgXCJbaV1cIik7XG4gICAgICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS4lcyglc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgKFwiaWYoJXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sJWopKVwiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgIChcIncudWludDMyKCVpKS4lcyglcylcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gd1wiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZW5jb2RlciIsIkVudW0iLCJyZXF1aXJlIiwidHlwZXMiLCJ1dGlsIiwiZ2VuVHlwZVBhcnRpYWwiLCJnZW4iLCJmaWVsZCIsImZpZWxkSW5kZXgiLCJyZWYiLCJkZWxpbWl0ZWQiLCJpZCIsIm10eXBlIiwiY29kZWdlbiIsIm5hbWUiLCJpIiwiZmllbGRzIiwiZmllbGRzQXJyYXkiLCJzbGljZSIsInNvcnQiLCJjb21wYXJlRmllbGRzQnlJZCIsImxlbmd0aCIsInJlc29sdmUiLCJpbmRleCIsIl9maWVsZHNBcnJheSIsImluZGV4T2YiLCJ0eXBlIiwicmVzb2x2ZWRUeXBlIiwid2lyZVR5cGUiLCJiYXNpYyIsInNhZmVQcm9wIiwibWFwIiwibWFwS2V5Iiwia2V5VHlwZSIsInVuZGVmaW5lZCIsInJlcGVhdGVkIiwicGFja2VkIiwib3B0aW9uYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/enum.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/enum.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Enum;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */ function Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n    if (values && typeof values !== \"object\") throw TypeError(\"values must be an object\");\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */ this.valuesById = {};\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */ this.values = Object.create(this.valuesById); // toJSON, marker\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */ this.comments = comments || {};\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this.valuesOptions = valuesOptions;\n    /**\n     * Resolved values features, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this._valuesFeatures = {};\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n    if (values) {\n        for(var keys = Object.keys(values), i = 0; i < keys.length; ++i)if (typeof values[keys[i]] === \"number\") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];\n    }\n}\n/**\n * @override\n */ Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    edition = this._edition || edition;\n    ReflectionObject.prototype._resolveFeatures.call(this, edition);\n    Object.keys(this.values).forEach((key)=>{\n        var parentFeaturesCopy = Object.assign({}, this._features);\n        this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);\n    });\n    return this;\n};\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */ /**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */ Enum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    if (json.edition) enm._edition = json.edition;\n    enm._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return enm;\n};\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */ Enum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        this.options,\n        \"valuesOptions\",\n        this.valuesOptions,\n        \"values\",\n        this.values,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"comments\",\n        keepComments ? this.comments : undefined\n    ]);\n};\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */ Enum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (!util.isInteger(id)) throw TypeError(\"id must be an integer\");\n    if (this.values[name] !== undefined) throw Error(\"duplicate name '\" + name + \"' in \" + this);\n    if (this.isReservedId(id)) throw Error(\"id \" + id + \" is reserved in \" + this);\n    if (this.isReservedName(name)) throw Error(\"name '\" + name + \"' is reserved in \" + this);\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias)) throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else this.valuesById[this.values[name] = id] = name;\n    if (options) {\n        if (this.valuesOptions === undefined) this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n    this.comments[name] = comment || null;\n    return this;\n};\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */ Enum.prototype.remove = function remove(name) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    var val = this.values[name];\n    if (val == null) throw Error(\"name '\" + name + \"' does not exist in \" + this);\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions) delete this.valuesOptions[name];\n    return this;\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQyxnRUFBVTtBQUN4QyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sSUFBRyxFQUFHTyxTQUFTLEdBQUc7QUFFOUYsSUFBSUMsWUFBWU4sbUJBQU9BLENBQUMsc0VBQWEsR0FDakNPLE9BQU9QLG1CQUFPQSxDQUFDLDREQUFRO0FBRTNCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0YsS0FBS1UsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7SUFDakVkLGlCQUFpQmUsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTUU7SUFFbEMsSUFBSUQsVUFBVSxPQUFPQSxXQUFXLFVBQzVCLE1BQU1NLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQztJQUVuQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNQLE1BQU0sR0FBR1AsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ2EsVUFBVSxHQUFHLGlCQUFpQjtJQUUvRDs7O0tBR0MsR0FDRCxJQUFJLENBQUNMLE9BQU8sR0FBR0E7SUFFZjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBR0EsWUFBWSxDQUFDO0lBRTdCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLGVBQWUsR0FBRyxDQUFDO0lBRXhCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHQyxXQUFXLFNBQVM7SUFFcEMsd0ZBQXdGO0lBQ3hGLHVGQUF1RjtJQUN2RixtRkFBbUY7SUFF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O0lBRS9ELE9BQU8sSUFBSSxDQUFDUSxVQUFVLENBQUNtQyxJQUFJO0lBQzNCLE9BQU8sSUFBSSxDQUFDMUMsTUFBTSxDQUFDRCxLQUFLO0lBQ3hCLE9BQU8sSUFBSSxDQUFDSSxRQUFRLENBQUNKLEtBQUs7SUFDMUIsSUFBSSxJQUFJLENBQUNLLGFBQWEsRUFDbEIsT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0wsS0FBSztJQUVuQyxPQUFPLElBQUk7QUFDZjtBQUVBOzs7O0NBSUMsR0FDRFYsS0FBS0csU0FBUyxDQUFDOEMsWUFBWSxHQUFHLFNBQVNBLGFBQWFKLEVBQUU7SUFDbEQsT0FBT3JDLFVBQVV5QyxZQUFZLENBQUMsSUFBSSxDQUFDN0IsUUFBUSxFQUFFeUI7QUFDakQ7QUFFQTs7OztDQUlDLEdBQ0Q3QyxLQUFLRyxTQUFTLENBQUMrQyxjQUFjLEdBQUcsU0FBU0EsZUFBZXhDLElBQUk7SUFDeEQsT0FBT0YsVUFBVTBDLGNBQWMsQ0FBQyxJQUFJLENBQUM5QixRQUFRLEVBQUVWO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanM/NTcxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRW51bTtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRW51bS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBFbnVtKS5jbGFzc05hbWUgPSBcIkVudW1cIjtcblxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGVudW0gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBlbnVtLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBbdmFsdWVzXSBFbnVtIHZhbHVlcyBhcyBhbiBvYmplY3QsIGJ5IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIFRoZSBjb21tZW50IGZvciB0aGlzIGVudW1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gW2NvbW1lbnRzXSBUaGUgdmFsdWUgY29tbWVudHMgZm9yIHRoaXMgZW51bVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxPYmplY3Q8c3RyaW5nLCo+Pnx1bmRlZmluZWR9IFt2YWx1ZXNPcHRpb25zXSBUaGUgdmFsdWUgb3B0aW9ucyBmb3IgdGhpcyBlbnVtXG4gKi9cbmZ1bmN0aW9uIEVudW0obmFtZSwgdmFsdWVzLCBvcHRpb25zLCBjb21tZW50LCBjb21tZW50cywgdmFsdWVzT3B0aW9ucykge1xuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZXMgJiYgdHlwZW9mIHZhbHVlcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidmFsdWVzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgYnkgaWQuXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNCeUlkID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc0J5SWQpOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRW51bSBjb21tZW50IHRleHQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBjb21tZW50IHRleHRzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmFsdWVzIG9wdGlvbnMsIGlmIGFueVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCAqPj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzT3B0aW9ucyA9IHZhbHVlc09wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCB2YWx1ZXMgZmVhdHVyZXMsIGlmIGFueVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCAqPj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX3ZhbHVlc0ZlYXR1cmVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvLyBOb3RlIHRoYXQgdmFsdWVzIGluaGVyaXQgdmFsdWVzQnlJZCBvbiB0aGVpciBwcm90b3R5cGUgd2hpY2ggbWFrZXMgdGhlbSBhIFR5cGVTY3JpcHQtXG4gICAgLy8gY29tcGF0aWJsZSBlbnVtLiBUaGlzIGlzIHVzZWQgYnkgcGJ0cyB0byB3cml0ZSBhY3R1YWwgZW51bSBkZWZpbml0aW9ucyB0aGF0IHdvcmsgZm9yXG4gICAgLy8gc3RhdGljIGFuZCByZWZsZWN0aW9uIGNvZGUgYWxpa2UgaW5zdGVhZCBvZiBlbWl0dGluZyBnZW5lcmljIG9iamVjdCBkZWZpbml0aW9ucy5cblxuICAgIGlmICh2YWx1ZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1trZXlzW2ldXSA9PT0gXCJudW1iZXJcIikgLy8gdXNlIGZvcndhcmQgZW50cmllcyBvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNCeUlkWyB0aGlzLnZhbHVlc1trZXlzW2ldXSA9IHZhbHVlc1trZXlzW2ldXSBdID0ga2V5c1tpXTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuRW51bS5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRmVhdHVyZXMoZWRpdGlvbikge1xuICAgIGVkaXRpb24gPSB0aGlzLl9lZGl0aW9uIHx8IGVkaXRpb247XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlcy5jYWxsKHRoaXMsIGVkaXRpb24pO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdmFyIHBhcmVudEZlYXR1cmVzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZlYXR1cmVzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRmVhdHVyZXNba2V5XSA9IE9iamVjdC5hc3NpZ24ocGFyZW50RmVhdHVyZXNDb3B5LCB0aGlzLnZhbHVlc09wdGlvbnMgJiYgdGhpcy52YWx1ZXNPcHRpb25zW2tleV0gJiYgdGhpcy52YWx1ZXNPcHRpb25zW2tleV0uZmVhdHVyZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVudW0gZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUVudW1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gdmFsdWVzIEVudW0gdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRW51bSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW0gZnJvbSBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFbnVtIG5hbWVcbiAqIEBwYXJhbSB7SUVudW19IGpzb24gRW51bSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RW51bX0gQ3JlYXRlZCBlbnVtXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5FbnVtLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBlbm0gPSBuZXcgRW51bShuYW1lLCBqc29uLnZhbHVlcywganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQsIGpzb24uY29tbWVudHMpO1xuICAgIGVubS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgaWYgKGpzb24uZWRpdGlvbilcbiAgICAgICAgZW5tLl9lZGl0aW9uID0ganNvbi5lZGl0aW9uO1xuICAgIGVubS5fZGVmYXVsdEVkaXRpb24gPSBcInByb3RvM1wiOyAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIHJldHVybiBlbm07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZW51bSB0byBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRW51bX0gRW51bSBkZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJlZGl0aW9uXCIgICAgICAgLCB0aGlzLl9lZGl0aW9uVG9KU09OKCksXG4gICAgICAgIFwib3B0aW9uc1wiICAgICAgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcInZhbHVlc09wdGlvbnNcIiAsIHRoaXMudmFsdWVzT3B0aW9ucyxcbiAgICAgICAgXCJ2YWx1ZXNcIiAgICAgICAgLCB0aGlzLnZhbHVlcyxcbiAgICAgICAgXCJyZXNlcnZlZFwiICAgICAgLCB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudHNcIiAgICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50cyA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhpcyBlbnVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFZhbHVlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQsIGlmIGFueVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj58dW5kZWZpbmVkfSBbb3B0aW9uc10gT3B0aW9ucywgaWYgYW55XG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSB2YWx1ZSB3aXRoIHRoaXMgbmFtZSBvciBpZFxuICovXG5FbnVtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgaWQsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyB1dGlsaXplZCBieSB0aGUgcGFyc2VyIGJ1dCBub3QgYnkgLmZyb21KU09OXG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmICghdXRpbC5pc0ludGVnZXIoaWQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpZCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG5cbiAgICBpZiAodGhpcy52YWx1ZXNbbmFtZV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBuYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkSWQoaWQpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImlkIFwiICsgaWQgKyBcIiBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUobmFtZSkpXG4gICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy52YWx1ZXNCeUlkW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuYWxsb3dfYWxpYXMpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzW25hbWVdID0gaWQ7XG4gICAgfSBlbHNlXG4gICAgICAgIHRoaXMudmFsdWVzQnlJZFt0aGlzLnZhbHVlc1tuYW1lXSA9IGlkXSA9IG5hbWU7XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXNPcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy52YWx1ZXNPcHRpb25zW25hbWVdID0gb3B0aW9ucyB8fCBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29tbWVudHNbbmFtZV0gPSBjb21tZW50IHx8IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoaXMgZW51bVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgbmFtZWAgaXMgbm90IGEgbmFtZSBvZiB0aGlzIGVudW1cbiAqL1xuRW51bS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgdmFyIHZhbCA9IHRoaXMudmFsdWVzW25hbWVdO1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gXCIgKyB0aGlzKTtcblxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc0J5SWRbdmFsXTtcbiAgICBkZWxldGUgdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgZGVsZXRlIHRoaXMuY29tbWVudHNbbmFtZV07XG4gICAgaWYgKHRoaXMudmFsdWVzT3B0aW9ucylcbiAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVzT3B0aW9uc1tuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiRW51bSIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJOYW1lc3BhY2UiLCJ1dGlsIiwibmFtZSIsInZhbHVlcyIsIm9wdGlvbnMiLCJjb21tZW50IiwiY29tbWVudHMiLCJ2YWx1ZXNPcHRpb25zIiwiY2FsbCIsIlR5cGVFcnJvciIsInZhbHVlc0J5SWQiLCJfdmFsdWVzRmVhdHVyZXMiLCJyZXNlcnZlZCIsInVuZGVmaW5lZCIsImtleXMiLCJpIiwibGVuZ3RoIiwiX3Jlc29sdmVGZWF0dXJlcyIsImVkaXRpb24iLCJfZWRpdGlvbiIsImZvckVhY2giLCJrZXkiLCJwYXJlbnRGZWF0dXJlc0NvcHkiLCJhc3NpZ24iLCJfZmVhdHVyZXMiLCJmZWF0dXJlcyIsImZyb21KU09OIiwianNvbiIsImVubSIsIl9kZWZhdWx0RWRpdGlvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJfZWRpdGlvblRvSlNPTiIsImFkZCIsImlkIiwiaXNTdHJpbmciLCJpc0ludGVnZXIiLCJFcnJvciIsImlzUmVzZXJ2ZWRJZCIsImlzUmVzZXJ2ZWROYW1lIiwiYWxsb3dfYWxpYXMiLCJyZW1vdmUiLCJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/enum.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/field.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/field.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Field;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Type; // cyclic\nvar ruleRe = /^required|optional|repeated$/;\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */ Field.fromJSON = function fromJSON(name, json) {\n    var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n    if (json.edition) field._edition = json.edition;\n    field._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return field;\n};\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function Field(name, id, type, rule, extend, options, comment) {\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    if (!util.isInteger(id) || id < 0) throw TypeError(\"id must be a non-negative integer\");\n    if (!util.isString(type)) throw TypeError(\"type must be a string\");\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");\n    if (extend !== undefined && !util.isString(extend)) throw TypeError(\"extend must be a string\");\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */ if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n    /**\n     * Field type.\n     * @type {string}\n     */ this.type = type; // toJSON\n    /**\n     * Unique field id.\n     * @type {number}\n     */ this.id = id; // toJSON, marker\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */ this.extend = extend || undefined; // toJSON\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */ this.repeated = rule === \"repeated\";\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */ this.map = false;\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */ this.message = null;\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */ this.partOf = null;\n    /**\n     * The field type's default value.\n     * @type {*}\n     */ this.typeDefault = null;\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */ this.defaultValue = null;\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */ this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */ this.bytes = type === \"bytes\";\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */ this.resolvedType = null;\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */ this.extensionField = null;\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */ this.declaringField = null;\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Determines whether this field is required.\n * @name Field#required\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"required\", {\n    get: function() {\n        return this._features.field_presence === \"LEGACY_REQUIRED\";\n    }\n});\n/**\n * Determines whether this field is not required.\n * @name Field#optional\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"optional\", {\n    get: function() {\n        return !this.required;\n    }\n});\n/**\n * Determines whether this field uses tag-delimited encoding.  In proto2 this\n * corresponded to group syntax.\n * @name Field#delimited\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"delimited\", {\n    get: function() {\n        return this.resolvedType instanceof Type && this._features.message_encoding === \"DELIMITED\";\n    }\n});\n/**\n * Determines whether this field is packed. Only relevant when repeated.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        return this._features.repeated_field_encoding === \"PACKED\";\n    }\n});\n/**\n * Determines whether this field tracks presence.\n * @name Field#hasPresence\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"hasPresence\", {\n    get: function() {\n        if (this.repeated || this.map) {\n            return false;\n        }\n        return this.partOf || // oneofs\n        this.declaringField || this.extensionField || // extensions\n        this._features.field_presence !== \"IMPLICIT\";\n    }\n});\n/**\n * @override\n */ Field.prototype.setOption = function setOption(name, value, ifNotSet) {\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */ /**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */ /**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */ Field.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"rule\",\n        this.rule !== \"optional\" && this.rule || undefined,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */ Field.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) {\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type) this.typeDefault = null;\n        else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\") this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;\n        if (!Object.keys(this.options).length) this.options = undefined;\n    }\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n        /* istanbul ignore else */ if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n    // take special care of maps and repeated fields\n    if (this.map) this.defaultValue = util.emptyObject;\n    else if (this.repeated) this.defaultValue = util.emptyArray;\n    else this.defaultValue = this.typeDefault;\n    // ensure proper value on prototype\n    if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;\n    return ReflectionObject.prototype.resolve.call(this);\n};\n/**\n * Infers field features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */ Field.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {\n    if (edition !== \"proto2\" && edition !== \"proto3\") {\n        return {};\n    }\n    var features = {};\n    if (this.rule === \"required\") {\n        features.field_presence = \"LEGACY_REQUIRED\";\n    }\n    if (this.parent && types.defaults[this.type] === undefined) {\n        // We can't use resolvedType because types may not have been resolved yet.  However,\n        // legacy groups are always in the same scope as the field so we don't have to do a\n        // full scan of the tree.\n        var type = this.parent.get(this.type.split(\".\").pop());\n        if (type && type instanceof Type && type.group) {\n            features.message_encoding = \"DELIMITED\";\n        }\n    }\n    if (this.getOption(\"packed\") === true) {\n        features.repeated_field_encoding = \"PACKED\";\n    } else if (this.getOption(\"packed\") === false) {\n        features.repeated_field_encoding = \"EXPANDED\";\n    }\n    return features;\n};\n/**\n * @override\n */ Field.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);\n};\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */ /**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */ Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\") fieldType = util.decorateType(fieldType).name;\n    else if (fieldType && typeof fieldType === \"object\") fieldType = util.decorateEnum(fieldType).name;\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {\n            \"default\": defaultValue\n        }));\n    };\n};\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */ // like Field.d but without a default value\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2ZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsZ0VBQVU7QUFDeEMsRUFBQ0YsTUFBTUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLEtBQUksRUFBR08sU0FBUyxHQUFHO0FBRWhHLElBQUlDLE9BQVFOLG1CQUFPQSxDQUFDLDREQUFRLEdBQ3hCTyxRQUFRUCxtQkFBT0EsQ0FBQyw4REFBUyxHQUN6QlEsT0FBUVIsbUJBQU9BLENBQUMsNERBQVE7QUFFNUIsSUFBSVMsTUFBTSxTQUFTO0FBRW5CLElBQUlDLFNBQVM7QUFFYjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRDs7Ozs7O0NBTUMsR0FDRFosTUFBTWEsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsSUFBSTtJQUN6QyxJQUFJQyxRQUFRLElBQUloQixNQUFNYyxNQUFNQyxLQUFLRSxFQUFFLEVBQUVGLEtBQUtHLElBQUksRUFBRUgsS0FBS0ksSUFBSSxFQUFFSixLQUFLSyxNQUFNLEVBQUVMLEtBQUtNLE9BQU8sRUFBRU4sS0FBS08sT0FBTztJQUNsRyxJQUFJUCxLQUFLUSxPQUFPLEVBQ1pQLE1BQU1RLFFBQVEsR0FBR1QsS0FBS1EsT0FBTztJQUNqQ1AsTUFBTVMsZUFBZSxHQUFHLFVBQVcsK0JBQStCO0lBQ2xFLE9BQU9UO0FBQ1g7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU2hCLE1BQU1jLElBQUksRUFBRUcsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFFekQsSUFBSVosS0FBS2dCLFFBQVEsQ0FBQ1AsT0FBTztRQUNyQkcsVUFBVUY7UUFDVkMsVUFBVUY7UUFDVkEsT0FB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QVUsR0FBRyxTQUFTQyxVQUFVQyxLQUFLO0lBQ3ZDN0YsT0FBTzZGO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanM/ZTU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRmllbGQ7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEZpZWxkKS5jbGFzc05hbWUgPSBcIkZpZWxkXCI7XG5cbnZhciBFbnVtICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlOyAvLyBjeWNsaWNcblxudmFyIHJ1bGVSZSA9IC9ecmVxdWlyZWR8b3B0aW9uYWx8cmVwZWF0ZWQkLztcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgZmllbGQgaW5zdGFuY2UuIE5vdGUgdGhhdCB7QGxpbmsgTWFwRmllbGR8bWFwIGZpZWxkc30gaGF2ZSB0aGVpciBvd24gY2xhc3MuXG4gKiBAbmFtZSBGaWVsZFxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSBmaWVsZC5cbiAqIEBleHRlbmRzIEZpZWxkQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZpZWxkIGZyb20gYSBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJRmllbGR9IGpzb24gRmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge0ZpZWxkfSBDcmVhdGVkIGZpZWxkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5GaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQobmFtZSwganNvbi5pZCwganNvbi50eXBlLCBqc29uLnJ1bGUsIGpzb24uZXh0ZW5kLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG4gICAgaWYgKGpzb24uZWRpdGlvbilcbiAgICAgICAgZmllbGQuX2VkaXRpb24gPSBqc29uLmVkaXRpb247XG4gICAgZmllbGQuX2RlZmF1bHRFZGl0aW9uID0gXCJwcm90bzNcIjsgIC8vIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAgICByZXR1cm4gZmllbGQ7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgRmllbGR9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkcy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgRmllbGRCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gRmllbGQobmFtZSwgaWQsIHR5cGUsIHJ1bGUsIGV4dGVuZCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgY29tbWVudCA9IGV4dGVuZDtcbiAgICAgICAgb3B0aW9ucyA9IHJ1bGU7XG4gICAgICAgIHJ1bGUgPSBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGV4dGVuZCkpIHtcbiAgICAgICAgY29tbWVudCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQ7XG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSB8fCBpZCA8IDApXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyh0eXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCAmJiAhcnVsZVJlLnRlc3QocnVsZSA9IHJ1bGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XG5cbiAgICBpZiAoZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNTdHJpbmcoZXh0ZW5kKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBydWxlLCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgaWYgKHJ1bGUgPT09IFwicHJvdG8zX29wdGlvbmFsXCIpIHtcbiAgICAgICAgcnVsZSA9IFwib3B0aW9uYWxcIjtcbiAgICB9XG4gICAgdGhpcy5ydWxlID0gcnVsZSAmJiBydWxlICE9PSBcIm9wdGlvbmFsXCIgPyBydWxlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBmaWVsZCBpZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5kID0gZXh0ZW5kIHx8IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVwZWF0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBhIG1hcCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE9uZU9mIHRoaXMgZmllbGQgYmVsb25ncyB0bywgaWYgYW55LFxuICAgICAqIEB0eXBlIHtPbmVPZnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFydE9mID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgb24gcHJvdG90eXBlcy5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxvbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb25nID0gdXRpbC5Mb25nID8gdHlwZXMubG9uZ1t0eXBlXSAhPT0gdW5kZWZpbmVkIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBpcyBhIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gdHlwZSA9PT0gXCJieXRlc1wiO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfEVudW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBleHRlbmRlZCB0eXBlIGlmIGEgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGRlY2xhcmluZyBuYW1lc3BhY2UgaWYgYW4gZXh0ZW5kZWQgZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZWNsYXJpbmdGaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIGlzIHJlcXVpcmVkLlxuICogQG5hbWUgRmllbGQjcmVxdWlyZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaWVsZC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlcy5maWVsZF9wcmVzZW5jZSA9PT0gXCJMRUdBQ1lfUkVRVUlSRURcIjtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBub3QgcmVxdWlyZWQuXG4gKiBAbmFtZSBGaWVsZCNvcHRpb25hbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJvcHRpb25hbFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVkO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIHVzZXMgdGFnLWRlbGltaXRlZCBlbmNvZGluZy4gIEluIHByb3RvMiB0aGlzXG4gKiBjb3JyZXNwb25kZWQgdG8gZ3JvdXAgc3ludGF4LlxuICogQG5hbWUgRmllbGQjZGVsaW1pdGVkXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcImRlbGltaXRlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSAmJlxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMubWVzc2FnZV9lbmNvZGluZyA9PT0gXCJERUxJTUlURURcIjtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBwYWNrZWQuIE9ubHkgcmVsZXZhbnQgd2hlbiByZXBlYXRlZC5cbiAqIEBuYW1lIEZpZWxkI3BhY2tlZFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJwYWNrZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlcy5yZXBlYXRlZF9maWVsZF9lbmNvZGluZyA9PT0gXCJQQUNLRURcIjtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCB0cmFja3MgcHJlc2VuY2UuXG4gKiBAbmFtZSBGaWVsZCNoYXNQcmVzZW5jZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJoYXNQcmVzZW5jZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQgfHwgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0T2YgfHwgLy8gb25lb2ZzXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmluZ0ZpZWxkIHx8IHRoaXMuZXh0ZW5zaW9uRmllbGQgfHwgLy8gZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMuZmllbGRfcHJlc2VuY2UgIT09IFwiSU1QTElDSVRcIjtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuRmllbGQucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIGlmTm90U2V0KTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBGaWVsZCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgRmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBGaWVsZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbkZpZWxkXG4gKiBAZXh0ZW5kcyBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBmaWVsZCB0byBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRmllbGR9IEZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJlZGl0aW9uXCIgLCB0aGlzLl9lZGl0aW9uVG9KU09OKCksXG4gICAgICAgIFwicnVsZVwiICAgICwgdGhpcy5ydWxlICE9PSBcIm9wdGlvbmFsXCIgJiYgdGhpcy5ydWxlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJ0eXBlXCIgICAgLCB0aGlzLnR5cGUsXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgZmllbGQncyB0eXBlIHJlZmVyZW5jZXMuXG4gKiBAcmV0dXJucyB7RmllbGR9IGB0aGlzYFxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSByZWZlcmVuY2UgY2Fubm90IGJlIHJlc29sdmVkXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICgodGhpcy50eXBlRGVmYXVsdCA9IHR5cGVzLmRlZmF1bHRzW3RoaXMudHlwZV0pID09PSB1bmRlZmluZWQpIHsgLy8gaWYgbm90IGEgYmFzaWMgdHlwZSwgcmVzb2x2ZSBpdFxuICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9ICh0aGlzLmRlY2xhcmluZ0ZpZWxkID8gdGhpcy5kZWNsYXJpbmdGaWVsZC5wYXJlbnQgOiB0aGlzLnBhcmVudCkubG9va3VwVHlwZU9yRW51bSh0aGlzLnR5cGUpO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IG51bGw7XG4gICAgICAgIGVsc2UgLy8gaW5zdGFuY2VvZiBFbnVtXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW09iamVjdC5rZXlzKHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlcylbMF1dOyAvLyBmaXJzdCBkZWZpbmVkXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnByb3RvM19vcHRpb25hbCkge1xuICAgICAgICAvLyBwcm90bzMgc2NhbGFyIHZhbHVlIG1hcmtlZCBvcHRpb25hbDsgc2hvdWxkIGRlZmF1bHQgdG8gbnVsbFxuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1c2UgZXhwbGljaXRseSBzZXQgZGVmYXVsdCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl07XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW3RoaXMudHlwZURlZmF1bHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBvcHRpb25zXG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhY2tlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVzb2x2ZWRUeXBlICYmICEodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMucGFja2VkO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gaW50ZXJuYWwgZGF0YSB0eXBlIGlmIG5lY2Vzc3NhcnlcbiAgICBpZiAodGhpcy5sb25nKSB7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB1dGlsLkxvbmcuZnJvbU51bWJlcih0aGlzLnR5cGVEZWZhdWx0LCB0aGlzLnR5cGUuY2hhckF0KDApID09PSBcInVcIik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpXG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMudHlwZURlZmF1bHQpOyAvLyBsb25nIGluc3RhbmNlcyBhcmUgbWVhbnQgdG8gYmUgaW1tdXRhYmxlIGFueXdheSAoaS5lLiB1c2Ugc21hbGwgaW50IGNhY2hlIHRoYXQgZXZlbiByZXF1aXJlcyBpdClcblxuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlcyAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgYnVmO1xuICAgICAgICBpZiAodXRpbC5iYXNlNjQudGVzdCh0aGlzLnR5cGVEZWZhdWx0KSlcbiAgICAgICAgICAgIHV0aWwuYmFzZTY0LmRlY29kZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXRpbC51dGY4LndyaXRlKHRoaXMudHlwZURlZmF1bHQsIGJ1ZiA9IHV0aWwubmV3QnVmZmVyKHV0aWwudXRmOC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKTtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IGJ1ZjtcbiAgICB9XG5cbiAgICAvLyB0YWtlIHNwZWNpYWwgY2FyZSBvZiBtYXBzIGFuZCByZXBlYXRlZCBmaWVsZHNcbiAgICBpZiAodGhpcy5tYXApXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eU9iamVjdDtcbiAgICBlbHNlIGlmICh0aGlzLnJlcGVhdGVkKVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlBcnJheTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy50eXBlRGVmYXVsdDtcblxuICAgIC8vIGVuc3VyZSBwcm9wZXIgdmFsdWUgb24gcHJvdG90eXBlXG4gICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgdGhpcy5wYXJlbnQuY3Rvci5wcm90b3R5cGVbdGhpcy5uYW1lXSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogSW5mZXJzIGZpZWxkIGZlYXR1cmVzIGZyb20gbGVnYWN5IHN5bnRheCB0aGF0IG1heSBoYXZlIGJlZW4gc3BlY2lmaWVkIGRpZmZlcmVudGx5LlxuICogaW4gb2xkZXIgZWRpdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGVkaXRpb24gVGhlIGVkaXRpb24gdGhpcyBwcm90byBpcyBvbiwgb3IgdW5kZWZpbmVkIGlmIHByZS1lZGl0aW9uc1xuICogQHJldHVybnMge29iamVjdH0gVGhlIGZlYXR1cmUgdmFsdWVzIHRvIG92ZXJyaWRlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5faW5mZXJMZWdhY3lQcm90b0ZlYXR1cmVzID0gZnVuY3Rpb24gX2luZmVyTGVnYWN5UHJvdG9GZWF0dXJlcyhlZGl0aW9uKSB7XG4gICAgaWYgKGVkaXRpb24gIT09IFwicHJvdG8yXCIgJiYgZWRpdGlvbiAhPT0gXCJwcm90bzNcIikge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGZlYXR1cmVzID0ge307XG5cbiAgICBpZiAodGhpcy5ydWxlID09PSBcInJlcXVpcmVkXCIpIHtcbiAgICAgICAgZmVhdHVyZXMuZmllbGRfcHJlc2VuY2UgPSBcIkxFR0FDWV9SRVFVSVJFRFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdHlwZXMuZGVmYXVsdHNbdGhpcy50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHVzZSByZXNvbHZlZFR5cGUgYmVjYXVzZSB0eXBlcyBtYXkgbm90IGhhdmUgYmVlbiByZXNvbHZlZCB5ZXQuICBIb3dldmVyLFxuICAgICAgICAvLyBsZWdhY3kgZ3JvdXBzIGFyZSBhbHdheXMgaW4gdGhlIHNhbWUgc2NvcGUgYXMgdGhlIGZpZWxkIHNvIHdlIGRvbid0IGhhdmUgdG8gZG8gYVxuICAgICAgICAvLyBmdWxsIHNjYW4gb2YgdGhlIHRyZWUuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5wYXJlbnQuZ2V0KHRoaXMudHlwZS5zcGxpdChcIi5cIikucG9wKCkpO1xuICAgICAgICBpZiAodHlwZSAmJiB0eXBlIGluc3RhbmNlb2YgVHlwZSAmJiB0eXBlLmdyb3VwKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5tZXNzYWdlX2VuY29kaW5nID0gXCJERUxJTUlURURcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5nZXRPcHRpb24oXCJwYWNrZWRcIikgPT09IHRydWUpIHtcbiAgICAgICAgZmVhdHVyZXMucmVwZWF0ZWRfZmllbGRfZW5jb2RpbmcgPSBcIlBBQ0tFRFwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRPcHRpb24oXCJwYWNrZWRcIikgPT09IGZhbHNlKSB7XG4gICAgICAgIGZlYXR1cmVzLnJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nID0gXCJFWFBBTkRFRFwiO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5GaWVsZC5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRmVhdHVyZXMoZWRpdGlvbikge1xuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzLmNhbGwodGhpcywgdGhpcy5fZWRpdGlvbiB8fCBlZGl0aW9uKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBGaWVsZC5kfSBhbmQge0BsaW5rIE1hcEZpZWxkLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIEZpZWxkRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge1wiZG91YmxlXCJ8XCJmbG9hdFwifFwiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwic3RyaW5nXCJ8XCJib29sXCJ8XCJieXRlc1wifE9iamVjdH0gZmllbGRUeXBlIEZpZWxkIHR5cGVcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge1R9IFtkZWZhdWx0VmFsdWVdIERlZmF1bHQgdmFsdWVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIG51bWJlciB8IG51bWJlcltdIHwgTG9uZyB8IExvbmdbXSB8IHN0cmluZyB8IHN0cmluZ1tdIHwgYm9vbGVhbiB8IGJvb2xlYW5bXSB8IFVpbnQ4QXJyYXkgfCBVaW50OEFycmF5W10gfCBCdWZmZXIgfCBCdWZmZXJbXVxuICovXG5GaWVsZC5kID0gZnVuY3Rpb24gZGVjb3JhdGVGaWVsZChmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICAvLyBzdWJtZXNzYWdlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZVR5cGUoZmllbGRUeXBlKS5uYW1lO1xuXG4gICAgLy8gZW51bSByZWZlcmVuY2U6IGNyZWF0ZSBhIHJlZmxlY3RlZCBjb3B5IG9mIHRoZSBlbnVtIGFuZCBrZWVwIHJldXNlaW5nIGl0XG4gICAgZWxzZSBpZiAoZmllbGRUeXBlICYmIHR5cGVvZiBmaWVsZFR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIGZpZWxkVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVHlwZSkubmFtZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBmaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBGaWVsZChmaWVsZE5hbWUsIGZpZWxkSWQsIGZpZWxkVHlwZSwgZmllbGRSdWxlLCB7IFwiZGVmYXVsdFwiOiBkZWZhdWx0VmFsdWUgfSkpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fHN0cmluZ30gZmllbGRUeXBlIEZpZWxkIHR5cGVcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gbGlrZSBGaWVsZC5kIGJ1dCB3aXRob3V0IGEgZGVmYXVsdCB2YWx1ZVxuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcbkZpZWxkLl9jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUoVHlwZV8pIHtcbiAgICBUeXBlID0gVHlwZV87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJGaWVsZCIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJFbnVtIiwidHlwZXMiLCJ1dGlsIiwiVHlwZSIsInJ1bGVSZSIsImZyb21KU09OIiwibmFtZSIsImpzb24iLCJmaWVsZCIsImlkIiwidHlwZSIsInJ1bGUiLCJleHRlbmQiLCJvcHRpb25zIiwiY29tbWVudCIsImVkaXRpb24iLCJfZWRpdGlvbiIsIl9kZWZhdWx0RWRpdGlvbiIsImlzT2JqZWN0IiwidW5kZWZpbmVkIiwiY2FsbCIsImlzSW50ZWdlciIsIlR5cGVFcnJvciIsImlzU3RyaW5nIiwidGVzdCIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXBlYXRlZCIsIm1hcCIsIm1lc3NhZ2UiLCJwYXJ0T2YiLCJ0eXBlRGVmYXVsdCIsImRlZmF1bHRWYWx1ZSIsImxvbmciLCJMb25nIiwiYnl0ZXMiLCJyZXNvbHZlZFR5cGUiLCJleHRlbnNpb25GaWVsZCIsImRlY2xhcmluZ0ZpZWxkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJfZmVhdHVyZXMiLCJmaWVsZF9wcmVzZW5jZSIsInJlcXVpcmVkIiwibWVzc2FnZV9lbmNvZGluZyIsInJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nIiwic2V0T3B0aW9uIiwidmFsdWUiLCJpZk5vdFNldCIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJfZWRpdGlvblRvSlNPTiIsInJlc29sdmUiLCJyZXNvbHZlZCIsImRlZmF1bHRzIiwicGFyZW50IiwibG9va3VwVHlwZU9yRW51bSIsInZhbHVlcyIsImtleXMiLCJwcm90bzNfb3B0aW9uYWwiLCJwYWNrZWQiLCJsZW5ndGgiLCJmcm9tTnVtYmVyIiwiY2hhckF0IiwiZnJlZXplIiwiYnVmIiwiYmFzZTY0IiwiZGVjb2RlIiwibmV3QnVmZmVyIiwidXRmOCIsIndyaXRlIiwiZW1wdHlPYmplY3QiLCJlbXB0eUFycmF5IiwiY3RvciIsIl9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMiLCJmZWF0dXJlcyIsInNwbGl0IiwicG9wIiwiZ3JvdXAiLCJnZXRPcHRpb24iLCJfcmVzb2x2ZUZlYXR1cmVzIiwiZCIsImRlY29yYXRlRmllbGQiLCJmaWVsZElkIiwiZmllbGRUeXBlIiwiZmllbGRSdWxlIiwiZGVjb3JhdGVUeXBlIiwiZGVjb3JhdGVFbnVtIiwiZmllbGREZWNvcmF0b3IiLCJmaWVsZE5hbWUiLCJhZGQiLCJfY29uZmlndXJlIiwiY29uZmlndXJlIiwiVHlwZV8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/field.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index-light.js":
/*!*****************************************************!*\
  !*** ../node_modules/protobufjs/src/index-light.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-minimal */ \"(ssr)/../node_modules/protobufjs/src/index-minimal.js\");\nprotobuf.build = \"light\";\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */ /**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */ function load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root) root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */ // function load(filename:string, [root:Root]):Promise<Root>\nprotobuf.load = load;\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */ function loadSync(filename, root) {\n    if (!root) root = new protobuf.Root();\n    return root.loadSync(filename);\n}\nprotobuf.loadSync = loadSync;\n// Serialization\nprotobuf.encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/../node_modules/protobufjs/src/encoder.js\");\nprotobuf.decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../node_modules/protobufjs/src/decoder.js\");\nprotobuf.verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/../node_modules/protobufjs/src/verifier.js\");\nprotobuf.converter = __webpack_require__(/*! ./converter */ \"(ssr)/../node_modules/protobufjs/src/converter.js\");\n// Reflection\nprotobuf.ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\nprotobuf.Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\nprotobuf.Root = __webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\");\nprotobuf.Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\");\nprotobuf.Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\");\nprotobuf.Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\");\nprotobuf.OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\");\nprotobuf.MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\");\nprotobuf.Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\");\nprotobuf.Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\");\n// Runtime\nprotobuf.Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\");\nprotobuf.wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/../node_modules/protobufjs/src/wrappers.js\");\n// Utility\nprotobuf.types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\");\nprotobuf.util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LWxpZ2h0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBV0Msb0hBQTJDO0FBRTFERCxTQUFTSSxLQUFLLEdBQUc7QUFFakI7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxLQUFLQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUNsQyxJQUFJLE9BQU9ELFNBQVMsWUFBWTtRQUM1QkMsV0FBV0Q7UUFDWEEsT0FBTyxJQUFJUCxTQUFTUyxJQUFJO0lBQzVCLE9BQU8sSUFBSSxDQUFDRixNQUNSQSxPQUFPLElBQUlQLFNBQVNTLElBQUk7SUFDNUIsT0FBT0YsS0FBS0YsSUFBSSxDQUFDQyxVQUFVRTtBQUMvQjtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELGtFQUFrRTtBQUVsRTs7Ozs7Ozs7O0NBU0MsR0FDRCw0REFBNEQ7QUFFNURSLFNBQVNLLElBQUksR0FBR0E7QUFFaEI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNLLFNBQVNKLFFBQVEsRUFBRUMsSUFBSTtJQUM1QixJQUFJLENBQUNBLE1BQ0RBLE9BQU8sSUFBSVAsU0FBU1MsSUFBSTtJQUM1QixPQUFPRixLQUFLRyxRQUFRLENBQUNKO0FBQ3pCO0FBRUFOLFNBQVNVLFFBQVEsR0FBR0E7QUFFcEIsZ0JBQWdCO0FBQ2hCVixTQUFTVyxPQUFPLEdBQVlSLG1CQUFPQSxDQUFDLGtFQUFXO0FBQy9DSCxTQUFTWSxPQUFPLEdBQVlULG1CQUFPQSxDQUFDLGtFQUFXO0FBQy9DSCxTQUFTYSxRQUFRLEdBQVdWLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTYyxTQUFTLEdBQVVYLG1CQUFPQSxDQUFDLHNFQUFhO0FBRWpELGFBQWE7QUFDYkgsU0FBU2UsZ0JBQWdCLEdBQUdaLG1CQUFPQSxDQUFDLGdFQUFVO0FBQzlDSCxTQUFTZ0IsU0FBUyxHQUFVYixtQkFBT0EsQ0FBQyxzRUFBYTtBQUNqREgsU0FBU1MsSUFBSSxHQUFlTixtQkFBT0EsQ0FBQyw0REFBUTtBQUM1Q0gsU0FBU2lCLElBQUksR0FBZWQsbUJBQU9BLENBQUMsNERBQVE7QUFDNUNILFNBQVNrQixJQUFJLEdBQWVmLG1CQUFPQSxDQUFDLDREQUFRO0FBQzVDSCxTQUFTbUIsS0FBSyxHQUFjaEIsbUJBQU9BLENBQUMsOERBQVM7QUFDN0NILFNBQVNvQixLQUFLLEdBQWNqQixtQkFBT0EsQ0FBQyw4REFBUztBQUM3Q0gsU0FBU3FCLFFBQVEsR0FBV2xCLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTc0IsT0FBTyxHQUFZbkIsbUJBQU9BLENBQUMsa0VBQVc7QUFDL0NILFNBQVN1QixNQUFNLEdBQWFwQixtQkFBT0EsQ0FBQyxnRUFBVTtBQUU5QyxVQUFVO0FBQ1ZILFNBQVN3QixPQUFPLEdBQVlyQixtQkFBT0EsQ0FBQyxrRUFBVztBQUMvQ0gsU0FBU3lCLFFBQVEsR0FBV3RCLG1CQUFPQSxDQUFDLG9FQUFZO0FBRWhELFVBQVU7QUFDVkgsU0FBUzBCLEtBQUssR0FBY3ZCLG1CQUFPQSxDQUFDLDhEQUFTO0FBQzdDSCxTQUFTMkIsSUFBSSxHQUFleEIsbUJBQU9BLENBQUMsNERBQVE7QUFFNUMsaURBQWlEO0FBQ2pESCxTQUFTZSxnQkFBZ0IsQ0FBQ2EsVUFBVSxDQUFDNUIsU0FBU1MsSUFBSTtBQUNsRFQsU0FBU2dCLFNBQVMsQ0FBQ1ksVUFBVSxDQUFDNUIsU0FBU2tCLElBQUksRUFBRWxCLFNBQVNzQixPQUFPLEVBQUV0QixTQUFTaUIsSUFBSTtBQUM1RWpCLFNBQVNTLElBQUksQ0FBQ21CLFVBQVUsQ0FBQzVCLFNBQVNrQixJQUFJO0FBQ3RDbEIsU0FBU21CLEtBQUssQ0FBQ1MsVUFBVSxDQUFDNUIsU0FBU2tCLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanM/NjY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbWluaW1hbFwiKTtcblxucHJvdG9idWYuYnVpbGQgPSBcImxpZ2h0XCI7XG5cbi8qKlxuICogQSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIGxvYWR9IGFuZCB7QGxpbmsgUm9vdCNsb2FkfS5cbiAqIEB0eXBlZGVmIExvYWRDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290LCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIHJvb3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiByb290ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSByb290O1xuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICB9IGVsc2UgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkKGZpbGVuYW1lLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBuYW1lIGxvYWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW3Jvb3Q6Um9vdF0pOlByb21pc2U8Um9vdD5cblxucHJvdG9idWYubG9hZCA9IGxvYWQ7XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZFN5bmN9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSk7XG59XG5cbnByb3RvYnVmLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLmVuY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpO1xucHJvdG9idWYuZGVjb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIik7XG5wcm90b2J1Zi52ZXJpZmllciAgICAgICAgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIik7XG5wcm90b2J1Zi5jb252ZXJ0ZXIgICAgICAgID0gcmVxdWlyZShcIi4vY29udmVydGVyXCIpO1xuXG4vLyBSZWZsZWN0aW9uXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xucHJvdG9idWYuTmFtZXNwYWNlICAgICAgICA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbnByb3RvYnVmLlJvb3QgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpO1xucHJvdG9idWYuRW51bSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5wcm90b2J1Zi5UeXBlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnByb3RvYnVmLkZpZWxkICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbnByb3RvYnVmLk9uZU9mICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbnByb3RvYnVmLk1hcEZpZWxkICAgICAgICAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKTtcbnByb3RvYnVmLlNlcnZpY2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xucHJvdG9idWYuTWV0aG9kICAgICAgICAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKTtcblxuLy8gUnVudGltZVxucHJvdG9idWYuTWVzc2FnZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5wcm90b2J1Zi53cmFwcGVycyAgICAgICAgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnR5cGVzICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnByb3RvYnVmLnV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vLyBTZXQgdXAgcG9zc2libHkgY3ljbGljIHJlZmxlY3Rpb24gZGVwZW5kZW5jaWVzXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUocHJvdG9idWYuUm9vdCk7XG5wcm90b2J1Zi5OYW1lc3BhY2UuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5TZXJ2aWNlLCBwcm90b2J1Zi5FbnVtKTtcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbnByb3RvYnVmLkZpZWxkLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XG4iXSwibmFtZXMiOlsicHJvdG9idWYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImJ1aWxkIiwibG9hZCIsImZpbGVuYW1lIiwicm9vdCIsImNhbGxiYWNrIiwiUm9vdCIsImxvYWRTeW5jIiwiZW5jb2RlciIsImRlY29kZXIiLCJ2ZXJpZmllciIsImNvbnZlcnRlciIsIlJlZmxlY3Rpb25PYmplY3QiLCJOYW1lc3BhY2UiLCJFbnVtIiwiVHlwZSIsIkZpZWxkIiwiT25lT2YiLCJNYXBGaWVsZCIsIlNlcnZpY2UiLCJNZXRob2QiLCJNZXNzYWdlIiwid3JhcHBlcnMiLCJ0eXBlcyIsInV0aWwiLCJfY29uZmlndXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index-light.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index-minimal.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/index-minimal.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar protobuf = exports;\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */ protobuf.build = \"minimal\";\n// Serialization\nprotobuf.Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(ssr)/../node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(ssr)/../node_modules/protobufjs/src/reader_buffer.js\");\n// Utility\nprotobuf.util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/../node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots = __webpack_require__(/*! ./roots */ \"(ssr)/../node_modules/protobufjs/src/roots.js\");\nprotobuf.configure = configure;\n/* istanbul ignore next */ /**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */ function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n// Set up buffer utility according to the environment\nconfigure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQztBQUVmOzs7OztDQUtDLEdBQ0RELFNBQVNFLEtBQUssR0FBRztBQUVqQixnQkFBZ0I7QUFDaEJGLFNBQVNHLE1BQU0sR0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDMUNKLFNBQVNLLFlBQVksR0FBR0QsbUJBQU9BLENBQUMsOEVBQWlCO0FBQ2pESixTQUFTTSxNQUFNLEdBQVNGLG1CQUFPQSxDQUFDLGdFQUFVO0FBQzFDSixTQUFTTyxZQUFZLEdBQUdILG1CQUFPQSxDQUFDLDhFQUFpQjtBQUVqRCxVQUFVO0FBQ1ZKLFNBQVNRLElBQUksR0FBV0osbUJBQU9BLENBQUMsNEVBQWdCO0FBQ2hESixTQUFTUyxHQUFHLEdBQVlMLG1CQUFPQSxDQUFDLDBEQUFPO0FBQ3ZDSixTQUFTVSxLQUFLLEdBQVVOLG1CQUFPQSxDQUFDLDhEQUFTO0FBQ3pDSixTQUFTVyxTQUFTLEdBQU1BO0FBRXhCLHdCQUF3QixHQUN4Qjs7O0NBR0MsR0FDRCxTQUFTQTtJQUNMWCxTQUFTUSxJQUFJLENBQUNJLFVBQVU7SUFDeEJaLFNBQVNHLE1BQU0sQ0FBQ1MsVUFBVSxDQUFDWixTQUFTSyxZQUFZO0lBQ2hETCxTQUFTTSxNQUFNLENBQUNNLFVBQVUsQ0FBQ1osU0FBU08sWUFBWTtBQUNwRDtBQUVBLHFEQUFxRDtBQUNyREkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcz8zZGE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOlsicHJvdG9idWYiLCJleHBvcnRzIiwiYnVpbGQiLCJXcml0ZXIiLCJyZXF1aXJlIiwiQnVmZmVyV3JpdGVyIiwiUmVhZGVyIiwiQnVmZmVyUmVhZGVyIiwidXRpbCIsInJwYyIsInJvb3RzIiwiY29uZmlndXJlIiwiX2NvbmZpZ3VyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-light */ \"(ssr)/../node_modules/protobufjs/src/index-light.js\");\nprotobuf.build = \"full\";\n// Parser\nprotobuf.tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/../node_modules/protobufjs/src/tokenize.js\");\nprotobuf.parse = __webpack_require__(/*! ./parse */ \"(ssr)/../node_modules/protobufjs/src/parse.js\");\nprotobuf.common = __webpack_require__(/*! ./common */ \"(ssr)/../node_modules/protobufjs/src/common.js\");\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBV0MsZ0hBQXlDO0FBRXhERCxTQUFTSSxLQUFLLEdBQUc7QUFFakIsU0FBUztBQUNUSixTQUFTSyxRQUFRLEdBQVdGLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTTSxLQUFLLEdBQWNILG1CQUFPQSxDQUFDLDhEQUFTO0FBQzdDSCxTQUFTTyxNQUFNLEdBQWFKLG1CQUFPQSxDQUFDLGdFQUFVO0FBRTlDLG1CQUFtQjtBQUNuQkgsU0FBU1EsSUFBSSxDQUFDQyxVQUFVLENBQUNULFNBQVNVLElBQUksRUFBRVYsU0FBU00sS0FBSyxFQUFFTixTQUFTTyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LmpzPzE3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LWxpZ2h0XCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwiZnVsbFwiO1xuXG4vLyBQYXJzZXJcbnByb3RvYnVmLnRva2VuaXplICAgICAgICAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKTtcbnByb3RvYnVmLnBhcnNlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbnByb3RvYnVmLmNvbW1vbiAgICAgICAgICAgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5cbi8vIENvbmZpZ3VyZSBwYXJzZXJcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5wYXJzZSwgcHJvdG9idWYuY29tbW9uKTtcbiJdLCJuYW1lcyI6WyJwcm90b2J1ZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiYnVpbGQiLCJ0b2tlbml6ZSIsInBhcnNlIiwiY29tbW9uIiwiUm9vdCIsIl9jb25maWd1cmUiLCJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/mapfield.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/mapfield.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = MapField;\n// extends Field\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n    /* istanbul ignore if */ if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n    /**\n     * Key type.\n     * @type {string}\n     */ this.keyType = keyType; // toJSON, marker\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */ this.resolvedKeyType = null;\n    // Overrides Field#map\n    this.map = true;\n}\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */ /**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */ /**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */ MapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */ MapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\",\n        this.keyType,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ MapField.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n    return Field.prototype.resolve.call(this);\n};\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */ MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n    else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZ0JBQWdCO0FBQ2hCLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDLDhEQUFTO0FBQzVCLEVBQUNGLFNBQVNHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixNQUFNRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sUUFBTyxFQUFHTyxTQUFTLEdBQUc7QUFFM0YsSUFBSUMsUUFBVU4sbUJBQU9BLENBQUMsOERBQVMsR0FDM0JPLE9BQVVQLG1CQUFPQSxDQUFDLDREQUFRO0FBRTlCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0YsU0FBU1UsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDdkRkLE1BQU1lLElBQUksQ0FBQyxJQUFJLEVBQUVOLE1BQU1DLElBQUlFLE1BQU1JLFdBQVdBLFdBQVdILFNBQVNDO0lBRWhFLHNCQUFzQixHQUN0QixJQUFJLENBQUNOLEtBQUtTLFFBQVEsQ0FBQ04sVUFDZixNQUFNTyxVQUFVO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsT0FBTyxHQUFHQSxTQUFTLGlCQUFpQjtJQUV6Qzs7O0tBR0MsR0FDRCxJQUFJLENBQUNRLGVBQWUsR0FBRztJQUV2QixzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7QUFDZjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRHJCLFNBQVNzQixRQUFRLEdBQUcsU0FBU0EsU0FBU1osSUFBSSxFQUFFYSxJQUFJO0lBQzVDLE9BQU8sSUFBSXZCLFNBQVNVLE1BQU1hLEtBQUtaLEVBQUUsRUFBRVksS0FBS1gsT0FBTyxFQUFFVyxLQUFLVixJQUFJLEVBQUVVLEtBQUtULE9BQU8sRUFBRVMsS0FBS1IsT0FBTztBQUMxRjtBQUVBOzs7O0NBSUMsR0FDRGYsU0FBU0csU0FBUyxDQUFDcUIsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLGFBQWE7SUFDckQsSUFBSUMsZUFBZUQsZ0JBQWdCRSxRQUFRRixjQUFjQyxZQUFZLElBQUk7SUFDekUsT0FBT2pCLEtBQUttQixRQUFRLENBQUM7UUFDakI7UUFBWSxJQUFJLENBQUNoQixPQUFPO1FBQ3hCO1FBQVksSUFBSSxDQUFDQyxJQUFJO1FBQ3JCO1FBQVksSUFBSSxDQUFDRixFQUFFO1FBQ25CO1FBQVksSUFBSSxDQUFDa0IsTUFBTTtRQUN2QjtRQUFZLElBQUksQ0FBQ2YsT0FBTztRQUN4QjtRQUFZWSxlQUFlLElBQUksQ0FBQ1gsT0FBTyxHQUFHRTtLQUM3QztBQUNMO0FBRUE7O0NBRUMsR0FDRGpCLFNBQVNHLFNBQVMsQ0FBQzJCLE9BQU8sR0FBRyxTQUFTQTtJQUNsQyxJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUNiLE9BQU8sSUFBSTtJQUVmLDJIQUEySDtJQUMzSCxJQUFJdkIsTUFBTXdCLE1BQU0sQ0FBQyxJQUFJLENBQUNwQixPQUFPLENBQUMsS0FBS0ssV0FDL0IsTUFBTWdCLE1BQU0sdUJBQXVCLElBQUksQ0FBQ3JCLE9BQU87SUFFbkQsT0FBT1gsTUFBTUUsU0FBUyxDQUFDMkIsT0FBTyxDQUFDZCxJQUFJLENBQUMsSUFBSTtBQUM1QztBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEaEIsU0FBU2tDLENBQUMsR0FBRyxTQUFTQyxpQkFBaUJDLE9BQU8sRUFBRUMsWUFBWSxFQUFFQyxjQUFjO0lBRXhFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9BLG1CQUFtQixZQUMxQkEsaUJBQWlCN0IsS0FBSzhCLFlBQVksQ0FBQ0QsZ0JBQWdCNUIsSUFBSTtTQUd0RCxJQUFJNEIsa0JBQWtCLE9BQU9BLG1CQUFtQixVQUNqREEsaUJBQWlCN0IsS0FBSytCLFlBQVksQ0FBQ0YsZ0JBQWdCNUIsSUFBSTtJQUUzRCxPQUFPLFNBQVMrQixrQkFBa0J0QyxTQUFTLEVBQUV1QyxTQUFTO1FBQ2xEakMsS0FBSzhCLFlBQVksQ0FBQ3BDLFVBQVVHLFdBQVcsRUFDbENxQyxHQUFHLENBQUMsSUFBSTNDLFNBQVMwQyxXQUFXTixTQUFTQyxjQUFjQztJQUM1RDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzP2Y2MTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcEZpZWxkO1xuXG4vLyBleHRlbmRzIEZpZWxkXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbigoTWFwRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1hcEZpZWxkKS5jbGFzc05hbWUgPSBcIk1hcEZpZWxkXCI7XG5cbnZhciB0eXBlcyAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtYXAgZmllbGQgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtYXAgZmllbGQuXG4gKiBAZXh0ZW5kcyBGaWVsZEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIE1hcEZpZWxkKG5hbWUsIGlkLCBrZXlUeXBlLCB0eXBlLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgRmllbGQuY2FsbCh0aGlzLCBuYW1lLCBpZCwgdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMsIGNvbW1lbnQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKGtleVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJrZXlUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBLZXkgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5VHlwZSA9IGtleVR5cGU7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBrZXkgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZEtleVR5cGUgPSBudWxsO1xuXG4gICAgLy8gT3ZlcnJpZGVzIEZpZWxkI21hcFxuICAgIHRoaXMubWFwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU1hcEZpZWxkXG4gKiBAZXh0ZW5kcyB7SUZpZWxkfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleVR5cGUgS2V5IHR5cGVcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbk1hcEZpZWxkXG4gKiBAZXh0ZW5kcyBJTWFwRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1hcCBmaWVsZCBmcm9tIGEgbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lNYXBGaWVsZH0ganNvbiBNYXAgZmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge01hcEZpZWxkfSBDcmVhdGVkIG1hcCBmaWVsZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTWFwRmllbGQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLmtleVR5cGUsIGpzb24udHlwZSwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1hcCBmaWVsZCB0byBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1hcEZpZWxkfSBNYXAgZmllbGQgZGVzY3JpcHRvclxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImtleVR5cGVcIiAsIHRoaXMua2V5VHlwZSxcbiAgICAgICAgXCJ0eXBlXCIgICAgLCB0aGlzLnR5cGUsXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gQmVzaWRlcyBhIHZhbHVlIHR5cGUsIG1hcCBmaWVsZHMgaGF2ZSBhIGtleSB0eXBlIHRoYXQgbWF5IGJlIFwiYW55IHNjYWxhciB0eXBlIGV4Y2VwdCBmb3IgZmxvYXRpbmcgcG9pbnQgdHlwZXMgYW5kIGJ5dGVzXCJcbiAgICBpZiAodHlwZXMubWFwS2V5W3RoaXMua2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGtleSB0eXBlOiBcIiArIHRoaXMua2V5VHlwZSk7XG5cbiAgICByZXR1cm4gRmllbGQucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBNYXBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge1wiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwiYm9vbFwifFwic3RyaW5nXCJ9IGZpZWxkS2V5VHlwZSBGaWVsZCBrZXkgdHlwZVxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifFwiYnl0ZXNcInxPYmplY3R8Q29uc3RydWN0b3I8e30+fSBmaWVsZFZhbHVlVHlwZSBGaWVsZCB2YWx1ZSB0eXBlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IExvbmcgfCBzdHJpbmcgfCBib29sZWFuIHwgVWludDhBcnJheSB8IEJ1ZmZlciB8IG51bWJlcltdIHwgTWVzc2FnZTx7fT4gfVxuICovXG5NYXBGaWVsZC5kID0gZnVuY3Rpb24gZGVjb3JhdGVNYXBGaWVsZChmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSB7XG5cbiAgICAvLyBzdWJtZXNzYWdlIHZhbHVlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgLy8gZW51bSByZWZlcmVuY2UgdmFsdWU6IGNyZWF0ZSBhIHJlZmxlY3RlZCBjb3B5IG9mIHRoZSBlbnVtIGFuZCBrZWVwIHJldXNlaW5nIGl0XG4gICAgZWxzZSBpZiAoZmllbGRWYWx1ZVR5cGUgJiYgdHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcEZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE1hcEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkpO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNYXBGaWVsZCIsIkZpZWxkIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwidHlwZXMiLCJ1dGlsIiwibmFtZSIsImlkIiwia2V5VHlwZSIsInR5cGUiLCJvcHRpb25zIiwiY29tbWVudCIsImNhbGwiLCJ1bmRlZmluZWQiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInJlc29sdmVkS2V5VHlwZSIsIm1hcCIsImZyb21KU09OIiwianNvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJleHRlbmQiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJtYXBLZXkiLCJFcnJvciIsImQiLCJkZWNvcmF0ZU1hcEZpZWxkIiwiZmllbGRJZCIsImZpZWxkS2V5VHlwZSIsImZpZWxkVmFsdWVUeXBlIiwiZGVjb3JhdGVUeXBlIiwiZGVjb3JhdGVFbnVtIiwibWFwRmllbGREZWNvcmF0b3IiLCJmaWVsZE5hbWUiLCJhZGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/mapfield.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/message.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/message.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Message;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */ function Message(properties) {\n    // not used internally\n    if (properties) for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)this[keys[i]] = properties[keys[i]];\n}\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */ /**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */ /*eslint-disable valid-jsdoc*/ /**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.create = function create(properties) {\n    return this.$type.create(properties);\n};\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */ Message.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */ Message.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n}; /*eslint-enable valid-jsdoc*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0RUFBZ0I7QUFFbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0YsUUFBUUcsVUFBVTtJQUN2QixzQkFBc0I7SUFDdEIsSUFBSUEsWUFDQSxJQUFLLElBQUlDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0QsYUFBYUcsSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUUsRUFBRUQsRUFDL0QsSUFBSSxDQUFDRixJQUFJLENBQUNFLEVBQUUsQ0FBQyxHQUFHSCxVQUFVLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDO0FBQy9DO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVELDRCQUE0QixHQUU1Qjs7Ozs7O0NBTUMsR0FDRE4sUUFBUVEsTUFBTSxHQUFHLFNBQVNBLE9BQU9MLFVBQVU7SUFDdkMsT0FBTyxJQUFJLENBQUNNLEtBQUssQ0FBQ0QsTUFBTSxDQUFDTDtBQUM3QjtBQUVBOzs7Ozs7O0NBT0MsR0FDREgsUUFBUVUsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLE9BQU8sRUFBRUMsTUFBTTtJQUM1QyxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDQyxNQUFNLENBQUNDLFNBQVNDO0FBQ3RDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEWixRQUFRYSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCRixPQUFPLEVBQUVDLE1BQU07SUFDOUQsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksZUFBZSxDQUFDRixTQUFTQztBQUMvQztBQUVBOzs7Ozs7OztDQVFDLEdBQ0RaLFFBQVFjLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxNQUFNO0lBQ25DLE9BQU8sSUFBSSxDQUFDTixLQUFLLENBQUNLLE1BQU0sQ0FBQ0M7QUFDN0I7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEZixRQUFRZ0IsZUFBZSxHQUFHLFNBQVNBLGdCQUFnQkQsTUFBTTtJQUNyRCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTyxlQUFlLENBQUNEO0FBQ3RDO0FBRUE7Ozs7OztDQU1DLEdBQ0RmLFFBQVFpQixNQUFNLEdBQUcsU0FBU0EsT0FBT04sT0FBTztJQUNwQyxPQUFPLElBQUksQ0FBQ0YsS0FBSyxDQUFDUSxNQUFNLENBQUNOO0FBQzdCO0FBRUE7Ozs7OztDQU1DLEdBQ0RYLFFBQVFrQixVQUFVLEdBQUcsU0FBU0EsV0FBV0MsTUFBTTtJQUMzQyxPQUFPLElBQUksQ0FBQ1YsS0FBSyxDQUFDUyxVQUFVLENBQUNDO0FBQ2pDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEbkIsUUFBUW9CLFFBQVEsR0FBRyxTQUFTQSxTQUFTVCxPQUFPLEVBQUVVLE9BQU87SUFDakQsT0FBTyxJQUFJLENBQUNaLEtBQUssQ0FBQ1csUUFBUSxDQUFDVCxTQUFTVTtBQUN4QztBQUVBOzs7Q0FHQyxHQUNEckIsUUFBUXNCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNBO0lBQ2hDLE9BQU8sSUFBSSxDQUFDZCxLQUFLLENBQUNXLFFBQVEsQ0FBQyxJQUFJLEVBQUVuQixLQUFLdUIsYUFBYTtBQUN2RCxHQUVBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXNzYWdlLmpzPzgyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQWJzdHJhY3QgcnVudGltZSBtZXNzYWdlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb3BlcnRpZXM8VD59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZShwcm9wZXJ0aWVzKSB7XG4gICAgLy8gbm90IHVzZWQgaW50ZXJuYWxseVxuICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLiR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSByZWZsZWN0ZWQgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UjJHR5cGVcbiAqIEB0eXBlIHtUeXBlfVxuICogQHJlYWRvbmx5XG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPFQ+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5jcmVhdGUocHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIHVzZVxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZVxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5kZWNvZGVEZWxpbWl0ZWQocmVhZGVyKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UudmVyaWZ5XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuTWVzc2FnZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnZlcmlmeShtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge1R9IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge1R9IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0byBKU09OLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QodGhpcywgdXRpbC50b0pTT05PcHRpb25zKTtcbn07XG5cbi8qZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyovIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNZXNzYWdlIiwidXRpbCIsInJlcXVpcmUiLCJwcm9wZXJ0aWVzIiwia2V5cyIsIk9iamVjdCIsImkiLCJsZW5ndGgiLCJjcmVhdGUiLCIkdHlwZSIsImVuY29kZSIsIm1lc3NhZ2UiLCJ3cml0ZXIiLCJlbmNvZGVEZWxpbWl0ZWQiLCJkZWNvZGUiLCJyZWFkZXIiLCJkZWNvZGVEZWxpbWl0ZWQiLCJ2ZXJpZnkiLCJmcm9tT2JqZWN0Iiwib2JqZWN0IiwidG9PYmplY3QiLCJvcHRpb25zIiwicHJvdG90eXBlIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/message.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/method.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/method.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Method;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */ function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n    /* istanbul ignore next */ if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n    /* istanbul ignore if */ if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n    /* istanbul ignore if */ if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n    /* istanbul ignore if */ if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n    ReflectionObject.call(this, name, options);\n    /**\n     * Method type.\n     * @type {string}\n     */ this.type = type || \"rpc\"; // toJSON\n    /**\n     * Request type.\n     * @type {string}\n     */ this.requestType = requestType; // toJSON, marker\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */ this.requestStream = requestStream ? true : undefined; // toJSON\n    /**\n     * Response type.\n     * @type {string}\n     */ this.responseType = responseType; // toJSON\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */ this.responseStream = responseStream ? true : undefined; // toJSON\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */ this.resolvedRequestType = null;\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */ this.resolvedResponseType = null;\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Options properly parsed into an object\n     */ this.parsedOptions = parsedOptions;\n}\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */ /**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */ Method.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */ Method.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\",\n        this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\",\n        this.requestType,\n        \"requestStream\",\n        this.requestStream,\n        \"responseType\",\n        this.responseType,\n        \"responseStream\",\n        this.responseStream,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"parsedOptions\",\n        this.parsedOptions\n    ]);\n};\n/**\n * @override\n */ Method.prototype.resolve = function resolve() {\n    /* istanbul ignore if */ if (this.resolved) return this;\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n    return ReflectionObject.prototype.resolve.call(this);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ3hDLEVBQUNGLE9BQU9HLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixNQUFLLEVBQUdPLFNBQVMsR0FBRztBQUVsRyxJQUFJQyxPQUFPTixtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNGLE9BQU9TLElBQUksRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxjQUFjLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxhQUFhO0lBRWpILHdCQUF3QixHQUN4QixJQUFJVCxLQUFLVSxRQUFRLENBQUNMLGdCQUFnQjtRQUM5QkUsVUFBVUY7UUFDVkEsZ0JBQWdCQyxpQkFBaUJLO0lBQ3JDLE9BQU8sSUFBSVgsS0FBS1UsUUFBUSxDQUFDSixpQkFBaUI7UUFDdENDLFVBQVVEO1FBQ1ZBLGlCQUFpQks7SUFDckI7SUFFQSxzQkFBc0IsR0FDdEIsSUFBSSxDQUFFVCxDQUFBQSxTQUFTUyxhQUFhWCxLQUFLWSxRQUFRLENBQUNWLEtBQUksR0FDMUMsTUFBTVcsVUFBVTtJQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDYixLQUFLWSxRQUFRLENBQUNULGNBQ2YsTUFBTVUsVUFBVTtJQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDYixLQUFLWSxRQUFRLENBQUNSLGVBQ2YsTUFBTVMsVUFBVTtJQUVwQnBCLGlCQUFpQnFCLElBQUksQ0FBQyxJQUFJLEVBQUViLE1BQU1NO0lBRWxDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsSUFBSSxHQUFHQSxRQUFRLE9BQU8sU0FBUztJQUVwQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBR0EsYUFBYSxpQkFBaUI7SUFFakQ7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRSxhQUFhLEdBQUdBLGdCQUFnQixPQUFPTSxXQUFXLFNBQVM7SUFFaEU7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBLGNBQWMsU0FBUztJQUUzQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLGNBQWMsR0FBR0EsaUJBQWlCLE9BQU9LLFdBQVcsU0FBUztJQUVsRTs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLG1CQUFtQixHQUFHO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFFNUI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUixPQUFPLEdBQUdBO0lBRWY7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGFBQWEsR0FBR0E7QUFDekI7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEakIsT0FBT3lCLFFBQVEsR0FBRyxTQUFTQSxTQUFTaEIsSUFBSSxFQUFFaUIsSUFBSTtJQUMxQyxPQUFPLElBQUkxQixPQUFPUyxNQUFNaUIsS0FBS2hCLElBQUksRUFBRWdCLEtBQUtmLFdBQVcsRUFBRWUsS0FBS2QsWUFBWSxFQUFFYyxLQUFLYixhQUFhLEVBQUVhLEtBQUtaLGNBQWMsRUFBRVksS0FBS1gsT0FBTyxFQUFFVyxLQUFLVixPQUFPLEVBQUVVLEtBQUtULGFBQWE7QUFDbks7QUFFQTs7OztDQUlDLEdBQ0RqQixPQUFPRyxTQUFTLENBQUN3QixNQUFNLEdBQUcsU0FBU0EsT0FBT0MsYUFBYTtJQUNuRCxJQUFJQyxlQUFlRCxnQkFBZ0JFLFFBQVFGLGNBQWNDLFlBQVksSUFBSTtJQUN6RSxPQUFPckIsS0FBS3VCLFFBQVEsQ0FBQztRQUNqQjtRQUFtQixJQUFJLENBQUNyQixJQUFJLEtBQUssU0FBUyx3QkFBd0IsR0FBRyxJQUFJLENBQUNBLElBQUksSUFBSVM7UUFDbEY7UUFBbUIsSUFBSSxDQUFDUixXQUFXO1FBQ25DO1FBQW1CLElBQUksQ0FBQ0UsYUFBYTtRQUNyQztRQUFtQixJQUFJLENBQUNELFlBQVk7UUFDcEM7UUFBbUIsSUFBSSxDQUFDRSxjQUFjO1FBQ3RDO1FBQW1CLElBQUksQ0FBQ0MsT0FBTztRQUMvQjtRQUFtQmMsZUFBZSxJQUFJLENBQUNiLE9BQU8sR0FBR0c7UUFDakQ7UUFBbUIsSUFBSSxDQUFDRixhQUFhO0tBQ3hDO0FBQ0w7QUFFQTs7Q0FFQyxHQUNEakIsT0FBT0csU0FBUyxDQUFDNkIsT0FBTyxHQUFHLFNBQVNBO0lBRWhDLHNCQUFzQixHQUN0QixJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUNiLE9BQU8sSUFBSTtJQUVmLElBQUksQ0FBQ1YsbUJBQW1CLEdBQUcsSUFBSSxDQUFDVyxNQUFNLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUN4QixXQUFXO0lBQ2xFLElBQUksQ0FBQ2Esb0JBQW9CLEdBQUcsSUFBSSxDQUFDVSxNQUFNLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUN2QixZQUFZO0lBRXBFLE9BQU9YLGlCQUFpQkUsU0FBUyxDQUFDNkIsT0FBTyxDQUFDVixJQUFJLENBQUMsSUFBSTtBQUN2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXRob2QuanM/MTU0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWV0aG9kKS5jbGFzc05hbWUgPSBcIk1ldGhvZFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIG1ldGhvZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UgbWV0aG9kLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB0eXBlIE1ldGhvZCB0eXBlLCB1c3VhbGx5IGBcInJwY1wiYFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVxdWVzdFN0cmVhbV0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVzcG9uc2VTdHJlYW1dIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zLCBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtLCBvcHRpb25zLCBjb21tZW50LCBwYXJzZWRPcHRpb25zKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJlcXVlc3RTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXF1ZXN0U3RyZWFtO1xuICAgICAgICByZXF1ZXN0U3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHJlc3BvbnNlU3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVzcG9uc2VTdHJlYW07XG4gICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB1dGlsLmlzU3RyaW5nKHR5cGUpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlcXVlc3RUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdFR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXNwb25zZVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXNwb25zZVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCBcInJwY1wiOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFR5cGUgPSByZXF1ZXN0VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdFN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IHBhcnNlZE9wdGlvbnM7XG59XG5cbi8qKlxuICogTWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT1cInJwY1wiXSBNZXRob2QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSB0eXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1ZXN0U3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzcG9uc2VTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE1ldGhvZCBvcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWVudCBNZXRob2QgY29tbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBNZXRob2Qgb3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtZXRob2QgZnJvbSBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gQ3JlYXRlZCBtZXRob2RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1ldGhvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChuYW1lLCBqc29uLnR5cGUsIGpzb24ucmVxdWVzdFR5cGUsIGpzb24ucmVzcG9uc2VUeXBlLCBqc29uLnJlcXVlc3RTdHJlYW0sIGpzb24ucmVzcG9uc2VTdHJlYW0sIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLnBhcnNlZE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1ldGhvZH0gTWV0aG9kIGRlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgICAsIHRoaXMudHlwZSAhPT0gXCJycGNcIiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLnR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInJlcXVlc3RUeXBlXCIgICAgLCB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIFwicmVzcG9uc2VUeXBlXCIgICAsIHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBcInJlc3BvbnNlU3RyZWFtXCIgLCB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJwYXJzZWRPcHRpb25zXCIgICwgdGhpcy5wYXJzZWRPcHRpb25zLFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1ldGhvZCIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJ1dGlsIiwibmFtZSIsInR5cGUiLCJyZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsIm9wdGlvbnMiLCJjb21tZW50IiwicGFyc2VkT3B0aW9ucyIsImlzT2JqZWN0IiwidW5kZWZpbmVkIiwiaXNTdHJpbmciLCJUeXBlRXJyb3IiLCJjYWxsIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwiZnJvbUpTT04iLCJqc29uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsInJlc29sdmUiLCJyZXNvbHZlZCIsInBhcmVudCIsImxvb2t1cFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/method.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/namespace.js":
/*!***************************************************!*\
  !*** ../node_modules/protobufjs/src/namespace.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Namespace;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\");\nvar Type, Service, Enum;\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */ Namespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */ function arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length)) return undefined;\n    var obj = {};\n    for(var i = 0; i < array.length; ++i)obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n    }\n    return false;\n};\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (reserved[i] === name) return true;\n    }\n    return false;\n};\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */ function Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */ this.nested = undefined; // toJSON\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */ this._nestedArray = null;\n    /**\n     * Cache lookup calls for any objects contains anywhere under this namespace.\n     * This drastically speeds up resolve for large cross-linked protos where the same\n     * types are looked up repeatedly.\n     * @type {Object.<string,ReflectionObject|null>}\n     * @private\n     */ this._lookupCache = {};\n    /**\n     * Whether or not objects contained in this namespace need feature resolution.\n     * @type {boolean}\n     * @protected\n     */ this._needsRecursiveFeatureResolution = true;\n    /**\n     * Whether or not objects contained in this namespace need a resolve.\n     * @type {boolean}\n     * @protected\n     */ this._needsRecursiveResolve = true;\n}\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    namespace._lookupCache = {};\n    // Also clear parent caches, since they include nested lookups.\n    var parent = namespace;\n    while(parent = parent.parent){\n        parent._lookupCache = {};\n    }\n    return namespace;\n}\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */ Object.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */ /**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */ /**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */ /**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */ Namespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"nested\",\n        arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */ Namespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */ if (nestedJson) {\n        for(var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i){\n            nested = nestedJson[names[i]];\n            ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n        }\n    }\n    return this;\n};\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */ Namespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name] || null;\n};\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */ Namespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */ Namespace.prototype.add = function add(object) {\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n    if (!this.nested) this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for(var i = 0; i < nested.length; ++i)object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested) this.nested = {};\n                object.setOptions(prev.options, true);\n            } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {\n        // This is a package or a root namespace.\n        if (!object._edition) {\n            // Make sure that some edition is set if it hasn't already been specified.\n            object._edition = object._defaultEdition;\n        }\n    }\n    this._needsRecursiveFeatureResolution = true;\n    this._needsRecursiveResolve = true;\n    // Also clear parent caches, since they need to recurse down.\n    var parent = this;\n    while(parent = parent.parent){\n        parent._needsRecursiveFeatureResolution = true;\n        parent._needsRecursiveResolve = true;\n    }\n    object.onAdd(this);\n    return clearCache(this);\n};\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */ Namespace.prototype.remove = function remove(object) {\n    if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length) this.nested = undefined;\n    object.onRemove(this);\n    return clearCache(this);\n};\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */ Namespace.prototype.define = function define(path, json) {\n    if (util.isString(path)) path = path.split(\".\");\n    else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n    var ptr = this;\n    while(path.length > 0){\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n        } else ptr.add(ptr = new Namespace(part));\n    }\n    if (json) ptr.addJSON(json);\n    return ptr;\n};\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */ Namespace.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    this._resolveFeaturesRecursive(this._edition);\n    var nested = this.nestedArray, i = 0;\n    this.resolve();\n    while(i < nested.length)if (nested[i] instanceof Namespace) nested[i++].resolveAll();\n    else nested[i++].resolve();\n    this._needsRecursiveResolve = false;\n    return this;\n};\n/**\n * @override\n */ Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    this._needsRecursiveFeatureResolution = false;\n    edition = this._edition || edition;\n    ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.nestedArray.forEach((nested)=>{\n        nested._resolveFeaturesRecursive(edition);\n    });\n    return this;\n};\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n    /* istanbul ignore next */ if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [\n        filterTypes\n    ];\n    if (util.isString(path) && path.length) {\n        if (path === \".\") return this.root;\n        path = path.split(\".\");\n    } else if (!path.length) return this;\n    var flatPath = path.join(\".\");\n    // Start at root if path is absolute\n    if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n    // Early bailout for objects with matching absolute paths\n    var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects[\".\" + flatPath];\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n    // Do a regular lookup at this namespace and below\n    found = this._lookupImpl(path, flatPath);\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n    if (parentAlreadyChecked) return null;\n    // If there hasn't been a match, walk up the tree and look more broadly\n    var current = this;\n    while(current.parent){\n        found = current.parent._lookupImpl(path, flatPath);\n        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n            return found;\n        }\n        current = current.parent;\n    }\n    return null;\n};\n/**\n * Internal helper for lookup that handles searching just at this namespace and below along with caching.\n * @param {string[]} path Path to look up\n * @param {string} flatPath Flattened version of the path to use as a cache key\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @private\n */ Namespace.prototype._lookupImpl = function lookup(path, flatPath) {\n    if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {\n        return this._lookupCache[flatPath];\n    }\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    var exact = null;\n    if (found) {\n        if (path.length === 1) {\n            exact = found;\n        } else if (found instanceof Namespace) {\n            path = path.slice(1);\n            exact = found._lookupImpl(path, path.join(\".\"));\n        }\n    // Otherwise try each nested namespace\n    } else {\n        for(var i = 0; i < this.nestedArray.length; ++i)if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath))) exact = found;\n    }\n    // Set this even when null, so that when we walk up the tree we can quickly bail on repeated checks back down.\n    this._lookupCache[flatPath] = exact;\n    return exact;\n};\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */ // lookup(path: string, [parentAlreadyChecked: boolean])\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */ Namespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [\n        Type\n    ]);\n    if (!found) throw Error(\"no such type: \" + path);\n    return found;\n};\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */ Namespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */ Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [\n        Type,\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */ Namespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [\n        Service\n    ]);\n    if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type = Type_;\n    Service = Service_;\n    Enum = Enum_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL25hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ3hDLEVBQUNGLFVBQVVHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixTQUFRLEVBQUdPLFNBQVMsR0FBRztBQUV4RyxJQUFJQyxRQUFXTixtQkFBT0EsQ0FBQyw4REFBUyxHQUM1Qk8sT0FBV1AsbUJBQU9BLENBQUMsNERBQVEsR0FDM0JRLFFBQVdSLG1CQUFPQSxDQUFDLDhEQUFTO0FBRWhDLElBQUlTLE1BQ0FDLFNBQ0FDO0FBRUo7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUNEYixVQUFVYyxRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQzdDLE9BQU8sSUFBSWhCLFVBQVVlLE1BQU1DLEtBQUtDLE9BQU8sRUFBRUMsT0FBTyxDQUFDRixLQUFLRyxNQUFNO0FBQ2hFO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsWUFBWUMsS0FBSyxFQUFFQyxhQUFhO0lBQ3JDLElBQUksQ0FBRUQsQ0FBQUEsU0FBU0EsTUFBTUUsTUFBTSxHQUN2QixPQUFPQztJQUNYLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNRSxNQUFNLEVBQUUsRUFBRUcsRUFDaENELEdBQUcsQ0FBQ0osS0FBSyxDQUFDSyxFQUFFLENBQUNYLElBQUksQ0FBQyxHQUFHTSxLQUFLLENBQUNLLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDTDtJQUN6QyxPQUFPRztBQUNYO0FBRUF6QixVQUFVb0IsV0FBVyxHQUFHQTtBQUV4Qjs7Ozs7Q0FLQyxHQUNEcEIsVUFBVTRCLFlBQVksR0FBRyxTQUFTQSxhQUFhQyxR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QUFLLEVBQUVDLFFBQVEsRUFBRUMsS0FBSztJQUNsRHpGLE9BQVV1RjtJQUNWdEYsVUFBVXVGO0lBQ1Z0RixPQUFVdUY7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9uYW1lc3BhY2UuanM/NDIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChOYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTmFtZXNwYWNlKS5jbGFzc05hbWUgPSBcIk5hbWVzcGFjZVwiO1xuXG52YXIgRmllbGQgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgT25lT2YgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcblxudmFyIFR5cGUsICAgIC8vIGN5Y2xpY1xuICAgIFNlcnZpY2UsXG4gICAgRW51bTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG5hbWVzcGFjZSBpbnN0YW5jZS5cbiAqIEBuYW1lIE5hbWVzcGFjZVxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbmFtZXNwYWNlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuYW1lc3BhY2UgZnJvbSBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBKU09OIG9iamVjdFxuICogQHJldHVybnMge05hbWVzcGFjZX0gQ3JlYXRlZCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk5hbWVzcGFjZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE5hbWVzcGFjZShuYW1lLCBqc29uLm9wdGlvbnMpLmFkZEpTT04oanNvbi5uZXN0ZWQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiByZWZsZWN0aW9uIG9iamVjdHMgdG8gSlNPTi5cbiAqIEBtZW1iZXJvZiBOYW1lc3BhY2VcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdFtdfSBhcnJheSBPYmplY3QgYXJyYXlcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fHVuZGVmaW5lZH0gSlNPTiBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgd2hlbiBhcnJheSBpcyBlbXB0eVxuICovXG5mdW5jdGlvbiBhcnJheVRvSlNPTihhcnJheSwgdG9KU09OT3B0aW9ucykge1xuICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIG9ialthcnJheVtpXS5uYW1lXSA9IGFycmF5W2ldLnRvSlNPTih0b0pTT05PcHRpb25zKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5OYW1lc3BhY2UuYXJyYXlUb0pTT04gPSBhcnJheVRvSlNPTjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5OYW1lc3BhY2UuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKHJlc2VydmVkLCBpZCkge1xuICAgIGlmIChyZXNlcnZlZClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzZXJ2ZWRbaV0gIT09IFwic3RyaW5nXCIgJiYgcmVzZXJ2ZWRbaV1bMF0gPD0gaWQgJiYgcmVzZXJ2ZWRbaV1bMV0gPiBpZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz58dW5kZWZpbmVkfSByZXNlcnZlZCBBcnJheSBvZiByZXNlcnZlZCByYW5nZXMgYW5kIG5hbWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKHJlc2VydmVkLCBuYW1lKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHJlc2VydmVkW2ldID09PSBuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogTm90IGFuIGFjdHVhbCBjb25zdHJ1Y3Rvci4gVXNlIHtAbGluayBOYW1lc3BhY2V9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3Rpb24gb2JqZWN0cyBjb250YWluaW5nIG5lc3RlZCBvYmplY3RzLiBUaGlzIGlzIG5vdCBhbiBhY3R1YWwgY2xhc3MgYnV0IGhlcmUgZm9yIHRoZSBzYWtlIG9mIGhhdmluZyBjb25zaXN0ZW50IHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAZXhwb3J0cyBOYW1lc3BhY2VCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAYWJzdHJhY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAc2VlIHtAbGluayBOYW1lc3BhY2V9XG4gKi9cbmZ1bmN0aW9uIE5hbWVzcGFjZShuYW1lLCBvcHRpb25zKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTmVzdGVkIG9iamVjdHMgYnkgbmFtZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUmVmbGVjdGlvbk9iamVjdD58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBuZXN0ZWQgb2JqZWN0cyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9uZXN0ZWRBcnJheSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBsb29rdXAgY2FsbHMgZm9yIGFueSBvYmplY3RzIGNvbnRhaW5zIGFueXdoZXJlIHVuZGVyIHRoaXMgbmFtZXNwYWNlLlxuICAgICAqIFRoaXMgZHJhc3RpY2FsbHkgc3BlZWRzIHVwIHJlc29sdmUgZm9yIGxhcmdlIGNyb3NzLWxpbmtlZCBwcm90b3Mgd2hlcmUgdGhlIHNhbWVcbiAgICAgKiB0eXBlcyBhcmUgbG9va2VkIHVwIHJlcGVhdGVkbHkuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLFJlZmxlY3Rpb25PYmplY3R8bnVsbD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sb29rdXBDYWNoZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3Qgb2JqZWN0cyBjb250YWluZWQgaW4gdGhpcyBuYW1lc3BhY2UgbmVlZCBmZWF0dXJlIHJlc29sdXRpb24uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3Qgb2JqZWN0cyBjb250YWluZWQgaW4gdGhpcyBuYW1lc3BhY2UgbmVlZCBhIHJlc29sdmUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUobmFtZXNwYWNlKSB7XG4gICAgbmFtZXNwYWNlLl9uZXN0ZWRBcnJheSA9IG51bGw7XG4gICAgbmFtZXNwYWNlLl9sb29rdXBDYWNoZSA9IHt9O1xuXG4gICAgLy8gQWxzbyBjbGVhciBwYXJlbnQgY2FjaGVzLCBzaW5jZSB0aGV5IGluY2x1ZGUgbmVzdGVkIGxvb2t1cHMuXG4gICAgdmFyIHBhcmVudCA9IG5hbWVzcGFjZTtcbiAgICB3aGlsZShwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5fbG9va3VwQ2FjaGUgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbn1cblxuLyoqXG4gKiBOZXN0ZWQgb2JqZWN0cyBvZiB0aGlzIG5hbWVzcGFjZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNuZXN0ZWRBcnJheVxuICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3RbXX1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTmFtZXNwYWNlLnByb3RvdHlwZSwgXCJuZXN0ZWRBcnJheVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lc3RlZEFycmF5IHx8ICh0aGlzLl9uZXN0ZWRBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm5lc3RlZCkpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTmFtZXNwYWNlIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsQW55TmVzdGVkT2JqZWN0Pn0gW25lc3RlZF0gTmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yc1xuICovXG5cbi8qKlxuICogQW55IGV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55RXh0ZW5zaW9uRmllbGRcbiAqIEB0eXBlIHtJRXh0ZW5zaW9uRmllbGR8SUV4dGVuc2lvbk1hcEZpZWxkfVxuICovXG5cbi8qKlxuICogQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvci5cbiAqIEB0eXBlZGVmIEFueU5lc3RlZE9iamVjdFxuICogQHR5cGUge0lFbnVtfElUeXBlfElTZXJ2aWNlfEFueUV4dGVuc2lvbkZpZWxkfElOYW1lc3BhY2V8SU9uZU9mfVxuICovXG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBuYW1lc3BhY2UgdG8gYSBuYW1lc3BhY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lOYW1lc3BhY2V9IE5hbWVzcGFjZSBkZXNjcmlwdG9yXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcIm5lc3RlZFwiICAsIGFycmF5VG9KU09OKHRoaXMubmVzdGVkQXJyYXksIHRvSlNPTk9wdGlvbnMpXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgbmVzdGVkIG9iamVjdHMgdG8gdGhpcyBuYW1lc3BhY2UgZnJvbSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBuZXN0ZWRKc29uIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGRKU09OID0gZnVuY3Rpb24gYWRkSlNPTihuZXN0ZWRKc29uKSB7XG4gICAgdmFyIG5zID0gdGhpcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChuZXN0ZWRKc29uKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXMobmVzdGVkSnNvbiksIGkgPSAwLCBuZXN0ZWQ7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmVzdGVkID0gbmVzdGVkSnNvbltuYW1lc1tpXV07XG4gICAgICAgICAgICBucy5hZGQoIC8vIG1vc3QgdG8gbGVhc3QgbGlrZWx5XG4gICAgICAgICAgICAgICAgKCBuZXN0ZWQuZmllbGRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFR5cGUuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC52YWx1ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRW51bS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLm1ldGhvZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gU2VydmljZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBOYW1lc3BhY2UuZnJvbUpTT04gKShuYW1lc1tpXSwgbmVzdGVkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbmVzdGVkIG9iamVjdCBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgb2JqZWN0IG5hbWVcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IFRoZSByZWZsZWN0aW9uIG9iamVjdCBvciBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmVzdGVkIHtAbGluayBFbnVtfGVudW19IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIFRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNnZXR8Z2V0fSBpbiB0aGF0IGl0IHJldHVybnMgYW4gZW51bSdzIHZhbHVlcyBkaXJlY3RseSBhbmQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBlbnVtIG5hbWVcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBFbnVtIHZhbHVlc1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldEVudW0gPSBmdW5jdGlvbiBnZXRFbnVtKG5hbWUpIHtcbiAgICBpZiAodGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV0gaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXN0ZWRbbmFtZV0udmFsdWVzO1xuICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBlbnVtOiBcIiArIG5hbWUpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmVzdGVkIG9iamVjdCB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5lc3RlZCBvYmplY3Qgd2l0aCB0aGlzIG5hbWVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgVHlwZSAgfHwgb2JqZWN0IGluc3RhbmNlb2YgT25lT2YgfHwgb2JqZWN0IGluc3RhbmNlb2YgRW51bSB8fCBvYmplY3QgaW5zdGFuY2VvZiBTZXJ2aWNlIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9iamVjdCBtdXN0IGJlIGEgdmFsaWQgbmVzdGVkIG9iamVjdFwiKTtcblxuICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXQob2JqZWN0Lm5hbWUpO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKHByZXYgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlICYmICEocHJldiBpbnN0YW5jZW9mIFR5cGUgfHwgcHJldiBpbnN0YW5jZW9mIFNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwbGFpbiBuYW1lc3BhY2UgYnV0IGtlZXAgZXhpc3RpbmcgbmVzdGVkIGVsZW1lbnRzIGFuZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZCA9IHByZXYubmVzdGVkQXJyYXk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXN0ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGQobmVzdGVkW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShwcmV2KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmVzdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHt9O1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZXRPcHRpb25zKHByZXYub3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5lc3RlZFtvYmplY3QubmFtZV0gPSBvYmplY3Q7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHlwZSB8fCB0aGlzIGluc3RhbmNlb2YgU2VydmljZSB8fCB0aGlzIGluc3RhbmNlb2YgRW51bSB8fCB0aGlzIGluc3RhbmNlb2YgRmllbGQpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBwYWNrYWdlIG9yIGEgcm9vdCBuYW1lc3BhY2UuXG4gICAgICAgIGlmICghb2JqZWN0Ll9lZGl0aW9uKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBzb21lIGVkaXRpb24gaXMgc2V0IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc3BlY2lmaWVkLlxuICAgICAgICAgICAgb2JqZWN0Ll9lZGl0aW9uID0gb2JqZWN0Ll9kZWZhdWx0RWRpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24gPSB0cnVlO1xuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSA9IHRydWU7XG5cbiAgICAvLyBBbHNvIGNsZWFyIHBhcmVudCBjYWNoZXMsIHNpbmNlIHRoZXkgbmVlZCB0byByZWN1cnNlIGRvd24uXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgd2hpbGUocGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICBwYXJlbnQuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgb2JqZWN0YCBpcyBub3QgYSBtZW1iZXIgb2YgdGhpcyBuYW1lc3BhY2VcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG5cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBSZWZsZWN0aW9uT2JqZWN0KSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSBSZWZsZWN0aW9uT2JqZWN0XCIpO1xuICAgIGlmIChvYmplY3QucGFyZW50ICE9PSB0aGlzKVxuICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgIGRlbGV0ZSB0aGlzLm5lc3RlZFtvYmplY3QubmFtZV07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm5lc3RlZCkubGVuZ3RoKVxuICAgICAgICB0aGlzLm5lc3RlZCA9IHVuZGVmaW5lZDtcblxuICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhZGRpdGlhbCBuYW1lc3BhY2VzIHdpdGhpbiB0aGlzIG9uZSBpZiBub3QgeWV0IGV4aXN0aW5nLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Kn0gW2pzb25dIE5lc3RlZCB0eXBlcyB0byBjcmVhdGUgZnJvbSBKU09OXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBQb2ludGVyIHRvIHRoZSBsYXN0IG5hbWVzcGFjZSBjcmVhdGVkIG9yIGB0aGlzYCBpZiBwYXRoIGlzIGVtcHR5XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKHBhdGgsIGpzb24pIHtcblxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHBhdGgpKVxuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlsbGVnYWwgcGF0aFwiKTtcbiAgICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCAmJiBwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICB0aHJvdyBFcnJvcihcInBhdGggbXVzdCBiZSByZWxhdGl2ZVwiKTtcblxuICAgIHZhciBwdHIgPSB0aGlzO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwdHIubmVzdGVkICYmIHB0ci5uZXN0ZWRbcGFydF0pIHtcbiAgICAgICAgICAgIHB0ciA9IHB0ci5uZXN0ZWRbcGFydF07XG4gICAgICAgICAgICBpZiAoIShwdHIgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwicGF0aCBjb25mbGljdHMgd2l0aCBub24tbmFtZXNwYWNlIG9iamVjdHNcIik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcHRyLmFkZChwdHIgPSBuZXcgTmFtZXNwYWNlKHBhcnQpKTtcbiAgICB9XG4gICAgaWYgKGpzb24pXG4gICAgICAgIHB0ci5hZGRKU09OKGpzb24pO1xuICAgIHJldHVybiBwdHI7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgbmFtZXNwYWNlJ3MgYW5kIGFsbCBpdHMgbmVzdGVkIG9iamVjdHMnIHR5cGUgcmVmZXJlbmNlcy4gVXNlZnVsIHRvIHZhbGlkYXRlIGEgcmVmbGVjdGlvbiB0cmVlLCBidXQgY29tZXMgYXQgYSBjb3N0LlxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZVJlc29sdmUpIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKHRoaXMuX2VkaXRpb24pO1xuXG4gICAgdmFyIG5lc3RlZCA9IHRoaXMubmVzdGVkQXJyYXksIGkgPSAwO1xuICAgIHRoaXMucmVzb2x2ZSgpO1xuICAgIHdoaWxlIChpIDwgbmVzdGVkLmxlbmd0aClcbiAgICAgICAgaWYgKG5lc3RlZFtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmVBbGwoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZSgpO1xuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlID0gZnVuY3Rpb24gX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZShlZGl0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uID0gZmFsc2U7XG5cbiAgICBlZGl0aW9uID0gdGhpcy5fZWRpdGlvbiB8fCBlZGl0aW9uO1xuXG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZS5jYWxsKHRoaXMsIGVkaXRpb24pO1xuICAgIHRoaXMubmVzdGVkQXJyYXkuZm9yRWFjaChuZXN0ZWQgPT4ge1xuICAgICAgICBuZXN0ZWQuX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZShlZGl0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbG9va3MgdXAgdGhlIHJlZmxlY3Rpb24gb2JqZWN0IG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcGF0aCBpbiB0aGUgc2NvcGUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB7KnxBcnJheS48Kj59IGZpbHRlclR5cGVzIEZpbHRlciB0eXBlcywgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSBjb25zdHJ1Y3RvcnMgb2YgYHByb3RvYnVmLlR5cGVgLCBgcHJvdG9idWYuRW51bWAsIGBwcm90b2J1Zi5TZXJ2aWNlYCBldGMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gSWYga25vd24sIHdoZXRoZXIgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAocGF0aCwgZmlsdGVyVHlwZXMsIHBhcmVudEFscmVhZHlDaGVja2VkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGZpbHRlclR5cGVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBwYXJlbnRBbHJlYWR5Q2hlY2tlZCA9IGZpbHRlclR5cGVzO1xuICAgICAgICBmaWx0ZXJUeXBlcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGZpbHRlclR5cGVzICYmICFBcnJheS5pc0FycmF5KGZpbHRlclR5cGVzKSlcbiAgICAgICAgZmlsdGVyVHlwZXMgPSBbIGZpbHRlclR5cGVzIF07XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgfSBlbHNlIGlmICghcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGZsYXRQYXRoID0gcGF0aC5qb2luKFwiLlwiKTtcblxuICAgIC8vIFN0YXJ0IGF0IHJvb3QgaWYgcGF0aCBpcyBhYnNvbHV0ZVxuICAgIGlmIChwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAvLyBFYXJseSBiYWlsb3V0IGZvciBvYmplY3RzIHdpdGggbWF0Y2hpbmcgYWJzb2x1dGUgcGF0aHNcbiAgICB2YXIgZm91bmQgPSB0aGlzLnJvb3QuX2Z1bGx5UXVhbGlmaWVkT2JqZWN0cyAmJiB0aGlzLnJvb3QuX2Z1bGx5UXVhbGlmaWVkT2JqZWN0c1tcIi5cIiArIGZsYXRQYXRoXTtcbiAgICBpZiAoZm91bmQgJiYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKSkge1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gRG8gYSByZWd1bGFyIGxvb2t1cCBhdCB0aGlzIG5hbWVzcGFjZSBhbmQgYmVsb3dcbiAgICBmb3VuZCA9IHRoaXMuX2xvb2t1cEltcGwocGF0aCwgZmxhdFBhdGgpO1xuICAgIGlmIChmb3VuZCAmJiAoIWZpbHRlclR5cGVzIHx8IGZpbHRlclR5cGVzLmluZGV4T2YoZm91bmQuY29uc3RydWN0b3IpID4gLTEpKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50QWxyZWFkeUNoZWNrZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gSWYgdGhlcmUgaGFzbid0IGJlZW4gYSBtYXRjaCwgd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBtb3JlIGJyb2FkbHlcbiAgICB2YXIgY3VycmVudCA9IHRoaXM7XG4gICAgd2hpbGUgKGN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIGZvdW5kID0gY3VycmVudC5wYXJlbnQuX2xvb2t1cEltcGwocGF0aCwgZmxhdFBhdGgpO1xuICAgICAgICBpZiAoZm91bmQgJiYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgbG9va3VwIHRoYXQgaGFuZGxlcyBzZWFyY2hpbmcganVzdCBhdCB0aGlzIG5hbWVzcGFjZSBhbmQgYmVsb3cgYWxvbmcgd2l0aCBjYWNoaW5nLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbGF0UGF0aCBGbGF0dGVuZWQgdmVyc2lvbiBvZiB0aGUgcGF0aCB0byB1c2UgYXMgYSBjYWNoZSBrZXlcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuX2xvb2t1cEltcGwgPSBmdW5jdGlvbiBsb29rdXAocGF0aCwgZmxhdFBhdGgpIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fbG9va3VwQ2FjaGUsIGZsYXRQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwQ2FjaGVbZmxhdFBhdGhdO1xuICAgIH1cblxuICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IHBhcnQgbWF0Y2hlcyBhbnkgbmVzdGVkIG9iamVjdCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSBpZiBwYXRoIGNvbnRhaW5zIG1vcmVcbiAgICB2YXIgZm91bmQgPSB0aGlzLmdldChwYXRoWzBdKTtcbiAgICB2YXIgZXhhY3QgPSBudWxsO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGV4YWN0ID0gZm91bmQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICAgICAgZXhhY3QgPSBmb3VuZC5fbG9va3VwSW1wbChwYXRoLCBwYXRoLmpvaW4oXCIuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIHRyeSBlYWNoIG5lc3RlZCBuYW1lc3BhY2VcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgKGZvdW5kID0gdGhpcy5fbmVzdGVkQXJyYXlbaV0uX2xvb2t1cEltcGwocGF0aCwgZmxhdFBhdGgpKSlcbiAgICAgICAgICAgICAgICBleGFjdCA9IGZvdW5kO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGlzIGV2ZW4gd2hlbiBudWxsLCBzbyB0aGF0IHdoZW4gd2Ugd2FsayB1cCB0aGUgdHJlZSB3ZSBjYW4gcXVpY2tseSBiYWlsIG9uIHJlcGVhdGVkIGNoZWNrcyBiYWNrIGRvd24uXG4gICAgdGhpcy5fbG9va3VwQ2FjaGVbZmxhdFBhdGhdID0gZXhhY3Q7XG4gICAgcmV0dXJuIGV4YWN0O1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEBuYW1lIE5hbWVzcGFjZUJhc2UjbG9va3VwXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHtib29sZWFufSBbcGFyZW50QWxyZWFkeUNoZWNrZWQ9ZmFsc2VdIFdoZXRoZXIgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBsb29rdXAocGF0aDogc3RyaW5nLCBbcGFyZW50QWxyZWFkeUNoZWNrZWQ6IGJvb2xlYW5dKVxuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSB0eXBlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwVHlwZSA9IGZ1bmN0aW9uIGxvb2t1cFR5cGUocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgVHlwZSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggdHlwZTogXCIgKyBwYXRoKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB2YWx1ZXMgb2YgdGhlIHtAbGluayBFbnVtfGVudW19IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtFbnVtfSBMb29rZWQgdXAgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhbiBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwRW51bSA9IGZ1bmN0aW9uIGxvb2t1cEVudW0ocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgRW51bSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFR5cGV8dHlwZX0gb3Ige0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1R5cGV9IExvb2tlZCB1cCB0eXBlIG9yIGVudW1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSB0eXBlIG9yIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlT3JFbnVtID0gZnVuY3Rpb24gbG9va3VwVHlwZU9yRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlLCBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBUeXBlIG9yIEVudW0gJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBTZXJ2aWNlfHNlcnZpY2V9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBMb29rZWQgdXAgc2VydmljZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHNlcnZpY2VcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBTZXJ2aWNlID0gZnVuY3Rpb24gbG9va3VwU2VydmljZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBTZXJ2aWNlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBTZXJ2aWNlICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcbk5hbWVzcGFjZS5fY29uZmlndXJlID0gZnVuY3Rpb24oVHlwZV8sIFNlcnZpY2VfLCBFbnVtXykge1xuICAgIFR5cGUgICAgPSBUeXBlXztcbiAgICBTZXJ2aWNlID0gU2VydmljZV87XG4gICAgRW51bSAgICA9IEVudW1fO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiTmFtZXNwYWNlIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkZpZWxkIiwidXRpbCIsIk9uZU9mIiwiVHlwZSIsIlNlcnZpY2UiLCJFbnVtIiwiZnJvbUpTT04iLCJuYW1lIiwianNvbiIsIm9wdGlvbnMiLCJhZGRKU09OIiwibmVzdGVkIiwiYXJyYXlUb0pTT04iLCJhcnJheSIsInRvSlNPTk9wdGlvbnMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJvYmoiLCJpIiwidG9KU09OIiwiaXNSZXNlcnZlZElkIiwicmVzZXJ2ZWQiLCJpZCIsImlzUmVzZXJ2ZWROYW1lIiwiY2FsbCIsIl9uZXN0ZWRBcnJheSIsIl9sb29rdXBDYWNoZSIsIl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uIiwiX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSIsImNsZWFyQ2FjaGUiLCJuYW1lc3BhY2UiLCJwYXJlbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInRvQXJyYXkiLCJ0b09iamVjdCIsIm5lc3RlZEFycmF5IiwibmVzdGVkSnNvbiIsIm5zIiwibmFtZXMiLCJrZXlzIiwiYWRkIiwiZmllbGRzIiwidmFsdWVzIiwibWV0aG9kcyIsImdldEVudW0iLCJFcnJvciIsIm9iamVjdCIsImV4dGVuZCIsIlR5cGVFcnJvciIsInByZXYiLCJyZW1vdmUiLCJzZXRPcHRpb25zIiwiX2VkaXRpb24iLCJfZGVmYXVsdEVkaXRpb24iLCJvbkFkZCIsIm9uUmVtb3ZlIiwiZGVmaW5lIiwicGF0aCIsImlzU3RyaW5nIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJwdHIiLCJwYXJ0Iiwic2hpZnQiLCJyZXNvbHZlQWxsIiwiX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZSIsInJlc29sdmUiLCJlZGl0aW9uIiwiZm9yRWFjaCIsImxvb2t1cCIsImZpbHRlclR5cGVzIiwicGFyZW50QWxyZWFkeUNoZWNrZWQiLCJyb290IiwiZmxhdFBhdGgiLCJqb2luIiwic2xpY2UiLCJmb3VuZCIsIl9mdWxseVF1YWxpZmllZE9iamVjdHMiLCJpbmRleE9mIiwiX2xvb2t1cEltcGwiLCJjdXJyZW50IiwiaGFzT3duUHJvcGVydHkiLCJleGFjdCIsImxvb2t1cFR5cGUiLCJsb29rdXBFbnVtIiwibG9va3VwVHlwZU9yRW51bSIsImxvb2t1cFNlcnZpY2UiLCJfY29uZmlndXJlIiwiVHlwZV8iLCJTZXJ2aWNlXyIsIkVudW1fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/namespace.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/object.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/object.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\nconst OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\");\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Root; // cyclic\n/* eslint-disable no-warning-comments */ // TODO: Replace with embedded proto.\nvar editions2023Defaults = {\n    enum_type: \"OPEN\",\n    field_presence: \"EXPLICIT\",\n    json_format: \"ALLOW\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"PACKED\",\n    utf8_validation: \"VERIFY\"\n};\nvar proto2Defaults = {\n    enum_type: \"CLOSED\",\n    field_presence: \"EXPLICIT\",\n    json_format: \"LEGACY_BEST_EFFORT\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"EXPANDED\",\n    utf8_validation: \"NONE\"\n};\nvar proto3Defaults = {\n    enum_type: \"OPEN\",\n    field_presence: \"IMPLICIT\",\n    json_format: \"ALLOW\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"PACKED\",\n    utf8_validation: \"VERIFY\"\n};\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */ function ReflectionObject(name, options) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */ this.options = options; // toJSON\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */ this.parsedOptions = null;\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */ this.name = name;\n    /**\n     * The edition specified for this object.  Only relevant for top-level objects.\n     * @type {string}\n     * @private\n     */ this._edition = null;\n    /**\n     * The default edition to use for this object if none is specified.  For legacy reasons,\n     * this is proto2 except in the JSON parsing case where it was proto3.\n     * @type {string}\n     * @private\n     */ this._defaultEdition = \"proto2\";\n    /**\n     * Resolved Features.\n     * @type {object}\n     * @private\n     */ this._features = {};\n    /**\n     * Whether or not features have been resolved.\n     * @type {boolean}\n     * @private\n     */ this._featuresResolved = false;\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */ this.parent = null;\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */ this.resolved = false;\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */ this.comment = null;\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */ this.filename = null;\n}\nObject.defineProperties(ReflectionObject.prototype, {\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */ root: {\n        get: function() {\n            var ptr = this;\n            while(ptr.parent !== null)ptr = ptr.parent;\n            return ptr;\n        }\n    },\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */ fullName: {\n        get: function() {\n            var path = [\n                this.name\n            ], ptr = this.parent;\n            while(ptr){\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */ ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */ ReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent) this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root) root._handleAdd(this);\n};\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */ ReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root) root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if (this.root instanceof Root) this.resolved = true; // only if part of a root\n    return this;\n};\n/**\n * Resolves this objects editions features.\n * @param {string} edition The edition we're currently resolving for.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    return this._resolveFeatures(this._edition || edition);\n};\n/**\n * Resolves child features from parent features\n * @param {string} edition The edition we're currently resolving for.\n * @returns {undefined}\n */ ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    if (this._featuresResolved) {\n        return;\n    }\n    var defaults = {};\n    /* istanbul ignore if */ if (!edition) {\n        throw new Error(\"Unknown edition for \" + this.fullName);\n    }\n    var protoFeatures = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(edition));\n    if (this._edition) {\n        // For a namespace marked with a specific edition, reset defaults.\n        /* istanbul ignore else */ if (edition === \"proto2\") {\n            defaults = Object.assign({}, proto2Defaults);\n        } else if (edition === \"proto3\") {\n            defaults = Object.assign({}, proto3Defaults);\n        } else if (edition === \"2023\") {\n            defaults = Object.assign({}, editions2023Defaults);\n        } else {\n            throw new Error(\"Unknown edition: \" + edition);\n        }\n        this._features = Object.assign(defaults, protoFeatures || {});\n        this._featuresResolved = true;\n        return;\n    }\n    // fields in Oneofs aren't actually children of them, so we have to\n    // special-case it\n    /* istanbul ignore else */ if (this.partOf instanceof OneOf) {\n        var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);\n        this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});\n    } else if (this.declaringField) {\n    // Skip feature resolution of sister fields.\n    } else if (this.parent) {\n        var parentFeaturesCopy = Object.assign({}, this.parent._features);\n        this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});\n    } else {\n        throw new Error(\"Unable to find a parent for \" + this.fullName);\n    }\n    if (this.extensionField) {\n        // Sister fields should have the same features as their extensions.\n        this.extensionField._features = this._features;\n    }\n    this._featuresResolved = true;\n};\n/**\n * Infers features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */ ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {\n    return {};\n};\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */ ReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options) return this.options[name];\n    return undefined;\n};\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!this.options) this.options = {};\n    if (/^features\\./.test(name)) {\n        util.setProperty(this.options, name, value, ifNotSet);\n    } else if (!ifNotSet || this.options[name] === undefined) {\n        if (this.getOption(name) !== value) this.resolved = false;\n        this.options[name] = value;\n    }\n    return this;\n};\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function(opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            // (If it's a feature, will just write over)\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set its property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options) for(var keys = Object.keys(options), i = 0; i < keys.length; ++i)this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */ ReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className, fullName = this.fullName;\n    if (fullName.length) return className + \" \" + fullName;\n    return className;\n};\n/**\n * Converts the edition this object is pinned to for JSON format.\n * @returns {string|undefined} The edition string for JSON representation\n */ ReflectionObject.prototype._editionToJSON = function _editionToJSON() {\n    if (!this._edition || this._edition === \"proto3\") {\n        // Avoid emitting proto3 since we need to default to it for backwards\n        // compatibility anyway.\n        return undefined;\n    }\n    return this._edition;\n};\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCQSxpQkFBaUJDLFNBQVMsR0FBRztBQUU3QixNQUFNQyxRQUFRQyxtQkFBT0EsQ0FBQyw4REFBUztBQUMvQixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQixJQUFJRSxNQUFNLFNBQVM7QUFFbkIsc0NBQXNDLEdBQ3RDLHFDQUFxQztBQUNyQyxJQUFJQyx1QkFBdUI7SUFBQ0MsV0FBVztJQUFRQyxnQkFBZ0I7SUFBWUMsYUFBYTtJQUFTQyxrQkFBa0I7SUFBbUJDLHlCQUF5QjtJQUFVQyxpQkFBaUI7QUFBUTtBQUNsTSxJQUFJQyxpQkFBaUI7SUFBQ04sV0FBVztJQUFVQyxnQkFBZ0I7SUFBWUMsYUFBYTtJQUFzQkMsa0JBQWtCO0lBQW1CQyx5QkFBeUI7SUFBWUMsaUJBQWlCO0FBQU07QUFDM00sSUFBSUUsaUJBQWlCO0lBQUNQLFdBQVc7SUFBUUMsZ0JBQWdCO0lBQVlDLGFBQWE7SUFBU0Msa0JBQWtCO0lBQW1CQyx5QkFBeUI7SUFBVUMsaUJBQWlCO0FBQVE7QUFFNUw7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNaLGlCQUFpQmUsSUFBSSxFQUFFQyxPQUFPO0lBRW5DLElBQUksQ0FBQ1osS0FBS2EsUUFBUSxDQUFDRixPQUNmLE1BQU1HLFVBQVU7SUFFcEIsSUFBSUYsV0FBVyxDQUFDWixLQUFLZSxRQUFRLENBQUNILFVBQzFCLE1BQU1FLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixPQUFPLEdBQUdBLFNBQVMsU0FBUztJQUVqQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLGFBQWEsR0FBRztJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNMLElBQUksR0FBR0E7SUFFWjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDTSxRQUFRLEdBQUc7SUFFaEI7Ozs7O0tBS0MsR0FDRCxJ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Ozs7Q0FLQyxHQUNEM0UsaUJBQWlCK0IsU0FBUyxDQUFDNkMsVUFBVSxHQUFHLFNBQVNBLFdBQVc1RCxPQUFPLEVBQUVnRCxRQUFRO0lBQ3pFLElBQUloRCxTQUNBLElBQUssSUFBSTZELE9BQU9oRCxPQUFPZ0QsSUFBSSxDQUFDN0QsVUFBVThELElBQUksR0FBR0EsSUFBSUQsS0FBS0UsTUFBTSxFQUFFLEVBQUVELEVBQzVELElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ2UsSUFBSSxDQUFDQyxFQUFFLEVBQUU5RCxPQUFPLENBQUM2RCxJQUFJLENBQUNDLEVBQUUsQ0FBQyxFQUFFZDtJQUNsRCxPQUFPLElBQUk7QUFDZjtBQUVBOzs7Q0FHQyxHQUNEaEUsaUJBQWlCK0IsU0FBUyxDQUFDaUQsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLElBQUkvRSxZQUFZLElBQUksQ0FBQ2dGLFdBQVcsQ0FBQ2hGLFNBQVMsRUFDdENrQyxXQUFZLElBQUksQ0FBQ0EsUUFBUTtJQUM3QixJQUFJQSxTQUFTNEMsTUFBTSxFQUNmLE9BQU85RSxZQUFZLE1BQU1rQztJQUM3QixPQUFPbEM7QUFDWDtBQUVBOzs7Q0FHQyxHQUNERCxpQkFBaUIrQixTQUFTLENBQUNtRCxjQUFjLEdBQUcsU0FBU0E7SUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQzdELFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsS0FBSyxVQUFVO1FBQzlDLHFFQUFxRTtRQUNyRSx3QkFBd0I7UUFDeEIsT0FBT3dDO0lBQ1g7SUFDQSxPQUFPLElBQUksQ0FBQ3hDLFFBQVE7QUFDeEI7QUFFQSxzREFBc0Q7QUFDdERyQixpQkFBaUJtRixVQUFVLEdBQUcsU0FBU0MsS0FBSztJQUN4Qy9FLE9BQU8rRTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29iamVjdC5qcz8xMzM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0aW9uT2JqZWN0O1xuXG5SZWZsZWN0aW9uT2JqZWN0LmNsYXNzTmFtZSA9IFwiUmVmbGVjdGlvbk9iamVjdFwiO1xuXG5jb25zdCBPbmVPZiA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgUm9vdDsgLy8gY3ljbGljXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXdhcm5pbmctY29tbWVudHMgKi9cbi8vIFRPRE86IFJlcGxhY2Ugd2l0aCBlbWJlZGRlZCBwcm90by5cbnZhciBlZGl0aW9uczIwMjNEZWZhdWx0cyA9IHtlbnVtX3R5cGU6IFwiT1BFTlwiLCBmaWVsZF9wcmVzZW5jZTogXCJFWFBMSUNJVFwiLCBqc29uX2Zvcm1hdDogXCJBTExPV1wiLCBtZXNzYWdlX2VuY29kaW5nOiBcIkxFTkdUSF9QUkVGSVhFRFwiLCByZXBlYXRlZF9maWVsZF9lbmNvZGluZzogXCJQQUNLRURcIiwgdXRmOF92YWxpZGF0aW9uOiBcIlZFUklGWVwifTtcbnZhciBwcm90bzJEZWZhdWx0cyA9IHtlbnVtX3R5cGU6IFwiQ0xPU0VEXCIsIGZpZWxkX3ByZXNlbmNlOiBcIkVYUExJQ0lUXCIsIGpzb25fZm9ybWF0OiBcIkxFR0FDWV9CRVNUX0VGRk9SVFwiLCBtZXNzYWdlX2VuY29kaW5nOiBcIkxFTkdUSF9QUkVGSVhFRFwiLCByZXBlYXRlZF9maWVsZF9lbmNvZGluZzogXCJFWFBBTkRFRFwiLCB1dGY4X3ZhbGlkYXRpb246IFwiTk9ORVwifTtcbnZhciBwcm90bzNEZWZhdWx0cyA9IHtlbnVtX3R5cGU6IFwiT1BFTlwiLCBmaWVsZF9wcmVzZW5jZTogXCJJTVBMSUNJVFwiLCBqc29uX2Zvcm1hdDogXCJBTExPV1wiLCBtZXNzYWdlX2VuY29kaW5nOiBcIkxFTkdUSF9QUkVGSVhFRFwiLCByZXBlYXRlZF9maWVsZF9lbmNvZGluZzogXCJQQUNLRURcIiwgdXRmOF92YWxpZGF0aW9uOiBcIlZFUklGWVwifTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3Rpb24gb2JqZWN0IGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQGFic3RyYWN0XG4gKi9cbmZ1bmN0aW9uIFJlZmxlY3Rpb25PYmplY3QobmFtZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAob3B0aW9ucyAmJiAhdXRpbC5pc09iamVjdChvcHRpb25zKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFBhcnNlZCBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsKj4+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRpb24gc3BlY2lmaWVkIGZvciB0aGlzIG9iamVjdC4gIE9ubHkgcmVsZXZhbnQgZm9yIHRvcC1sZXZlbCBvYmplY3RzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lZGl0aW9uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGVkaXRpb24gdG8gdXNlIGZvciB0aGlzIG9iamVjdCBpZiBub25lIGlzIHNwZWNpZmllZC4gIEZvciBsZWdhY3kgcmVhc29ucyxcbiAgICAgKiB0aGlzIGlzIHByb3RvMiBleGNlcHQgaW4gdGhlIEpTT04gcGFyc2luZyBjYXNlIHdoZXJlIGl0IHdhcyBwcm90bzMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RlZmF1bHRFZGl0aW9uID0gXCJwcm90bzJcIjtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIEZlYXR1cmVzLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mZWF0dXJlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgZmVhdHVyZXMgaGF2ZSBiZWVuIHJlc29sdmVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmVhdHVyZXNSZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUGFyZW50IG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7TmFtZXNwYWNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbHJlYWR5IHJlc29sdmVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IHRleHQsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nIGZpbGUgbmFtZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxuICAgICAqIEBuYW1lIFJlZmxlY3Rpb25PYmplY3Qjcm9vdFxuICAgICAqIEB0eXBlIHtSb290fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHJvb3Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwdHIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKHB0ci5wYXJlbnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVsbCBuYW1lIGluY2x1ZGluZyBsZWFkaW5nIGRvdC5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I2Z1bGxOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmdWxsTmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBbIHRoaXMubmFtZSBdLFxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHB0cikge1xuICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdChwdHIubmFtZSk7XG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyByZWZsZWN0aW9uIG9iamVjdCB0byBpdHMgZGVzY3JpcHRvciByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzY3JpcHRvclxuICogQGFic3RyYWN0XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB0aHJvdyBFcnJvcigpOyAvLyBub3QgaW1wbGVtZW50ZWQsIHNob3VsZG4ndCBoYXBwZW5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgYWRkZWQgdG9cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50ICE9PSBwYXJlbnQpXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZUFkZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IHJlbW92ZWQgZnJvbVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICB2YXIgcm9vdCA9IHBhcmVudC5yb290O1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgcm9vdC5faGFuZGxlUmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgb2JqZWN0cyB0eXBlIHJlZmVyZW5jZXMuXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHRydWU7IC8vIG9ubHkgaWYgcGFydCBvZiBhIHJvb3RcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBvYmplY3RzIGVkaXRpb25zIGZlYXR1cmVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGVkaXRpb24gVGhlIGVkaXRpb24gd2UncmUgY3VycmVudGx5IHJlc29sdmluZyBmb3IuXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUZlYXR1cmVzKHRoaXMuX2VkaXRpb24gfHwgZWRpdGlvbik7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIGNoaWxkIGZlYXR1cmVzIGZyb20gcGFyZW50IGZlYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gZWRpdGlvbiBUaGUgZWRpdGlvbiB3ZSdyZSBjdXJyZW50bHkgcmVzb2x2aW5nIGZvci5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXMgPSBmdW5jdGlvbiBfcmVzb2x2ZUZlYXR1cmVzKGVkaXRpb24pIHtcbiAgICBpZiAodGhpcy5fZmVhdHVyZXNSZXNvbHZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRzID0ge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVkaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlZGl0aW9uIGZvciBcIiArIHRoaXMuZnVsbE5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwcm90b0ZlYXR1cmVzID0gT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCAgdGhpcy5vcHRpb25zLmZlYXR1cmVzKSA6IHt9LFxuICAgICAgICB0aGlzLl9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMoZWRpdGlvbikpO1xuXG4gICAgaWYgKHRoaXMuX2VkaXRpb24pIHtcbiAgICAgICAgLy8gRm9yIGEgbmFtZXNwYWNlIG1hcmtlZCB3aXRoIGEgc3BlY2lmaWMgZWRpdGlvbiwgcmVzZXQgZGVmYXVsdHMuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvMlwiKSB7XG4gICAgICAgICAgICBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvMkRlZmF1bHRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0aW9uID09PSBcInByb3RvM1wiKSB7XG4gICAgICAgICAgICBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvM0RlZmF1bHRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0aW9uID09PSBcIjIwMjNcIikge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKHt9LCBlZGl0aW9uczIwMjNEZWZhdWx0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVkaXRpb246IFwiICsgZWRpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBwcm90b0ZlYXR1cmVzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fZmVhdHVyZXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaWVsZHMgaW4gT25lb2ZzIGFyZW4ndCBhY3R1YWxseSBjaGlsZHJlbiBvZiB0aGVtLCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gc3BlY2lhbC1jYXNlIGl0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5wYXJ0T2YgaW5zdGFuY2VvZiBPbmVPZikge1xuICAgICAgICB2YXIgbGV4aWNhbFBhcmVudEZlYXR1cmVzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFydE9mLl9mZWF0dXJlcyk7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gT2JqZWN0LmFzc2lnbihsZXhpY2FsUGFyZW50RmVhdHVyZXNDb3B5LCBwcm90b0ZlYXR1cmVzIHx8IHt9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVjbGFyaW5nRmllbGQpIHtcbiAgICAgICAgLy8gU2tpcCBmZWF0dXJlIHJlc29sdXRpb24gb2Ygc2lzdGVyIGZpZWxkcy5cbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRGZWF0dXJlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmVudC5fZmVhdHVyZXMpO1xuICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IE9iamVjdC5hc3NpZ24ocGFyZW50RmVhdHVyZXNDb3B5LCBwcm90b0ZlYXR1cmVzIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhIHBhcmVudCBmb3IgXCIgKyB0aGlzLmZ1bGxOYW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uRmllbGQpIHtcbiAgICAgICAgLy8gU2lzdGVyIGZpZWxkcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBmZWF0dXJlcyBhcyB0aGVpciBleHRlbnNpb25zLlxuICAgICAgICB0aGlzLmV4dGVuc2lvbkZpZWxkLl9mZWF0dXJlcyA9IHRoaXMuX2ZlYXR1cmVzO1xuICAgIH1cbiAgICB0aGlzLl9mZWF0dXJlc1Jlc29sdmVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogSW5mZXJzIGZlYXR1cmVzIGZyb20gbGVnYWN5IHN5bnRheCB0aGF0IG1heSBoYXZlIGJlZW4gc3BlY2lmaWVkIGRpZmZlcmVudGx5LlxuICogaW4gb2xkZXIgZWRpdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGVkaXRpb24gVGhlIGVkaXRpb24gdGhpcyBwcm90byBpcyBvbiwgb3IgdW5kZWZpbmVkIGlmIHByZS1lZGl0aW9uc1xuICogQHJldHVybnMge29iamVjdH0gVGhlIGZlYXR1cmUgdmFsdWVzIHRvIG92ZXJyaWRlXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLl9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMgPSBmdW5jdGlvbiBfaW5mZXJMZWdhY3lQcm90b0ZlYXR1cmVzKC8qZWRpdGlvbiovKSB7XG4gICAgcmV0dXJuIHt9O1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG9wdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXG4gKiBAcmV0dXJucyB7Kn0gT3B0aW9uIHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBzZXRcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBbaWZOb3RTZXRdIFNldHMgdGhlIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zKVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICBpZiAoL15mZWF0dXJlc1xcLi8udGVzdChuYW1lKSkge1xuICAgICAgICB1dGlsLnNldFByb3BlcnR5KHRoaXMub3B0aW9ucywgbmFtZSwgdmFsdWUsIGlmTm90U2V0KTtcbiAgICB9IGVsc2UgaWYgKCFpZk5vdFNldCB8fCB0aGlzLm9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24obmFtZSkgIT09IHZhbHVlKSB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcGFyc2VkIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHBhcnNlZCBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBkb3QgJy4nIGRlbGltaXRlZCBmdWxsIHBhdGggb2YgcHJvcGVydHkgd2l0aGluIHRoZSBvcHRpb24gdG8gc2V0LiBpZiB1bmRlZmluZWRcXGVtcHR5LCB3aWxsIGFkZCBhIG5ldyBvcHRpb24gd2l0aCB0aGF0IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldFBhcnNlZE9wdGlvbiA9IGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICBpZiAoIXRoaXMucGFyc2VkT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZE9wdGlvbnMgPSB0aGlzLnBhcnNlZE9wdGlvbnM7XG4gICAgaWYgKHByb3BOYW1lKSB7XG4gICAgICAgIC8vIElmIHNldHRpbmcgYSBzdWIgcHJvcGVydHkgb2YgYW4gb3B0aW9uIHRoZW4gdHJ5IHRvIG1lcmdlIGl0XG4gICAgICAgIC8vIHdpdGggYW4gZXhpc3Rpbmcgb3B0aW9uXG4gICAgICAgIHZhciBvcHQgPSBwYXJzZWRPcHRpb25zLmZpbmQoZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYW4gZXhpc3Rpbmcgb3B0aW9uIC0ganVzdCBtZXJnZSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIC8vIChJZiBpdCdzIGEgZmVhdHVyZSwgd2lsbCBqdXN0IHdyaXRlIG92ZXIpXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB1dGlsLnNldFByb3BlcnR5KG5ld1ZhbHVlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgb3B0aW9uLCBzZXQgaXRzIHByb3BlcnR5IGFuZCBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIG9wdCA9IHt9O1xuICAgICAgICAgICAgb3B0W25hbWVdID0gdXRpbC5zZXRQcm9wZXJ0eSh7fSwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChvcHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBhIG5ldyBvcHRpb24gd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGl0c2VsZlxuICAgICAgICB2YXIgbmV3T3B0ID0ge307XG4gICAgICAgIG5ld09wdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gobmV3T3B0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBtdWx0aXBsZSBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb3B0aW9ucyBPcHRpb25zIHRvIHNldFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXRdIFNldHMgYW4gb3B0aW9uIG9ubHkgaWYgaXQgaXNuJ3QgY3VycmVudGx5IHNldFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBpZk5vdFNldCkge1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uKGtleXNbaV0sIG9wdGlvbnNba2V5c1tpXV0sIGlmTm90U2V0KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBpbnN0YW5jZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogQHJldHVybnMge3N0cmluZ30gQ2xhc3MgbmFtZVssIHNwYWNlLCBmdWxsIG5hbWVdXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lLFxuICAgICAgICBmdWxsTmFtZSAgPSB0aGlzLmZ1bGxOYW1lO1xuICAgIGlmIChmdWxsTmFtZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBcIiArIGZ1bGxOYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBlZGl0aW9uIHRoaXMgb2JqZWN0IGlzIHBpbm5lZCB0byBmb3IgSlNPTiBmb3JtYXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGVkaXRpb24gc3RyaW5nIGZvciBKU09OIHJlcHJlc2VudGF0aW9uXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLl9lZGl0aW9uVG9KU09OID0gZnVuY3Rpb24gX2VkaXRpb25Ub0pTT04oKSB7XG4gICAgaWYgKCF0aGlzLl9lZGl0aW9uIHx8IHRoaXMuX2VkaXRpb24gPT09IFwicHJvdG8zXCIpIHtcbiAgICAgICAgLy8gQXZvaWQgZW1pdHRpbmcgcHJvdG8zIHNpbmNlIHdlIG5lZWQgdG8gZGVmYXVsdCB0byBpdCBmb3IgYmFja3dhcmRzXG4gICAgICAgIC8vIGNvbXBhdGliaWxpdHkgYW55d2F5LlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWRpdGlvbjtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlID0gZnVuY3Rpb24oUm9vdF8pIHtcbiAgICBSb290ID0gUm9vdF87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWZsZWN0aW9uT2JqZWN0IiwiY2xhc3NOYW1lIiwiT25lT2YiLCJyZXF1aXJlIiwidXRpbCIsIlJvb3QiLCJlZGl0aW9uczIwMjNEZWZhdWx0cyIsImVudW1fdHlwZSIsImZpZWxkX3ByZXNlbmNlIiwianNvbl9mb3JtYXQiLCJtZXNzYWdlX2VuY29kaW5nIiwicmVwZWF0ZWRfZmllbGRfZW5jb2RpbmciLCJ1dGY4X3ZhbGlkYXRpb24iLCJwcm90bzJEZWZhdWx0cyIsInByb3RvM0RlZmF1bHRzIiwibmFtZSIsIm9wdGlvbnMiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsImlzT2JqZWN0IiwicGFyc2VkT3B0aW9ucyIsIl9lZGl0aW9uIiwiX2RlZmF1bHRFZGl0aW9uIiwiX2ZlYXR1cmVzIiwiX2ZlYXR1cmVzUmVzb2x2ZWQiLCJwYXJlbnQiLCJyZXNvbHZlZCIsImNvbW1lbnQiLCJmaWxlbmFtZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJyb290IiwiZ2V0IiwicHRyIiwiZnVsbE5hbWUiLCJwYXRoIiwidW5zaGlmdCIsImpvaW4iLCJ0b0pTT04iLCJFcnJvciIsIm9uQWRkIiwicmVtb3ZlIiwiX2hhbmRsZUFkZCIsIm9uUmVtb3ZlIiwiX2hhbmRsZVJlbW92ZSIsInJlc29sdmUiLCJfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlIiwiZWRpdGlvbiIsIl9yZXNvbHZlRmVhdHVyZXMiLCJkZWZhdWx0cyIsInByb3RvRmVhdHVyZXMiLCJhc3NpZ24iLCJmZWF0dXJlcyIsIl9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMiLCJwYXJ0T2YiLCJsZXhpY2FsUGFyZW50RmVhdHVyZXNDb3B5IiwiZGVjbGFyaW5nRmllbGQiLCJwYXJlbnRGZWF0dXJlc0NvcHkiLCJleHRlbnNpb25GaWVsZCIsImdldE9wdGlvbiIsInVuZGVmaW5lZCIsInNldE9wdGlvbiIsInZhbHVlIiwiaWZOb3RTZXQiLCJ0ZXN0Iiwic2V0UHJvcGVydHkiLCJzZXRQYXJzZWRPcHRpb24iLCJwcm9wTmFtZSIsIm9wdCIsImZpbmQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuZXdWYWx1ZSIsInB1c2giLCJuZXdPcHQiLCJzZXRPcHRpb25zIiwia2V5cyIsImkiLCJsZW5ndGgiLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwiX2VkaXRpb25Ub0pTT04iLCJfY29uZmlndXJlIiwiUm9vdF8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/object.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/oneof.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/oneof.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = OneOf;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    /* istanbul ignore if */ if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError(\"fieldNames must be an Array\");\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */ this.oneof = fieldNames || []; // toJSON, marker\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */ this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */ /**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */ OneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */ OneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"oneof\",\n        this.oneof,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */ function addFieldsToParent(oneof) {\n    if (oneof.parent) {\n        for(var i = 0; i < oneof.fieldsArray.length; ++i)if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);\n    }\n}\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */ OneOf.prototype.add = function add(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    if (field.parent && field.parent !== this.parent) field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */ OneOf.prototype.remove = function remove(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    var index = this.fieldsArray.indexOf(field);\n    /* istanbul ignore if */ if (index < 0) throw Error(field + \" is not a member of \" + this);\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n    /* istanbul ignore else */ if (index > -1) this.oneof.splice(index, 1);\n    field.partOf = null;\n    return this;\n};\n/**\n * @override\n */ OneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for(var i = 0; i < this.oneof.length; ++i){\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n/**\n * @override\n */ OneOf.prototype.onRemove = function onRemove(parent) {\n    for(var i = 0, field; i < this.fieldsArray.length; ++i)if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n/**\n * Determines whether this field corresponds to a synthetic oneof created for\n * a proto3 optional field.  No behavioral logic should depend on this, but it\n * can be relevant for reflection.\n * @name OneOf#isProto3Optional\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(OneOf.prototype, \"isProto3Optional\", {\n    get: function() {\n        if (this.fieldsArray == null || this.fieldsArray.length !== 1) {\n            return false;\n        }\n        var field = this.fieldsArray[0];\n        return field.options != null && field.options[\"proto3_optional\"] === true;\n    }\n});\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */ /**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */ OneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length), index = 0;\n    while(index < arguments.length)fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsZ0VBQVU7QUFDeEMsRUFBQ0YsTUFBTUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLEtBQUksRUFBR08sU0FBUyxHQUFHO0FBRWhHLElBQUlDLFFBQVFOLG1CQUFPQSxDQUFDLDhEQUFTLEdBQ3pCTyxPQUFRUCxtQkFBT0EsQ0FBQyw0REFBUTtBQUU1Qjs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRixNQUFNVSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQzdDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixhQUFhO1FBQzVCQyxVQUFVRDtRQUNWQSxhQUFhSztJQUNqQjtJQUNBZixpQkFBaUJnQixJQUFJLENBQUMsSUFBSSxFQUFFUCxNQUFNRTtJQUVsQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFFRCxDQUFBQSxlQUFlSyxhQUFhRixNQUFNQyxPQUFPLENBQUNKLFdBQVUsR0FDdEQsTUFBTU8sVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLEtBQUssR0FBR1IsY0FBYyxFQUFFLEVBQUUsaUJBQWlCO0lBRWhEOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNTLFdBQVcsR0FBRyxFQUFFLEVBQUUsc0VBQXNFO0lBRTdGOzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsT0FBTyxHQUFHQTtBQUNuQjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RiLE1BQU1xQixRQUFRLEdBQUcsU0FBU0EsU0FBU1gsSUFBSSxFQUFFWSxJQUFJO0lBQ3pDLE9BQU8sSUFBSXRCLE1BQU1VLE1BQU1ZLEtBQUtILEtBQUssRUFBRUcsS0FBS1YsT0FBTyxF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QixHQUFHLENBQUMsSUFBSWhDLE1BQU1rRCxXQUFXdkM7UUFDOUJQLE9BQU95QyxjQUFjLENBQUMxQyxXQUFXK0MsV0FBVztZQUN4Q1AsS0FBS2xDLEtBQUsyQyxXQUFXLENBQUN6QztZQUN0QjBDLEtBQUs1QyxLQUFLNkMsV0FBVyxDQUFDM0M7UUFDMUI7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzP2JkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE9uZU9mO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChPbmVPZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBPbmVPZikuY2xhc3NOYW1lID0gXCJPbmVPZlwiO1xuXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBvbmVvZiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG9uZW9mLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ1tdfE9iamVjdC48c3RyaW5nLCo+fSBbZmllbGROYW1lc10gRmllbGQgbmFtZXNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gT25lT2YobmFtZSwgZmllbGROYW1lcywgb3B0aW9ucywgY29tbWVudCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkge1xuICAgICAgICBvcHRpb25zID0gZmllbGROYW1lcztcbiAgICAgICAgZmllbGROYW1lcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGROYW1lcyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoZmllbGROYW1lcykpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZE5hbWVzIG11c3QgYmUgYW4gQXJyYXlcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBuYW1lcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLm9uZW9mID0gZmllbGROYW1lcyB8fCBbXTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5maWVsZHNBcnJheSA9IFtdOyAvLyBkZWNsYXJlZCByZWFkb25seSBmb3IgY29uZm9ybWFuY2UsIHBvc3NpYmx5IG5vdCB5ZXQgYWRkZWQgdG8gcGFyZW50XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIE9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElPbmVPZlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gb25lb2YgT25lb2YgZmllbGQgbmFtZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBPbmVvZiBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgb25lb2YgZnJvbSBhIG9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge0lPbmVPZn0ganNvbiBPbmVvZiBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7T25lT2Z9IENyZWF0ZWQgb25lb2ZcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk9uZU9mLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgT25lT2YobmFtZSwganNvbi5vbmVvZiwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG9uZW9mIHRvIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lPbmVPZn0gT25lb2YgZGVzY3JpcHRvclxuICovXG5PbmVPZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJvbmVvZlwiICAgLCB0aGlzLm9uZW9mLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBmaWVsZHMgb2YgdGhlIHNwZWNpZmllZCBvbmVvZiB0byB0aGUgcGFyZW50IGlmIG5vdCBhbHJlYWR5IGRvbmUgc28uXG4gKiBAcGFyYW0ge09uZU9mfSBvbmVvZiBUaGUgb25lb2ZcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gYWRkRmllbGRzVG9QYXJlbnQob25lb2YpIHtcbiAgICBpZiAob25lb2YucGFyZW50KVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uZW9mLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKCFvbmVvZi5maWVsZHNBcnJheVtpXS5wYXJlbnQpXG4gICAgICAgICAgICAgICAgb25lb2YucGFyZW50LmFkZChvbmVvZi5maWVsZHNBcnJheVtpXSk7XG59XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIHRvIHRoaXMgb25lb2YgYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnQsIGlmIGFueS5cbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIGFkZFxuICogQHJldHVybnMge09uZU9mfSBgdGhpc2BcbiAqL1xuT25lT2YucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChmaWVsZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkIG11c3QgYmUgYSBGaWVsZFwiKTtcblxuICAgIGlmIChmaWVsZC5wYXJlbnQgJiYgZmllbGQucGFyZW50ICE9PSB0aGlzLnBhcmVudClcbiAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgdGhpcy5vbmVvZi5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIHRoaXMuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XG4gICAgZmllbGQucGFydE9mID0gdGhpczsgLy8gZmllbGQucGFyZW50IHJlbWFpbnMgbnVsbFxuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGlzIG9uZW9mIGFuZCBwdXRzIGl0IGJhY2sgdG8gdGhlIG9uZW9mJ3MgcGFyZW50LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgIHRocm93IEVycm9yKGZpZWxkICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICB0aGlzLmZpZWxkc0FycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSB0aGlzLm9uZW9mLmluZGV4T2YoZmllbGQubmFtZSk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbmRleCA+IC0xKSAvLyB0aGVvcmV0aWNhbFxuICAgICAgICB0aGlzLm9uZW9mLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBmaWVsZC5wYXJ0T2YgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDb2xsZWN0IHByZXNlbnQgZmllbGRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9uZW9mLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHBhcmVudC5nZXQodGhpcy5vbmVvZltpXSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiAhZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICBmaWVsZC5wYXJ0T2YgPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgbm90IHlldCBwcmVzZW50IGZpZWxkc1xuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IHRoaXMuZmllbGRzQXJyYXlbaV0pLnBhcmVudClcbiAgICAgICAgICAgIGZpZWxkLnBhcmVudC5yZW1vdmUoZmllbGQpO1xuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgcGFyZW50KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgY29ycmVzcG9uZHMgdG8gYSBzeW50aGV0aWMgb25lb2YgY3JlYXRlZCBmb3JcbiAqIGEgcHJvdG8zIG9wdGlvbmFsIGZpZWxkLiAgTm8gYmVoYXZpb3JhbCBsb2dpYyBzaG91bGQgZGVwZW5kIG9uIHRoaXMsIGJ1dCBpdFxuICogY2FuIGJlIHJlbGV2YW50IGZvciByZWZsZWN0aW9uLlxuICogQG5hbWUgT25lT2YjaXNQcm90bzNPcHRpb25hbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9uZU9mLnByb3RvdHlwZSwgXCJpc1Byb3RvM09wdGlvbmFsXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5maWVsZHNBcnJheSA9PSBudWxsIHx8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc0FycmF5WzBdO1xuICAgICAgICByZXR1cm4gZmllbGQub3B0aW9ucyAhPSBudWxsICYmIGZpZWxkLm9wdGlvbnNbXCJwcm90bzNfb3B0aW9uYWxcIl0gPT09IHRydWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBPbmVPZi5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBPbmVPZkRlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lb2ZOYW1lIE9uZU9mIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBPbmVPZiBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgc3RyaW5nXG4gKi9cbk9uZU9mLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU9uZU9mKCkge1xuICAgIHZhciBmaWVsZE5hbWVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuICAgICAgICBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgZmllbGROYW1lc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uZU9mRGVjb3JhdG9yKHByb3RvdHlwZSwgb25lb2ZOYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE9uZU9mKG9uZW9mTmFtZSwgZmllbGROYW1lcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBvbmVvZk5hbWUsIHtcbiAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcihmaWVsZE5hbWVzKSxcbiAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcihmaWVsZE5hbWVzKVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiT25lT2YiLCJSZWZsZWN0aW9uT2JqZWN0IiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRmllbGQiLCJ1dGlsIiwibmFtZSIsImZpZWxkTmFtZXMiLCJvcHRpb25zIiwiY29tbWVudCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImNhbGwiLCJUeXBlRXJyb3IiLCJvbmVvZiIsImZpZWxkc0FycmF5IiwiZnJvbUpTT04iLCJqc29uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsImFkZEZpZWxkc1RvUGFyZW50IiwicGFyZW50IiwiaSIsImxlbmd0aCIsImFkZCIsImZpZWxkIiwicmVtb3ZlIiwicHVzaCIsInBhcnRPZiIsImluZGV4IiwiaW5kZXhPZiIsIkVycm9yIiwic3BsaWNlIiwib25BZGQiLCJzZWxmIiwiZ2V0Iiwib25SZW1vdmUiLCJkZWZpbmVQcm9wZXJ0eSIsImQiLCJkZWNvcmF0ZU9uZU9mIiwiYXJndW1lbnRzIiwib25lT2ZEZWNvcmF0b3IiLCJvbmVvZk5hbWUiLCJkZWNvcmF0ZVR5cGUiLCJvbmVPZkdldHRlciIsInNldCIsIm9uZU9mU2V0dGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/oneof.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/parse.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/parse.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n    keepCase: false\n};\nvar tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/../node_modules/protobufjs/src/tokenize.js\"), Root = __webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\"), Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\"), Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\"), ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {Root} root Populated root instance\n */ /**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */ /**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */ /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */ function parse(source, root, options) {\n    /* eslint-disable callback-return */ if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options) options = parse.defaults;\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;\n    var head = true, pkg, imports, weakImports, edition = \"proto2\";\n    var ptr = root;\n    var topLevelObjects = [];\n    var topLevelOptions = {};\n    var applyCase = options.keepCase ? function(name) {\n        return name;\n    } : util.camelCase;\n    function resolveFileFeatures() {\n        topLevelObjects.forEach((obj)=>{\n            obj._edition = edition;\n            Object.keys(topLevelOptions).forEach((opt)=>{\n                if (obj.getOption(opt) !== undefined) return;\n                obj.setOption(opt, topLevelOptions[opt], true);\n            });\n        });\n    }\n    /* istanbul ignore next */ function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch) parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n    function readString() {\n        var values = [], token;\n        do {\n            /* istanbul ignore if */ if ((token = next()) !== '\"' && token !== \"'\") throw illegal(token);\n            values.push(next());\n            skip(token);\n            token = peek();\n        }while (token === '\"' || token === \"'\");\n        return values.join(\"\");\n    }\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch(token){\n            case \"'\":\n            case '\"':\n                push(token);\n                return readString();\n            case \"true\":\n            case \"TRUE\":\n                return true;\n            case \"false\":\n            case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n            /* istanbul ignore else */ if (acceptTypeRef && typeRefRe.test(token)) return token;\n            /* istanbul ignore next */ throw illegal(token, \"value\");\n        }\n    }\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === '\"' || token === \"'\")) {\n                var str = readString();\n                target.push(str);\n                if (edition >= 2023) {\n                    throw illegal(str, \"id\");\n                }\n            } else {\n                try {\n                    target.push([\n                        start = parseId(next()),\n                        skip(\"to\", true) ? parseId(next()) : start\n                    ]);\n                } catch (err) {\n                    if (acceptStrings && typeRefRe.test(token) && edition >= 2023) {\n                        target.push(token);\n                    } else {\n                        throw err;\n                    }\n                }\n            }\n        }while (skip(\",\", true));\n        var dummy = {\n            options: undefined\n        };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined) this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseRange_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseRange_line() {\n            parseInlineOptions(dummy); // skip\n        });\n    }\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch(token){\n            case \"inf\":\n            case \"INF\":\n            case \"Inf\":\n                return sign * Infinity;\n            case \"nan\":\n            case \"NAN\":\n            case \"Nan\":\n            case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token)) return sign * parseInt(token, 10);\n        if (base16Re.test(token)) return sign * parseInt(token, 16);\n        if (base8Re.test(token)) return sign * parseInt(token, 8);\n        /* istanbul ignore else */ if (numberRe.test(token)) return sign * parseFloat(token);\n        /* istanbul ignore next */ throw illegal(token, \"number\", insideTryCatch);\n    }\n    function parseId(token, acceptNegative) {\n        switch(token){\n            case \"max\":\n            case \"MAX\":\n            case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n        /* istanbul ignore if */ if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n        if (base10NegRe.test(token)) return parseInt(token, 10);\n        if (base16NegRe.test(token)) return parseInt(token, 16);\n        /* istanbul ignore else */ if (base8NegRe.test(token)) return parseInt(token, 8);\n        /* istanbul ignore next */ throw illegal(token, \"id\");\n    }\n    function parsePackage() {\n        /* istanbul ignore if */ if (pkg !== undefined) throw illegal(\"package\");\n        pkg = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch(token){\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n            // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n    function parseSyntax() {\n        skip(\"=\");\n        edition = readString();\n        /* istanbul ignore if */ if (edition < 2023) throw illegal(edition, \"syntax\");\n        skip(\";\");\n    }\n    function parseEdition() {\n        skip(\"=\");\n        edition = readString();\n        const supportedEditions = [\n            \"2023\"\n        ];\n        /* istanbul ignore if */ if (!supportedEditions.includes(edition)) throw illegal(edition, \"edition\");\n        skip(\";\");\n    }\n    function parseCommon(parent, token) {\n        switch(token){\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n            case \"message\":\n                parseType(parent, token);\n                return true;\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n            case \"service\":\n                parseService(parent, token);\n                return true;\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if (typeof obj.comment !== \"string\") {\n                obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while((token = next()) !== \"}\")fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse) fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n    function parseType(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token)) return;\n            switch(token){\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n                case \"required\":\n                    if (edition !== \"proto2\") throw illegal(token);\n                /* eslint-disable no-fallthrough */ case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else if (edition !== \"proto2\") {\n                        throw illegal(token);\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                default:\n                    /* istanbul ignore if */ if (edition === \"proto2\" || !typeRefRe.test(token)) {\n                        throw illegal(token);\n                    }\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n        if (parent === ptr) {\n            topLevelObjects.push(type);\n        }\n    }\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while(type.endsWith(\".\") || peek().startsWith(\".\")){\n            type += next();\n        }\n        /* istanbul ignore if */ if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        name = applyCase(name);\n        skip(\"=\");\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n        if (parent === ptr) {\n            topLevelObjects.push(field);\n        }\n    }\n    function parseGroup(parent, rule) {\n        if (edition >= 2023) {\n            throw illegal(\"group\");\n        }\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName) name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"message\":\n                    parseType(type, token);\n                    break;\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                /* istanbul ignore next */ default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type).add(field);\n    }\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n        /* istanbul ignore if */ if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n        skip(\",\");\n        var valueType = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n        skip(\">\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n    function parseOneOf(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n    function parseEnum(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(enm, token);\n                    skip(\";\");\n                    break;\n                case \"reserved\":\n                    readRanges(enm.reserved || (enm.reserved = []), true);\n                    if (enm.reserved === undefined) enm.reserved = [];\n                    break;\n                default:\n                    parseEnumValue(enm, token);\n            }\n        });\n        parent.add(enm);\n        if (parent === ptr) {\n            topLevelObjects.push(enm);\n        }\n    }\n    function parseEnumValue(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token)) throw illegal(token, \"name\");\n        skip(\"=\");\n        var value = parseId(next(), true), dummy = {\n            options: undefined\n        };\n        dummy.getOption = function(name) {\n            return this.options[name];\n        };\n        dummy.setOption = function(name, value) {\n            ReflectionObject.prototype.setOption.call(dummy, name, value);\n        };\n        dummy.setParsedOption = function() {\n            return undefined;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.parsedOptions || dummy.options);\n    }\n    function parseOption(parent, token) {\n        var option;\n        var propName;\n        var isOption = true;\n        if (token === \"option\") {\n            token = next();\n        }\n        while(token !== \"=\"){\n            if (token === \"(\") {\n                var parensValue = next();\n                skip(\")\");\n                token = \"(\" + parensValue + \")\";\n            }\n            if (isOption) {\n                isOption = false;\n                if (token.includes(\".\") && !token.includes(\"(\")) {\n                    var tokens = token.split(\".\");\n                    option = tokens[0] + \".\";\n                    token = tokens[1];\n                    continue;\n                }\n                option = token;\n            } else {\n                propName = propName ? propName += token : token;\n            }\n            token = next();\n        }\n        var name = propName ? option.concat(propName) : option;\n        var optionValue = parseOptionValue(parent, name);\n        propName = propName && propName[0] === \".\" ? propName.slice(1) : propName;\n        option = option && option[option.length - 1] === \".\" ? option.slice(0, -1) : option;\n        setParsedOption(parent, option, optionValue, propName);\n    }\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n            while(!skip(\"}\", true)){\n                /* istanbul ignore if */ if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                    throw illegal(token, \"end of input\");\n                }\n                var value;\n                var propName = token;\n                skip(\":\", true);\n                if (peek() === \"{\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = parseOptionValue(parent, name + \".\" + token);\n                } else if (peek() === \"[\") {\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        }while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n                var prevValue = objectResult[propName];\n                if (prevValue) value = [].concat(prevValue).concat(value);\n                objectResult[propName] = value;\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n            return objectResult;\n        }\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n    // Does not enforce a delimiter to be universal\n    }\n    function setOption(parent, name, value) {\n        if (ptr === parent && /^features\\./.test(name)) {\n            topLevelOptions[name] = value;\n            return;\n        }\n        if (parent.setOption) parent.setOption(name, value);\n    }\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n    }\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            }while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n    function parseService(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token)) {\n                return;\n            }\n            /* istanbul ignore else */ if (token === \"rpc\") parseMethod(service, token);\n            else throw illegal(token);\n        });\n        parent.add(service);\n        if (parent === ptr) {\n            topLevelObjects.push(service);\n        }\n    }\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n        var type = token;\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token, requestType, requestStream, responseType, responseStream;\n        skip(\"(\");\n        if (skip(\"stream\", true)) requestStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        requestType = token;\n        skip(\")\");\n        skip(\"returns\");\n        skip(\"(\");\n        if (skip(\"stream\", true)) responseStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        responseType = token;\n        skip(\")\");\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else throw illegal(token);\n        });\n        parent.add(method);\n    }\n    function parseExtension(parent, token) {\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch(token){\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n                default:\n                    /* istanbul ignore if */ if (edition === \"proto2\" || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n    var token;\n    while((token = next()) !== null){\n        switch(token){\n            case \"package\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parsePackage();\n                break;\n            case \"import\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseImport();\n                break;\n            case \"syntax\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseSyntax();\n                break;\n            case \"edition\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseEdition();\n                break;\n            case \"option\":\n                parseOption(ptr, token);\n                skip(\";\", true);\n                break;\n            default:\n                /* istanbul ignore else */ if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n                /* istanbul ignore next */ throw illegal(token);\n        }\n    }\n    resolveFileFeatures();\n    parse.filename = null;\n    return {\n        \"package\": pkg,\n        \"imports\": imports,\n        weakImports: weakImports,\n        root: root\n    };\n} /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakJBLE1BQU1DLFFBQVEsR0FBRztBQUNqQkQsTUFBTUUsUUFBUSxHQUFHO0lBQUVDLFVBQVU7QUFBTTtBQUVuQyxJQUFJQyxXQUFZQyxtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ0MsT0FBWUQsbUJBQU9BLENBQUMsNERBQVEsR0FDNUJFLE9BQVlGLG1CQUFPQSxDQUFDLDREQUFRLEdBQzVCRyxRQUFZSCxtQkFBT0EsQ0FBQyw4REFBUyxHQUM3QkksV0FBWUosbUJBQU9BLENBQUMsb0VBQVksR0FDaENLLFFBQVlMLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzdCTSxPQUFZTixtQkFBT0EsQ0FBQyw0REFBUSxHQUM1Qk8sVUFBWVAsbUJBQU9BLENBQUMsa0VBQVcsR0FDL0JRLFNBQVlSLG1CQUFPQSxDQUFDLGdFQUFVLEdBQzlCUyxtQkFBbUJULG1CQUFPQSxDQUFDLGdFQUFVLEdBQ3JDVSxRQUFZVixtQkFBT0EsQ0FBQyw4REFBUyxHQUM3QlcsT0FBWVgsbUJBQU9BLENBQUMsNERBQVE7QUFFaEMsSUFBSVksV0FBYyxpQkFDZEMsY0FBYyxtQkFDZEMsV0FBYyxzQkFDZEMsY0FBYyx3QkFDZEMsVUFBYyxhQUNkQyxhQUFjLGVBQ2RDLFdBQWMscURBQ2RDLFNBQWMsNEJBQ2RDLFlBQWM7QUFFbEI7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVN6QixNQUFNMEIsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE9BQU87SUFDaEMsa0NBQWtDLEdBQ2xDLElBQUksQ0FBRUQsQ0FBQUEsZ0JBQWdCckIsSUFBRyxHQUFJO1FBQ3pCc0IsVUFBVUQ7UUFDVkEsT0FBTyxJQUFJckI7SUFDZjtJQUNBLElBQUksQ0FBQ3NCLFNBQ0RBLFVBQVU1QixNQUFNRSxRQUFRO0lBRTVCLElBQUkyQix3QkFBd0JELFFBQVFDLHFCQUFxQixJQUFJO0lBQzdELElBQUlDLEtBQUsxQixTQUFTc0IsUUFBUUUsUUFBUUcsb0JBQW9CLElBQUksUUFDdERDLE9BQU9GLEdBQUdFLElBQUksRUFDZEMsT0FBT0gsR0FBR0csSUFBSSxFQUNkQyxPQUFPSixHQUFHSSxJQUFJLEVBQ2RDLE9BQU9MLEdBQUdLLElBQUksRUFDZEMsT0FBT04sR0FBR00sSUFBSTtJQUVsQixJQUFJQyxPQUFPLE1BQ1BDLEtBQ0FDLFNBQ0FDLGFBQ0FDLFVBQVU7SUFFZCxJQUFJQyxNQUFNZjtJQUVWLElBQUlnQixrQkFBa0IsRUFBRTtJQUN4QixJQUFJQyxrQkFBa0IsQ0FBQztJQUV2QixJQUFJQyxZQUFZakIsUUFBUXpCLFFBQVEsR0FBRyxTQUFTMkMsSUFBSTtRQUFJLE9BQU9BO0lBQU0sSUFBSTlCLEtBQUsrQixTQUFTO0lBRW5GLFNBQVNDO1FBQ0xMLGdCQUFnQk0sT0FBTyxDQUFDQyxDQUFBQTtZQUNwQkEsSUFBSUMsUUFBUSxHQUFHVjtZQUNmVyxPQUFPQyxJQUFJLENBQUNULGlCQUFpQkssT0FBTyxDQUFDSyxDQUFBQTtnQkFDakMsSUFBSUosSUFBSUssU0FBUyxDQUFDRCxTQUFTRSxXQUFXO2dCQUN0Q04sSUFBSU8sU0FBUyxDQUFDSCxLQUFLVixlQUFlLENBQUNVLElBQUksRUFBRTtZQUM3QztRQUNKO0lBQ0o7SUFFQSx3QkFBd0IsR0FDeEIsU0FBU0ksUUFBUUMsS0FBSyxFQUFFYixJQUFJLEVBQUVjLGNBQWM7UUFDeEMsSUFBSTNELFdBQVdELE1BQU1DLFFBQVE7UUFDN0IsSUFBSSxDQUFDMkQsZ0JBQ0Q1RCxNQUFNQyxRQUFRLEdBQUc7UUFDckIsT0FBTzRELE1BQU0sYUFBY2YsQ0FBQUEsUUFBUSxPQUFNLElBQUssT0FBT2EsUUFBUSxRQUFTMUQsQ0FBQUEsV0FBV0EsV0FBVyxPQUFPLEVBQUMsSUFBSyxVQUFVNkIsR0FBR2dDLElBQUksR0FBRztJQUNqSTtJQUVBLFNBQVNDO1FBQ0wsSUFBSUMsU0FBUyxFQUFFLEVBQ1hMO1FBQ0osR0FBRztZQUNDLHNCQUFzQixHQUN0QixJQUFJLENBQUNBLFFBQVEzQixNQUFLLE1BQU8sT0FBUTJCLFVBQVUsS0FDdkMsTUFBTUQsUUFBUUM7WUFFbEJLLE9BQU8vQixJQUFJLENBQUNEO1lBQ1pHLEtBQUt3QjtZQUNMQSxRQUFRekI7UUFDWixRQUFTeUIsVUFBVSxPQUFRQSxVQUFVLEtBQUs7UUFDMUMsT0FBT0ssT0FBT0MsSUFBSSxDQUFDO0lBQ3ZCO0lBRUEsU0FBU0MsVUFBVUMsYUFBYTtRQUM1QixJQUFJUixRQUFRM0I7UUFDWixPQUFRMkI7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRDFCLEtBQUswQjtnQkFDTCxPQUFPSTtZQUNYLEtBQUs7WUFBUSxLQUFLO2dCQUNkLE9BQU87WUFDWCxLQUFLO1lBQVMsS0FBSztnQkFDZixPQUFPO1FBQ2Y7UUFDQSxJQUFJO1lBQ0EsT0FBT0ssWUFBWVQsT0FBTyxrQkFBa0IsR0FBRztRQUNuRCxFQUFFLE9BQU9VLEdBQUc7WUFDUix3QkFBd0IsR0FDeEIsSUFBSUYsaUJBQWlCMUMsVUFBVTZDLElBQUksQ0FBQ1gsUUFDaEMsT0FBT0E7WUFFWCx3QkFBd0IsR0FDeEIsTUFBTUQsUUFBUUMsT0FBTztRQUN6QjtJQUNKO0lBRUEsU0FBU1ksV0FBV0MsTUFBTSxFQUFFQyxhQUFhO1FBQ3JDLElBQUlkLE9BQU9lO1FBQ1gsR0FBRztZQUNDLElBQUlELGlCQUFrQixFQUFDZCxRQUFRekIsTUFBSyxNQUFPLE9BQVF5QixVQUFVLEdBQUUsR0FBSTtnQkFDL0QsSUFBSWdCLE1BQU1aO2dCQUNWUyxPQUFPdkMsSUFBSSxDQUFDMEM7Z0JBQ1osSUFBSWxDLFdBQVcsTUFBTTtvQkFDakIsTUFBTWlCLFFBQVFpQixLQUFLO2dCQUN2QjtZQUNKLE9BQU87Z0JBQ0gsSUFBSTtvQkFDQUgsT0FBT3ZDLElBQUksQ0FBQzt3QkFBRXlDLFFBQVFFLFFBQVE1Qzt3QkFBU0csS0FBSyxNQUFNLFFBQVF5QyxRQUFRNUMsVUFBVTBDO3FCQUFPO2dCQUN2RixFQUFFLE9BQU9HLEtBQUs7b0JBQ1YsSUFBSUosaUJBQWlCaEQsVUFBVTZDLElBQUksQ0FBQ1gsVUFBVWxCLFdBQVcsTUFBTTt3QkFDM0QrQixPQUFPdkMsSUFBSSxDQUFDMEI7b0JBQ2hCLE9BQU87d0JBQ0gsTUFBTWtCO29CQUNWO2dCQUNKO1lBQ0o7UUFDSixRQUFTMUMsS0FBSyxLQUFLLE9BQU87UUFDMUIsSUFBSTJDLFFBQVE7WUFBQ2xELFNBQVM0QjtRQUFTO1FBQy9Cc0IsTUFBTXJCLFNBQVMsR0FBRyxTQUFTWCxJQUFJLEVBQUVpQyxLQUFLO1lBQ3BDLElBQUksSUFBSSxDQUFDbkQsT0FBTyxLQUFLNEIsV0FBVyxJQUFJLENBQUM1QixPQUFPLEdBQUcsQ0FBQztZQUNoRCxJQUFJLENBQUNBLE9BQU8sQ0FBQ2tCLEtBQUssR0FBR2lDO1FBQ3ZCO1FBQ0FDLFFBQ0lGLE9BQ0EsU0FBU0csaUJBQWlCdEIsS0FBSztZQUM3Qix3QkFBd0IsR0FDeEIsSUFBSUEsVUFBVSxVQUFVO2dCQUN0QnVCLFlBQVlKLE9BQU9uQixRQUFTLE9BQU87Z0JBQ25DeEIsS0FBSztZQUNQLE9BQ0UsTUFBTXVCLFFBQVFDO1FBQ2xCLEdBQ0EsU0FBU3dCO1lBQ1BDLG1CQUFtQk4sUUFBUyxPQUFPO1FBQ3JDO0lBQ1I7SUFFQSxTQUFTVixZQUFZVCxLQUFLLEVBQUVDLGNBQWM7UUFDdEMsSUFBSXlCLE9BQU87UUFDWCxJQUFJMUIsTUFBTTJCLE1BQU0sQ0FBQyxPQUFPLEtBQUs7WUFDekJELE9BQU8sQ0FBQztZQUNSMUIsUUFBUUEsTUFBTTRCLFNBQVMsQ0FBQztRQUM1QjtRQUNBLE9BQVE1QjtZQUNKLEtBQUs7WUFBTyxLQUFLO1lBQU8sS0FBSztnQkFDekIsT0FBTzBCLE9BQU9HO1lBQ2xCLEtBQUs7WUFBTyxLQUFLO1lBQU8sS0FBSztZQUFPLEtBQUs7Z0JBQ3JDLE9BQU9DO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1FBQ2Y7UUFDQSxJQUFJeEUsU0FBU3FELElBQUksQ0FBQ1gsUUFDZCxPQUFPMEIsT0FBT0ssU0FBUy9CLE9BQU87UUFDbEMsSUFBSXhDLFNBQVNtRCxJQUFJLENBQUNYLFFBQ2QsT0FBTzBCLE9BQU9LLFNBQVMvQixPQUFPO1FBQ2xDLElBQUl0QyxRQUFRaUQsSUFBSSxDQUFDWCxRQUNiLE9BQU8wQixPQUFPSyxTQUFTL0IsT0FBTztRQUVsQyx3QkFBd0IsR0FDeEIsSUFBSXBDLFNBQVMrQyxJQUFJLENBQUNYLFFBQ2QsT0FBTzBCLE9BQU9NLFdBQVdoQztRQUU3Qix3QkFBd0IsR0FDeEIsTUFBTUQsUUFBUUMsT0FBTyxVQUFVQztJQUNuQztJQUVBLFNBQVNnQixRQUFRakIsS0FBSyxFQUFFaUMsY0FBYztRQUNsQyxPQUFRakM7WUFDSixLQUFLO1lBQU8sS0FBSztZQUFPLEtBQUs7Z0JBQ3pCLE9BQU87WUFDWCxLQUFLO2dCQUNELE9BQU87UUFDZjtRQUVBLHNCQUFzQixHQUN0QixJQUFJLENBQUNpQyxrQkFBa0JqQyxNQUFNMkIsTUFBTSxDQUFDLE9BQU8sS0FDdkMsTUFBTTVCLFFBQVFDLE9BQU87UUFFekIsSUFBSXpDLFlBQVlvRCxJQUFJLENBQUNYLFFBQ2pCLE9BQU8rQixTQUFTL0IsT0FBTztRQUMzQixJQUFJdkMsWUFBWWtELElBQUksQ0FBQ1gsUUFDakIsT0FBTytCLFNBQVMvQixPQUFPO1FBRTNCLHdCQUF3QixHQUN4QixJQUFJckMsV0FBV2dELElBQUksQ0FBQ1gsUUFDaEIsT0FBTytCLFNBQVMvQixPQUFPO1FBRTNCLHdCQUF3QixHQUN4QixNQUFNRCxRQUFRQyxPQUFPO0lBQ3pCO0lBRUEsU0FBU2tDO1FBQ0wsc0JBQXNCLEdBQ3RCLElBQUl2RCxRQUFRa0IsV0FDUixNQUFNRSxRQUFRO1FBRWxCcEIsTUFBTU47UUFFTixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDUCxVQUFVNkMsSUFBSSxDQUFDaEMsTUFDaEIsTUFBTW9CLFFBQVFwQixLQUFLO1FBRXZCSSxNQUFNQSxJQUFJb0QsTUFBTSxDQUFDeEQ7UUFFakJILEtBQUs7SUFDVDtJQUVBLFNBQVM0RDtRQUNMLElBQUlwQyxRQUFRekI7UUFDWixJQUFJOEQ7UUFDSixPQUFRckM7WUFDSixLQUFLO2dCQUNEcUMsZUFBZXhELGVBQWdCQSxDQUFBQSxjQUFjLEVBQUU7Z0JBQy9DUjtnQkFDQTtZQUNKLEtBQUs7Z0JBQ0RBO1lBQ0EsMENBQTBDO1lBQzlDO2dCQUNJZ0UsZUFBZXpELFdBQVlBLENBQUFBLFVBQVUsRUFBRTtnQkFDdkM7UUFDUjtRQUNBb0IsUUFBUUk7UUFDUjVCLEtBQUs7UUFDTDZELGFBQWEvRCxJQUFJLENBQUMwQjtJQUN0QjtJQUVBLFNBQVNzQztRQUNMOUQsS0FBSztRQUNMTSxVQUFVc0I7UUFFVixzQkFBc0IsR0FDdEIsSUFBSXRCLFVBQVUsTUFDVixNQUFNaUIsUUFBUWpCLFNBQVM7UUFFM0JOLEtBQUs7SUFDVDtJQUVBLFNBQVMrRDtRQUNML0QsS0FBSztRQUNMTSxVQUFVc0I7UUFDVixNQUFNb0Msb0JBQW9CO1lBQUM7U0FBTztRQUVsQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDQSxrQkFBa0JDLFFBQVEsQ0FBQzNELFVBQzVCLE1BQU1pQixRQUFRakIsU0FBUztRQUUzQk4sS0FBSztJQUNUO0lBR0EsU0FBU2tFLFlBQVlDLE1BQU0sRUFBRTNDLEtBQUs7UUFDOUIsT0FBUUE7WUFFSixLQUFLO2dCQUNEdUIsWUFBWW9CLFFBQVEzQztnQkFDcEJ4QixLQUFLO2dCQUNMLE9BQU87WUFFWCxLQUFLO2dCQUNEb0UsVUFBVUQsUUFBUTNDO2dCQUNsQixPQUFPO1lBRVgsS0FBSztnQkFDRDZDLFVBQVVGLFFBQVEzQztnQkFDbEIsT0FBTztZQUVYLEtBQUs7Z0JBQ0Q4QyxhQUFhSCxRQUFRM0M7Z0JBQ3JCLE9BQU87WUFFWCxLQUFLO2dCQUNEK0MsZUFBZUosUUFBUTNDO2dCQUN2QixPQUFPO1FBQ2Y7UUFDQSxPQUFPO0lBQ1g7SUFFQSxTQUFTcUIsUUFBUTlCLEdBQUcsRUFBRXlELElBQUksRUFBRUMsTUFBTTtRQUM5QixJQUFJQyxlQUFlL0UsR0FBR2dDLElBQUk7UUFDMUIsSUFBSVosS0FBSztZQUNMLElBQUcsT0FBT0EsSUFBSTRELE9BQU8sS0FBSyxVQUFVO2dCQUNsQzVELElBQUk0RCxPQUFPLEdBQUcxRSxRQUFRLHlCQUF5QjtZQUNqRDtZQUNBYyxJQUFJakQsUUFBUSxHQUFHRCxNQUFNQyxRQUFRO1FBQ2pDO1FBQ0EsSUFBSWtDLEtBQUssS0FBSyxPQUFPO1lBQ2pCLElBQUl3QjtZQUNKLE1BQU8sQ0FBQ0EsUUFBUTNCLE1BQUssTUFBTyxJQUN4QjJFLEtBQUtoRDtZQUNUeEIsS0FBSyxLQUFLO1FBQ2QsT0FBTztZQUNILElBQUl5RSxRQUNBQTtZQUNKekUsS0FBSztZQUNMLElBQUllLE9BQVEsUUFBT0EsSUFBSTRELE9BQU8sS0FBSyxZQUFZakYscUJBQW9CLEdBQy9EcUIsSUFBSTRELE9BQU8sR0FBRzFFLEtBQUt5RSxpQkFBaUIzRCxJQUFJNEQsT0FBTyxFQUFFLHdCQUF3QjtRQUNqRjtJQUNKO0lBRUEsU0FBU1AsVUFBVUQsTUFBTSxFQUFFM0MsS0FBSztRQUU1QixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDbkMsT0FBTzhDLElBQUksQ0FBQ1gsUUFBUTNCLFNBQ3JCLE1BQU0wQixRQUFRQyxPQUFPO1FBRXpCLElBQUlvRCxPQUFPLElBQUl4RyxLQUFLb0Q7UUFDcEJxQixRQUFRK0IsTUFBTSxTQUFTQyxnQkFBZ0JyRCxLQUFLO1lBQ3hDLElBQUkwQyxZQUFZVSxNQUFNcEQsUUFDbEI7WUFFSixPQUFRQTtnQkFFSixLQUFLO29CQUNEc0QsY0FBY0YsTUFBTXBEO29CQUNwQjtnQkFFSixLQUFLO29CQUNELElBQUlsQixZQUFZLFVBQ1osTUFBTWlCLFFBQVFDO2dCQUN0QixpQ0FBaUMsR0FDakMsS0FBSztvQkFDRHVELFdBQVdILE1BQU1wRDtvQkFDakI7Z0JBRUosS0FBSztvQkFDRCxzQkFBc0IsR0FDdEIsSUFBSWxCLFlBQVksVUFBVTt3QkFDdEJ5RSxXQUFXSCxNQUFNO29CQUNyQixPQUFPLElBQUl0RSxZQUFZLFVBQVU7d0JBQzdCLE1BQU1pQixRQUFRQztvQkFDbEIsT0FBTzt3QkFDSHVELFdBQVdILE1BQU07b0JBQ3JCO29CQUNBO2dCQUVKLEtBQUs7b0JBQ0RJLFdBQVdKLE1BQU1wRDtvQkFDakI7Z0JBRUosS0FBSztvQkFDRFksV0FBV3dDLEtBQUtLLFVBQVUsSUFBS0wsQ0FBQUEsS0FBS0ssVUFBVSxHQUFHLEVBQUU7b0JBQ25EO2dCQUVKLEtBQUs7b0JBQ0Q3QyxXQUFXd0MsS0FBS00sUUFBUSxJQUFLTixDQUFBQSxLQUFLTSxRQUFRLEdBQUcsRUFBRSxHQUFHO29CQUNsRDtnQkFFSjtvQkFDSSxzQkFBc0IsR0FDdEIsSUFBSTVFLFlBQVksWUFBWSxDQUFDaEIsVUFBVTZDLElBQUksQ0FBQ1gsUUFBUTt3QkFDaEQsTUFBTUQsUUFBUUM7b0JBQ2xCO29CQUVBMUIsS0FBSzBCO29CQUNMdUQsV0FBV0gsTUFBTTtvQkFDakI7WUFDUjtRQUNKO1FBQ0FULE9BQU9nQixHQUFHLENBQUNQO1FBQ1gsSUFBSVQsV0FBVzVELEtBQUs7WUFDaEJDLGdCQUFnQlYsSUFBSSxDQUFDOEU7UUFDekI7SUFDSjtJQUVBLFNBQVNHLFdBQVdaLE1BQU0sRUFBRWlCLElBQUksRUFBRUMsTUFBTTtRQUNwQyxJQUFJVCxPQUFPL0U7UUFDWCxJQUFJK0UsU0FBUyxTQUFTO1lBQ2xCVSxXQUFXbkIsUUFBUWlCO1lBQ25CO1FBQ0o7UUFDQSxnRUFBZ0U7UUFDaEUsaUdBQWlHO1FBQ2pHLHVHQUF1RztRQUN2RyxvR0FBb0c7UUFDcEcsb0dBQW9HO1FBQ3BHLDBFQUEwRTtRQUMxRSxtREFBbUQ7UUFDbkQsTUFBT1IsS0FBS1csUUFBUSxDQUFDLFFBQVF4RixPQUFPeUYsVUFBVSxDQUFDLEtBQU07WUFDakRaLFFBQVEvRTtRQUNaO1FBRUEsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ1AsVUFBVTZDLElBQUksQ0FBQ3lDLE9BQ2hCLE1BQU1yRCxRQUFRcUQsTUFBTTtRQUV4QixJQUFJakUsT0FBT2Q7UUFFWCxzQkFBc0IsR0FFdEIsSUFBSSxDQUFDUixPQUFPOEMsSUFBSSxDQUFDeEIsT0FDYixNQUFNWSxRQUFRWixNQUFNO1FBRXhCQSxPQUFPRCxVQUFVQztRQUNqQlgsS0FBSztRQUVMLElBQUl5RixRQUFRLElBQUlwSCxNQUFNc0MsTUFBTThCLFFBQVE1QyxTQUFTK0UsTUFBTVEsTUFBTUM7UUFFekR4QyxRQUFRNEMsT0FBTyxTQUFTQyxpQkFBaUJsRSxLQUFLO1lBRTFDLHdCQUF3QixHQUN4QixJQUFJQSxVQUFVLFVBQVU7Z0JBQ3BCdUIsWUFBWTBDLE9BQU9qRTtnQkFDbkJ4QixLQUFLO1lBQ1QsT0FDSSxNQUFNdUIsUUFBUUM7UUFFdEIsR0FBRyxTQUFTbUU7WUFDUjFDLG1CQUFtQndDO1FBQ3ZCO1FBRUEsSUFBSUwsU0FBUyxtQkFBbUI7WUFDNUIsMkZBQTJGO1lBQzNGLElBQUlRLFFBQVEsSUFBSXJILE1BQU0sTUFBTW9DO1lBQzVCOEUsTUFBTW5FLFNBQVMsQ0FBQyxtQkFBbUI7WUFDbkNzRSxNQUFNVCxHQUFHLENBQUNNO1lBQ1Z0QixPQUFPZ0IsR0FBRyxDQUFDUztRQUNmLE9BQU87WUFDSHpCLE9BQU9nQixHQUFHLENBQUNNO1FBQ2Y7UUFDQSxJQUFJdEIsV0FBVzVELEtBQUs7WUFDaEJDLGdCQUFnQlYsSUFBSSxDQUFDMkY7UUFDekI7SUFDSjtJQUVBLFNBQVNILFdBQVduQixNQUFNLEVBQUVpQixJQUFJO1FBQzVCLElBQUk5RSxXQUFXLE1BQU07WUFDakIsTUFBTWlCLFFBQVE7UUFDbEI7UUFDQSxJQUFJWixPQUFPZDtRQUVYLHNCQUFzQixHQUN0QixJQUFJLENBQUNSLE9BQU84QyxJQUFJLENBQUN4QixPQUNiLE1BQU1ZLFFBQVFaLE1BQU07UUFFeEIsSUFBSWtGLFlBQVloSCxLQUFLaUgsT0FBTyxDQUFDbkY7UUFDN0IsSUFBSUEsU0FBU2tGLFdBQ1RsRixPQUFPOUIsS0FBS2tILE9BQU8sQ0FBQ3BGO1FBQ3hCWCxLQUFLO1FBQ0wsSUFBSWdHLEtBQUt2RCxRQUFRNUM7UUFDakIsSUFBSStFLE9BQU8sSUFBSXhHLEtBQUt1QztRQUNwQmlFLEtBQUtxQixLQUFLLEdBQUc7UUFDYixJQUFJUixRQUFRLElBQUlwSCxNQUFNd0gsV0FBV0csSUFBSXJGLE1BQU15RTtRQUMzQ0ssTUFBTTNILFFBQVEsR0FBR0QsTUFBTUMsUUFBUTtRQUMvQitFLFFBQVErQixNQUFNLFNBQVNzQixpQkFBaUIxRSxLQUFLO1lBQ3pDLE9BQVFBO2dCQUVKLEtBQUs7b0JBQ0R1QixZQUFZNkIsTUFBTXBEO29CQUNsQnhCLEtBQUs7b0JBQ0w7Z0JBQ0osS0FBSztnQkFDTCxLQUFLO29CQUNEK0UsV0FBV0gsTUFBTXBEO29CQUNqQjtnQkFFSixLQUFLO29CQUNELHNCQUFzQixHQUN0QixJQUFJbEIsWUFBWSxVQUFVO3dCQUN0QnlFLFdBQVdILE1BQU07b0JBQ3JCLE9BQU87d0JBQ0hHLFdBQVdILE1BQU07b0JBQ3JCO29CQUNBO2dCQUVKLEtBQUs7b0JBQ0RSLFVBQVVRLE1BQU1wRDtvQkFDaEI7Z0JBRUosS0FBSztvQkFDRDZDLFVBQVVPLE1BQU1wRDtvQkFDaEI7Z0JBRUosS0FBSztvQkFDRFksV0FBV3dDLEtBQUtNLFFBQVEsSUFBS04sQ0FBQUEsS0FBS00sUUFBUSxHQUFHLEVBQUUsR0FBRztvQkFDbEQ7Z0JBRUosd0JBQXdCLEdBQ3hCO29CQUNJLE1BQU0zRCxRQUFRQyxRQUFRLDRDQUE0QztZQUMxRTtRQUNKO1FBQ0EyQyxPQUFPZ0IsR0FBRyxDQUFDUCxNQUNKTyxHQUFHLENBQUNNO0lBQ2Y7SUFFQSxTQUFTWCxjQUFjWCxNQUFNO1FBQ3pCbkUsS0FBSztRQUNMLElBQUltRyxVQUFVdEc7UUFFZCxzQkFBc0IsR0FDdEIsSUFBSWpCLE1BQU13SCxNQUFNLENBQUNELFFBQVEsS0FBSzlFLFdBQzFCLE1BQU1FLFFBQVE0RSxTQUFTO1FBRTNCbkcsS0FBSztRQUNMLElBQUlxRyxZQUFZeEc7UUFFaEIsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ1AsVUFBVTZDLElBQUksQ0FBQ2tFLFlBQ2hCLE1BQU05RSxRQUFROEUsV0FBVztRQUU3QnJHLEtBQUs7UUFDTCxJQUFJVyxPQUFPZDtRQUVYLHNCQUFzQixHQUN0QixJQUFJLENBQUNSLE9BQU84QyxJQUFJLENBQUN4QixPQUNiLE1BQU1ZLFFBQVFaLE1BQU07UUFFeEJYLEtBQUs7UUFDTCxJQUFJeUYsUUFBUSxJQUFJbkgsU0FBU29DLFVBQVVDLE9BQU84QixRQUFRNUMsU0FBU3NHLFNBQVNFO1FBQ3BFeEQsUUFBUTRDLE9BQU8sU0FBU2Esb0JBQW9COUUsS0FBSztZQUU3Qyx3QkFBd0IsR0FDeEIsSUFBSUEsVUFBVSxVQUFVO2dCQUNwQnVCLFlBQVkwQyxPQUFPakU7Z0JBQ25CeEIsS0FBSztZQUNULE9BQ0ksTUFBTXVCLFFBQVFDO1FBRXRCLEdBQUcsU0FBUytFO1lBQ1J0RCxtQkFBbUJ3QztRQUN2QjtRQUNBdEIsT0FBT2dCLEdBQUcsQ0FBQ007SUFDZjtJQUVBLFNBQVNULFdBQVdiLE1BQU0sRUFBRTNDLEtBQUs7UUFFN0Isc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ25DLE9BQU84QyxJQUFJLENBQUNYLFFBQVEzQixTQUNyQixNQUFNMEIsUUFBUUMsT0FBTztRQUV6QixJQUFJb0UsUUFBUSxJQUFJckgsTUFBTW1DLFVBQVVjO1FBQ2hDcUIsUUFBUStDLE9BQU8sU0FBU1ksaUJBQWlCaEYsS0FBSztZQUMxQyxJQUFJQSxVQUFVLFVBQVU7Z0JBQ3BCdUIsWUFBWTZDLE9BQU9wRTtnQkFDbkJ4QixLQUFLO1lBQ1QsT0FBTztnQkFDSEYsS0FBSzBCO2dCQUNMdUQsV0FBV2EsT0FBTztZQUN0QjtRQUNKO1FBQ0F6QixPQUFPZ0IsR0FBRyxDQUFDUztJQUNmO0lBRUEsU0FBU3ZCLFVBQVVGLE1BQU0sRUFBRTNDLEtBQUs7UUFFNUIsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ25DLE9BQU84QyxJQUFJLENBQUNYLFFBQVEzQixTQUNyQixNQUFNMEIsUUFBUUMsT0FBTztRQUV6QixJQUFJaUYsTUFBTSxJQUFJakksS0FBS2dEO1FBQ25CcUIsUUFBUTRELEtBQUssU0FBU0MsZ0JBQWdCbEYsS0FBSztZQUN6QyxPQUFPQTtnQkFDTCxLQUFLO29CQUNIdUIsWUFBWTBELEtBQUtqRjtvQkFDakJ4QixLQUFLO29CQUNMO2dCQUVGLEtBQUs7b0JBQ0hvQyxXQUFXcUUsSUFBSXZCLFFBQVEsSUFBS3VCLENBQUFBLElBQUl2QixRQUFRLEdBQUcsRUFBRSxHQUFHO29CQUNoRCxJQUFHdUIsSUFBSXZCLFFBQVEsS0FBSzdELFdBQVdvRixJQUFJdkIsUUFBUSxHQUFHLEVBQUU7b0JBQ2hEO2dCQUVGO29CQUNFeUIsZUFBZUYsS0FBS2pGO1lBQ3hCO1FBQ0Y7UUFDQTJDLE9BQU9nQixHQUFHLENBQUNzQjtRQUNYLElBQUl0QyxXQUFXNUQsS0FBSztZQUNoQkMsZ0JBQWdCVixJQUFJLENBQUMyRztRQUN6QjtJQUNKO0lBRUEsU0FBU0UsZUFBZXhDLE1BQU0sRUFBRTNDLEtBQUs7UUFFakMsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ25DLE9BQU84QyxJQUFJLENBQUNYLFFBQ2IsTUFBTUQsUUFBUUMsT0FBTztRQUV6QnhCLEtBQUs7UUFDTCxJQUFJNEMsUUFBUUgsUUFBUTVDLFFBQVEsT0FDeEI4QyxRQUFRO1lBQ0psRCxTQUFTNEI7UUFDYjtRQUNKc0IsTUFBTXZCLFNBQVMsR0FBRyxTQUFTVCxJQUFJO1lBQzNCLE9BQU8sSUFBSSxDQUFDbEIsT0FBTyxDQUFDa0IsS0FBSztRQUM3QjtRQUNBZ0MsTUFBTXJCLFNBQVMsR0FBRyxTQUFTWCxJQUFJLEVBQUVpQyxLQUFLO1lBQ2xDakUsaUJBQWlCaUksU0FBUyxDQUFDdEYsU0FBUyxDQUFDdUYsSUFBSSxDQUFDbEUsT0FBT2hDLE1BQU1pQztRQUMzRDtRQUNBRCxNQUFNbUUsZUFBZSxHQUFHO1lBQ3BCLE9BQU96RjtRQUNYO1FBQ0F3QixRQUFRRixPQUFPLFNBQVNvRSxxQkFBcUJ2RixLQUFLO1lBRTlDLHdCQUF3QixHQUN4QixJQUFJQSxVQUFVLFVBQVU7Z0JBQ3BCdUIsWUFBWUosT0FBT25CLFFBQVEsT0FBTztnQkFDbEN4QixLQUFLO1lBQ1QsT0FDSSxNQUFNdUIsUUFBUUM7UUFFdEIsR0FBRyxTQUFTd0Y7WUFDUi9ELG1CQUFtQk4sUUFBUSxPQUFPO1FBQ3RDO1FBQ0F3QixPQUFPZ0IsR0FBRyxDQUFDM0QsT0FBT29CLE9BQU9ELE1BQU1nQyxPQUFPLEVBQUVoQyxNQUFNc0UsYUFBYSxJQUFJdEUsTUFBTWxELE9BQU87SUFDaEY7SUFFQSxTQUFTc0QsWUFBWW9CLE1BQU0sRUFBRTNDLEtBQUs7UUFDMUIsSUFBSTBGO1FBQ0osSUFBSUM7UUFDSixJQUFJQyxXQUFXO1FBQ2YsSUFBSTVGLFVBQVUsVUFBVTtZQUNwQkEsUUFBUTNCO1FBQ1o7UUFFQSxNQUFPMkIsVUFBVSxJQUFLO1lBQ2xCLElBQUlBLFVBQVUsS0FBSztnQkFDZixJQUFJNkYsY0FBY3hIO2dCQUNsQkcsS0FBSztnQkFDTHdCLFFBQVEsTUFBTTZGLGNBQWM7WUFDaEM7WUFDQSxJQUFJRCxVQUFVO2dCQUNWQSxXQUFXO2dCQUNYLElBQUk1RixNQUFNeUMsUUFBUSxDQUFDLFFBQVEsQ0FBQ3pDLE1BQU15QyxRQUFRLENBQUMsTUFBTTtvQkFDN0MsSUFBSXFELFNBQVM5RixNQUFNK0YsS0FBSyxDQUFDO29CQUN6QkwsU0FBU0ksTUFBTSxDQUFDLEVBQUUsR0FBRztvQkFDckI5RixRQUFROEYsTUFBTSxDQUFDLEVBQUU7b0JBQ2pCO2dCQUNKO2dCQUNBSixTQUFTMUY7WUFDYixPQUFPO2dCQUNIMkYsV0FBV0EsV0FBV0EsWUFBWTNGLFFBQVFBO1lBQzlDO1lBQ0FBLFFBQVEzQjtRQUNaO1FBQ0EsSUFBSWMsT0FBT3dHLFdBQVdELE9BQU9NLE1BQU0sQ0FBQ0wsWUFBWUQ7UUFDaEQsSUFBSU8sY0FBY0MsaUJBQWlCdkQsUUFBUXhEO1FBQzNDd0csV0FBV0EsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxNQUFNQSxTQUFTUSxLQUFLLENBQUMsS0FBS1I7UUFDakVELFNBQVNBLFVBQVVBLE1BQU0sQ0FBQ0EsT0FBT1UsTUFBTSxHQUFHLEVBQUUsS0FBSyxNQUFNVixPQUFPUyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtUO1FBQzdFSixnQkFBZ0IzQyxRQUFRK0MsUUFBUU8sYUFBYU47SUFDckQ7SUFFQSxTQUFTTyxpQkFBaUJ2RCxNQUFNLEVBQUV4RCxJQUFJO1FBQ2xDLDhCQUE4QjtRQUM5QixJQUFJWCxLQUFLLEtBQUssT0FBTztZQUNqQixJQUFJNkgsZUFBZSxDQUFDO1lBRXBCLE1BQU8sQ0FBQzdILEtBQUssS0FBSyxNQUFPO2dCQUNyQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDWCxPQUFPOEMsSUFBSSxDQUFDWCxRQUFRM0IsU0FBUztvQkFDOUIsTUFBTTBCLFFBQVFDLE9BQU87Z0JBQ3pCO2dCQUNBLElBQUlBLFVBQVUsTUFBTTtvQkFDbEIsTUFBTUQsUUFBUUMsT0FBTztnQkFDdkI7Z0JBRUEsSUFBSW9CO2dCQUNKLElBQUl1RSxXQUFXM0Y7Z0JBRWZ4QixLQUFLLEtBQUs7Z0JBRVYsSUFBSUQsV0FBVyxLQUFLO29CQUNoQix5QkFBeUI7b0JBQ3pCLHVDQUF1QztvQkFDdkMsS0FBSztvQkFDTDZDLFFBQVE4RSxpQkFBaUJ2RCxRQUFReEQsT0FBTyxNQUFNYTtnQkFDbEQsT0FBTyxJQUFJekIsV0FBVyxLQUFLO29CQUN2QjZDLFFBQVEsRUFBRTtvQkFDVixJQUFJa0Y7b0JBQ0osSUFBSTlILEtBQUssS0FBSyxPQUFPO3dCQUNqQixHQUFHOzRCQUNDOEgsWUFBWS9GLFVBQVU7NEJBQ3RCYSxNQUFNOUMsSUFBSSxDQUFDZ0k7d0JBQ2YsUUFBUzlILEtBQUssS0FBSyxPQUFPO3dCQUMxQkEsS0FBSzt3QkFDTCxJQUFJLE9BQU84SCxjQUFjLGFBQWE7NEJBQ2xDeEcsVUFBVTZDLFFBQVF4RCxPQUFPLE1BQU1hLE9BQU9zRzt3QkFDMUM7b0JBQ0o7Z0JBQ0osT0FBTztvQkFDSGxGLFFBQVFiLFVBQVU7b0JBQ2xCVCxVQUFVNkMsUUFBUXhELE9BQU8sTUFBTWEsT0FBT29CO2dCQUMxQztnQkFFQSxJQUFJbUYsWUFBWUYsWUFBWSxDQUFDVixTQUFTO2dCQUV0QyxJQUFJWSxXQUNBbkYsUUFBUSxFQUFFLENBQUM0RSxNQUFNLENBQUNPLFdBQVdQLE1BQU0sQ0FBQzVFO2dCQUV4Q2lGLFlBQVksQ0FBQ1YsU0FBUyxHQUFHdkU7Z0JBRXpCLHdDQUF3QztnQkFDeEM1QyxLQUFLLEtBQUs7Z0JBQ1ZBLEtBQUssS0FBSztZQUNkO1lBRUEsT0FBTzZIO1FBQ1g7UUFFQSxJQUFJRyxjQUFjakcsVUFBVTtRQUM1QlQsVUFBVTZDLFFBQVF4RCxNQUFNcUg7UUFDeEIsT0FBT0E7SUFDUCwrQ0FBK0M7SUFDbkQ7SUFFQSxTQUFTMUcsVUFBVTZDLE1BQU0sRUFBRXhELElBQUksRUFBRWlDLEtBQUs7UUFDbEMsSUFBSXJDLFFBQVE0RCxVQUFVLGNBQWNoQyxJQUFJLENBQUN4QixPQUFPO1lBQzVDRixlQUFlLENBQUNFLEtBQUssR0FBR2lDO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJdUIsT0FBTzdDLFNBQVMsRUFDaEI2QyxPQUFPN0MsU0FBUyxDQUFDWCxNQUFNaUM7SUFDL0I7SUFFQSxTQUFTa0UsZ0JBQWdCM0MsTUFBTSxFQUFFeEQsSUFBSSxFQUFFaUMsS0FBSyxFQUFFdUUsUUFBUTtRQUNsRCxJQUFJaEQsT0FBTzJDLGVBQWUsRUFDdEIzQyxPQUFPMkMsZUFBZSxDQUFDbkcsTUFBTWlDLE9BQU91RTtJQUM1QztJQUVBLFNBQVNsRSxtQkFBbUJrQixNQUFNO1FBQzlCLElBQUluRSxLQUFLLEtBQUssT0FBTztZQUNqQixHQUFHO2dCQUNDK0MsWUFBWW9CLFFBQVE7WUFDeEIsUUFBU25FLEtBQUssS0FBSyxPQUFPO1lBQzFCQSxLQUFLO1FBQ1Q7UUFDQSxPQUFPbUU7SUFDWDtJQUVBLFNBQVNHLGFBQWFILE1BQU0sRUFBRTNDLEtBQUs7UUFFL0Isc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ25DLE9BQU84QyxJQUFJLENBQUNYLFFBQVEzQixTQUNyQixNQUFNMEIsUUFBUUMsT0FBTztRQUV6QixJQUFJeUcsVUFBVSxJQUFJeEosUUFBUStDO1FBQzFCcUIsUUFBUW9GLFNBQVMsU0FBU0MsbUJBQW1CMUcsS0FBSztZQUM5QyxJQUFJMEMsWUFBWStELFNBQVN6RyxRQUFRO2dCQUM3QjtZQUNKO1lBRUEsd0JBQXdCLEdBQ3hCLElBQUlBLFVBQVUsT0FDVjJHLFlBQVlGLFNBQVN6RztpQkFFckIsTUFBTUQsUUFBUUM7UUFDdEI7UUFDQTJDLE9BQU9nQixHQUFHLENBQUM4QztRQUNYLElBQUk5RCxXQUFXNUQsS0FBSztZQUNoQkMsZ0JBQWdCVixJQUFJLENBQUNtSTtRQUN6QjtJQUNKO0lBRUEsU0FBU0UsWUFBWWhFLE1BQU0sRUFBRTNDLEtBQUs7UUFDOUIsd0VBQXdFO1FBQ3hFLDJDQUEyQztRQUMzQyxJQUFJNEcsY0FBY25JO1FBRWxCLElBQUkyRSxPQUFPcEQ7UUFFWCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDbkMsT0FBTzhDLElBQUksQ0FBQ1gsUUFBUTNCLFNBQ3JCLE1BQU0wQixRQUFRQyxPQUFPO1FBRXpCLElBQUliLE9BQU9hLE9BQ1A2RyxhQUFhQyxlQUNiQyxjQUFjQztRQUVsQnhJLEtBQUs7UUFDTCxJQUFJQSxLQUFLLFVBQVUsT0FDZnNJLGdCQUFnQjtRQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDaEosVUFBVTZDLElBQUksQ0FBQ1gsUUFBUTNCLFNBQ3hCLE1BQU0wQixRQUFRQztRQUVsQjZHLGNBQWM3RztRQUNkeEIsS0FBSztRQUFNQSxLQUFLO1FBQVlBLEtBQUs7UUFDakMsSUFBSUEsS0FBSyxVQUFVLE9BQ2Z3SSxpQkFBaUI7UUFFckIsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ2xKLFVBQVU2QyxJQUFJLENBQUNYLFFBQVEzQixTQUN4QixNQUFNMEIsUUFBUUM7UUFFbEIrRyxlQUFlL0c7UUFDZnhCLEtBQUs7UUFFTCxJQUFJeUksU0FBUyxJQUFJL0osT0FBT2lDLE1BQU1pRSxNQUFNeUQsYUFBYUUsY0FBY0QsZUFBZUU7UUFDOUVDLE9BQU85RCxPQUFPLEdBQUd5RDtRQUNqQnZGLFFBQVE0RixRQUFRLFNBQVNDLGtCQUFrQmxILEtBQUs7WUFFNUMsd0JBQXdCLEdBQ3hCLElBQUlBLFVBQVUsVUFBVTtnQkFDcEJ1QixZQUFZMEYsUUFBUWpIO2dCQUNwQnhCLEtBQUs7WUFDVCxPQUNJLE1BQU11QixRQUFRQztRQUV0QjtRQUNBMkMsT0FBT2dCLEdBQUcsQ0FBQ3NEO0lBQ2Y7SUFFQSxTQUFTbEUsZUFBZUosTUFBTSxFQUFFM0MsS0FBSztRQUVqQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDbEMsVUFBVTZDLElBQUksQ0FBQ1gsUUFBUTNCLFNBQ3hCLE1BQU0wQixRQUFRQyxPQUFPO1FBRXpCLElBQUltSCxZQUFZbkg7UUFDaEJxQixRQUFRLE1BQU0sU0FBUytGLHFCQUFxQnBILEtBQUs7WUFDN0MsT0FBUUE7Z0JBRUosS0FBSztnQkFDTCxLQUFLO29CQUNEdUQsV0FBV1osUUFBUTNDLE9BQU9tSDtvQkFDMUI7Z0JBRUosS0FBSztvQkFDRCxzQkFBc0IsR0FDdEIsSUFBSXJJLFlBQVksVUFBVTt3QkFDdEJ5RSxXQUFXWixRQUFRLG1CQUFtQndFO29CQUMxQyxPQUFPO3dCQUNINUQsV0FBV1osUUFBUSxZQUFZd0U7b0JBQ25DO29CQUNBO2dCQUVKO29CQUNJLHNCQUFzQixHQUN0QixJQUFJckksWUFBWSxZQUFZLENBQUNoQixVQUFVNkMsSUFBSSxDQUFDWCxRQUN4QyxNQUFNRCxRQUFRQztvQkFDbEIxQixLQUFLMEI7b0JBQ0x1RCxXQUFXWixRQUFRLFlBQVl3RTtvQkFDL0I7WUFDUjtRQUNKO0lBQ0o7SUFFQSxJQUFJbkg7SUFDSixNQUFPLENBQUNBLFFBQVEzQixNQUFLLE1BQU8sS0FBTTtRQUM5QixPQUFRMkI7WUFFSixLQUFLO2dCQUVELHNCQUFzQixHQUN0QixJQUFJLENBQUN0QixNQUNELE1BQU1xQixRQUFRQztnQkFFbEJrQztnQkFDQTtZQUVKLEtBQUs7Z0JBRUQsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ3hELE1BQ0QsTUFBTXFCLFFBQVFDO2dCQUVsQm9DO2dCQUNBO1lBRUosS0FBSztnQkFFRCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDMUQsTUFDRCxNQUFNcUIsUUFBUUM7Z0JBRWxCc0M7Z0JBQ0E7WUFFSixLQUFLO2dCQUNELHNCQUFzQixHQUN0QixJQUFJLENBQUM1RCxNQUNELE1BQU1xQixRQUFRQztnQkFDbEJ1QztnQkFDQTtZQUVKLEtBQUs7Z0JBQ0RoQixZQUFZeEMsS0FBS2lCO2dCQUNqQnhCLEtBQUssS0FBSztnQkFDVjtZQUVKO2dCQUVJLHdCQUF3QixHQUN4QixJQUFJa0UsWUFBWTNELEtBQUtpQixRQUFRO29CQUN6QnRCLE9BQU87b0JBQ1A7Z0JBQ0o7Z0JBRUEsd0JBQXdCLEdBQ3hCLE1BQU1xQixRQUFRQztRQUN0QjtJQUNKO0lBRUFYO0lBRUFoRCxNQUFNQyxRQUFRLEdBQUc7SUFDakIsT0FBTztRQUNILFdBQWdCcUM7UUFDaEIsV0FBZ0JDO1FBQ2ZDLGFBQWVBO1FBQ2ZiLE1BQWVBO0lBQ3BCO0FBQ0osRUFFQTs7Ozs7Ozs7OztDQVVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzPzIzMWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG5wYXJzZS5maWxlbmFtZSA9IG51bGw7XG5wYXJzZS5kZWZhdWx0cyA9IHsga2VlcENhc2U6IGZhbHNlIH07XG5cbnZhciB0b2tlbml6ZSAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKSxcbiAgICBSb290ICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpLFxuICAgIFR5cGUgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVcIiksXG4gICAgRmllbGQgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgTWFwRmllbGQgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIiksXG4gICAgT25lT2YgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1ldGhvZCAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcbiAgICBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpLFxuICAgIHR5cGVzICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBiYXNlMTBSZSAgICA9IC9eWzEtOV1bMC05XSokLyxcbiAgICBiYXNlMTBOZWdSZSA9IC9eLT9bMS05XVswLTldKiQvLFxuICAgIGJhc2UxNlJlICAgID0gL14wW3hdWzAtOWEtZkEtRl0rJC8sXG4gICAgYmFzZTE2TmVnUmUgPSAvXi0/MFt4XVswLTlhLWZBLUZdKyQvLFxuICAgIGJhc2U4UmUgICAgID0gL14wWzAtN10rJC8sXG4gICAgYmFzZThOZWdSZSAgPSAvXi0/MFswLTddKyQvLFxuICAgIG51bWJlclJlICAgID0gL14oPyFbZUVdKVswLTldKig/OlxcLlswLTldKik/KD86W2VFXVsrLV0/WzAtOV0rKT8kLyxcbiAgICBuYW1lUmUgICAgICA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvLFxuICAgIHR5cGVSZWZSZSAgID0gL14oPzpcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKikoPzpcXC5bYS16QS1aX11bYS16QS1aXzAtOV0qKSokLztcblxuLyoqXG4gKiBSZXN1bHQgb2JqZWN0IHJldHVybmVkIGZyb20ge0BsaW5rIHBhcnNlfS5cbiAqIEBpbnRlcmZhY2UgSVBhcnNlclJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYWNrYWdlIFBhY2thZ2UgbmFtZSwgaWYgZGVjbGFyZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW118dW5kZWZpbmVkfSBpbXBvcnRzIEltcG9ydHMsIGlmIGFueVxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IHdlYWtJbXBvcnRzIFdlYWsgaW1wb3J0cywgaWYgYW55XG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgUG9wdWxhdGVkIHJvb3QgaW5zdGFuY2VcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiB7QGxpbmsgcGFyc2V9LlxuICogQGludGVyZmFjZSBJUGFyc2VPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ2FzZT1mYWxzZV0gS2VlcHMgZmllbGQgY2FzaW5nIGluc3RlYWQgb2YgY29udmVydGluZyB0byBjYW1lbCBjYXNlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHRlcm5hdGVDb21tZW50TW9kZT1mYWxzZV0gUmVjb2duaXplIGRvdWJsZS1zbGFzaCBjb21tZW50cyBpbiBhZGRpdGlvbiB0byBkb2MtYmxvY2sgY29tbWVudHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJUcmFpbGluZ0NvbW1lbnQ9ZmFsc2VdIFVzZSB0cmFpbGluZyBjb21tZW50IHdoZW4gYm90aCBsZWFkaW5nIGNvbW1lbnQgYW5kIHRyYWlsaW5nIGNvbW1lbnQgZXhpc3QuXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb2YgSlNPTiBzZXJpYWxpemF0aW9uLlxuICogQGludGVyZmFjZSBJVG9KU09OT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcENvbW1lbnRzPWZhbHNlXSBTZXJpYWxpemVzIGNvbW1lbnRzLlxuICovXG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgdG8gcG9wdWxhdGVcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge0lQYXJzZXJSZXN1bHR9IFBhcnNlciByZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlbmFtZT1udWxsIEN1cnJlbnRseSBwcm9jZXNzaW5nIGZpbGUgbmFtZSBmb3IgZXJyb3IgcmVwb3J0aW5nLCBpZiBrbm93blxuICogQHByb3BlcnR5IHtJUGFyc2VPcHRpb25zfSBkZWZhdWx0cyBEZWZhdWx0IHtAbGluayBJUGFyc2VPcHRpb25zfVxuICovXG5mdW5jdGlvbiBwYXJzZShzb3VyY2UsIHJvb3QsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbiAgICBpZiAoIShyb290IGluc3RhbmNlb2YgUm9vdCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBuZXcgUm9vdCgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSBwYXJzZS5kZWZhdWx0cztcblxuICAgIHZhciBwcmVmZXJUcmFpbGluZ0NvbW1lbnQgPSBvcHRpb25zLnByZWZlclRyYWlsaW5nQ29tbWVudCB8fCBmYWxzZTtcbiAgICB2YXIgdG4gPSB0b2tlbml6ZShzb3VyY2UsIG9wdGlvbnMuYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgZmFsc2UpLFxuICAgICAgICBuZXh0ID0gdG4ubmV4dCxcbiAgICAgICAgcHVzaCA9IHRuLnB1c2gsXG4gICAgICAgIHBlZWsgPSB0bi5wZWVrLFxuICAgICAgICBza2lwID0gdG4uc2tpcCxcbiAgICAgICAgY21udCA9IHRuLmNtbnQ7XG5cbiAgICB2YXIgaGVhZCA9IHRydWUsXG4gICAgICAgIHBrZyxcbiAgICAgICAgaW1wb3J0cyxcbiAgICAgICAgd2Vha0ltcG9ydHMsXG4gICAgICAgIGVkaXRpb24gPSBcInByb3RvMlwiO1xuXG4gICAgdmFyIHB0ciA9IHJvb3Q7XG5cbiAgICB2YXIgdG9wTGV2ZWxPYmplY3RzID0gW107XG4gICAgdmFyIHRvcExldmVsT3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGFwcGx5Q2FzZSA9IG9wdGlvbnMua2VlcENhc2UgPyBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lOyB9IDogdXRpbC5jYW1lbENhc2U7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlRmlsZUZlYXR1cmVzKCkge1xuICAgICAgICB0b3BMZXZlbE9iamVjdHMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgb2JqLl9lZGl0aW9uID0gZWRpdGlvbjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRvcExldmVsT3B0aW9ucykuZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvYmouZ2V0T3B0aW9uKG9wdCkgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9iai5zZXRPcHRpb24ob3B0LCB0b3BMZXZlbE9wdGlvbnNbb3B0XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHRva2VuLCBuYW1lLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWYgKCFpbnNpZGVUcnlDYXRjaClcbiAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIChuYW1lIHx8IFwidG9rZW5cIikgKyBcIiAnXCIgKyB0b2tlbiArIFwiJyAoXCIgKyAoZmlsZW5hbWUgPyBmaWxlbmFtZSArIFwiLCBcIiA6IFwiXCIpICsgXCJsaW5lIFwiICsgdG4ubGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICB0b2tlbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJcXFwiXCIgJiYgdG9rZW4gIT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuZXh0KCkpO1xuICAgICAgICAgICAgc2tpcCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVmFsdWUoYWNjZXB0VHlwZVJlZikge1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxcIlwiOlxuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiBjYXNlIFwiVFJVRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IGNhc2UgXCJGQUxTRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRva2VuLCAvKiBpbnNpZGVUcnlDYXRjaCAqLyB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChhY2NlcHRUeXBlUmVmICYmIHR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFJhbmdlcyh0YXJnZXQsIGFjY2VwdFN0cmluZ3MpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGFjY2VwdFN0cmluZ3MgJiYgKCh0b2tlbiA9IHBlZWsoKSkgPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gcmVhZFN0cmluZygpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRpb24gPj0gMjAyMykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHN0ciwgXCJpZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFsgc3RhcnQgPSBwYXJzZUlkKG5leHQoKSksIHNraXAoXCJ0b1wiLCB0cnVlKSA/IHBhcnNlSWQobmV4dCgpKSA6IHN0YXJ0IF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZXB0U3RyaW5ncyAmJiB0eXBlUmVmUmUudGVzdCh0b2tlbikgJiYgZWRpdGlvbiA+PSAyMDIzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgdmFyIGR1bW15ID0ge29wdGlvbnM6IHVuZGVmaW5lZH07XG4gICAgICAgIGR1bW15LnNldE9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWZCbG9jayhcbiAgICAgICAgICAgIGR1bW15LFxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VSYW5nZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihkdW1teSwgdG9rZW4pOyAgLy8gc2tpcFxuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJhbmdlX2xpbmUoKSB7XG4gICAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhkdW1teSk7ICAvLyBza2lwXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU51bWJlcih0b2tlbiwgaW5zaWRlVHJ5Q2F0Y2gpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICBpZiAodG9rZW4uY2hhckF0KDApID09PSBcIi1cIikge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcImluZlwiOiBjYXNlIFwiSU5GXCI6IGNhc2UgXCJJbmZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICAgICAgICAgICAgY2FzZSBcIm5hblwiOiBjYXNlIFwiTkFOXCI6IGNhc2UgXCJOYW5cIjogY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlMTBSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTYpO1xuICAgICAgICBpZiAoYmFzZThSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChudW1iZXJSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh0b2tlbik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJudW1iZXJcIiwgaW5zaWRlVHJ5Q2F0Y2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSWQodG9rZW4sIGFjY2VwdE5lZ2F0aXZlKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogY2FzZSBcIk1BWFwiOiBjYXNlIFwiTWF4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMTtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFhY2NlcHROZWdhdGl2ZSAmJiB0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcblxuICAgICAgICBpZiAoYmFzZTEwTmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNk5lZ1JlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCAxNik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGJhc2U4TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiaWRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYWNrYWdlKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHBrZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInBhY2thZ2VcIik7XG5cbiAgICAgICAgcGtnID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHBrZykpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHBrZywgXCJuYW1lXCIpO1xuXG4gICAgICAgIHB0ciA9IHB0ci5kZWZpbmUocGtnKTtcblxuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGVlaygpO1xuICAgICAgICB2YXIgd2hpY2hJbXBvcnRzO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwid2Vha1wiOlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IHdlYWtJbXBvcnRzIHx8ICh3ZWFrSW1wb3J0cyA9IFtdKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSBpbXBvcnRzIHx8IChpbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gcmVhZFN0cmluZygpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgd2hpY2hJbXBvcnRzLnB1c2godG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3ludGF4KCkge1xuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgZWRpdGlvbiA9IHJlYWRTdHJpbmcoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGVkaXRpb24gPCAyMDIzKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChlZGl0aW9uLCBcInN5bnRheFwiKTtcblxuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVkaXRpb24oKSB7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICBlZGl0aW9uID0gcmVhZFN0cmluZygpO1xuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFZGl0aW9ucyA9IFtcIjIwMjNcIl07XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc3VwcG9ydGVkRWRpdGlvbnMuaW5jbHVkZXMoZWRpdGlvbikpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKGVkaXRpb24sIFwiZWRpdGlvblwiKTtcblxuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tbW9uKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VUeXBlKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcInNlcnZpY2VcIjpcbiAgICAgICAgICAgICAgICBwYXJzZVNlcnZpY2UocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJleHRlbmRcIjpcbiAgICAgICAgICAgICAgICBwYXJzZUV4dGVuc2lvbihwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWZCbG9jayhvYmosIGZuSWYsIGZuRWxzZSkge1xuICAgICAgICB2YXIgdHJhaWxpbmdMaW5lID0gdG4ubGluZTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgaWYodHlwZW9mIG9iai5jb21tZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIG9iai5jb21tZW50ID0gY21udCgpOyAvLyB0cnkgYmxvY2stdHlwZSBjb21tZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcChcIntcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSBuZXh0KCkpICE9PSBcIn1cIilcbiAgICAgICAgICAgICAgICBmbklmKHRva2VuKTtcbiAgICAgICAgICAgIHNraXAoXCI7XCIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZuRWxzZSlcbiAgICAgICAgICAgICAgICBmbkVsc2UoKTtcbiAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgaWYgKG9iaiAmJiAodHlwZW9mIG9iai5jb21tZW50ICE9PSBcInN0cmluZ1wiIHx8IHByZWZlclRyYWlsaW5nQ29tbWVudCkpXG4gICAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KHRyYWlsaW5nTGluZSkgfHwgb2JqLmNvbW1lbnQ7IC8vIHRyeSBsaW5lLXR5cGUgY29tbWVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInR5cGUgbmFtZVwiKTtcblxuICAgICAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayh0eXBlLCBmdW5jdGlvbiBwYXJzZVR5cGVfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbih0eXBlLCB0b2tlbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTWFwRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGlvbiAhPT0gXCJwcm90bzJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRpb24gPT09IFwicHJvdG8zXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJwcm90bzNfb3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWRpdGlvbiAhPT0gXCJwcm90bzJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VPbmVPZih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImV4dGVuc2lvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJhbmdlcyh0eXBlLmV4dGVuc2lvbnMgfHwgKHR5cGUuZXh0ZW5zaW9ucyA9IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5yZXNlcnZlZCB8fCAodHlwZS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvMlwiIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBwdHIpIHtcbiAgICAgICAgICAgIHRvcExldmVsT2JqZWN0cy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZChwYXJlbnQsIHJ1bGUsIGV4dGVuZCkge1xuICAgICAgICB2YXIgdHlwZSA9IG5leHQoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGUgbmFtZXMgY2FuIGNvbnN1bWUgbXVsdGlwbGUgdG9rZW5zLCBpbiBtdWx0aXBsZSB2YXJpYW50czpcbiAgICAgICAgLy8gICAgcGFja2FnZS5zdWJwYWNrYWdlICAgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2Uuc3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZSAuIHN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2VcIiBcIi5cIiBcInN1YnBhY2thZ2VcIiBbVFlQRSBOQU1FIEVORFMgSEVSRV0gXCJmaWVsZFwiXG4gICAgICAgIC8vICAgIHBhY2thZ2UuICBzdWJwYWNrYWdlIGZpZWxkICAgICAgIHRva2VuczogXCJwYWNrYWdlLlwiIFwic3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZSAgLnN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2VcIiBcIi5zdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyBLZWVwIHJlYWRpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBhIHR5cGUgbmFtZSB3aXRoIG5vIHBlcmlvZCBhdCB0aGUgZW5kLFxuICAgICAgICAvLyBhbmQgdGhlIG5leHQgdG9rZW4gZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHBlcmlvZC5cbiAgICAgICAgd2hpbGUgKHR5cGUuZW5kc1dpdGgoXCIuXCIpIHx8IHBlZWsoKS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgICAgICAgdHlwZSArPSBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0eXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICBuYW1lID0gYXBwbHlDYXNlKG5hbWUpO1xuICAgICAgICBza2lwKFwiPVwiKTtcblxuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQobmFtZSwgcGFyc2VJZChuZXh0KCkpLCB0eXBlLCBydWxlLCBleHRlbmQpO1xuXG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZUZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnVsZSA9PT0gXCJwcm90bzNfb3B0aW9uYWxcIikge1xuICAgICAgICAgICAgLy8gZm9yIHByb3RvMyBvcHRpb25hbCBmaWVsZHMsIHdlIGNyZWF0ZSBhIHNpbmdsZS1tZW1iZXIgT25lb2YgdG8gbWltaWMgXCJvcHRpb25hbFwiIGJlaGF2aW9yXG4gICAgICAgICAgICB2YXIgb25lb2YgPSBuZXcgT25lT2YoXCJfXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInByb3RvM19vcHRpb25hbFwiLCB0cnVlKTtcbiAgICAgICAgICAgIG9uZW9mLmFkZChmaWVsZCk7XG4gICAgICAgICAgICBwYXJlbnQuYWRkKG9uZW9mKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hZGQoZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHB0cikge1xuICAgICAgICAgICAgdG9wTGV2ZWxPYmplY3RzLnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpIHtcbiAgICAgICAgaWYgKGVkaXRpb24gPj0gMjAyMykge1xuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IHV0aWwubGNGaXJzdChuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IGZpZWxkTmFtZSlcbiAgICAgICAgICAgIG5hbWUgPSB1dGlsLnVjRmlyc3QobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUlkKG5leHQoKSk7XG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSk7XG4gICAgICAgIHR5cGUuZ3JvdXAgPSB0cnVlO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoZmllbGROYW1lLCBpZCwgbmFtZSwgcnVsZSk7XG4gICAgICAgIGZpZWxkLmZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VHcm91cF9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcInByb3RvM19vcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVHlwZSh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbnVtKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzZXJ2ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJhbmdlcyh0eXBlLnJlc2VydmVkIHx8ICh0eXBlLnJlc2VydmVkID0gW10pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pOyAvLyB0aGVyZSBhcmUgbm8gZ3JvdXBzIHdpdGggcHJvdG8zIHNlbWFudGljc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0eXBlKVxuICAgICAgICAgICAgICAuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkKHBhcmVudCkge1xuICAgICAgICBza2lwKFwiPFwiKTtcbiAgICAgICAgdmFyIGtleVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0eXBlcy5tYXBLZXlba2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoa2V5VHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCIsXCIpO1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHZhbHVlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHZhbHVlVHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCI+XCIpO1xuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgTWFwRmllbGQoYXBwbHlDYXNlKG5hbWUpLCBwYXJzZUlkKG5leHQoKSksIGtleVR5cGUsIHZhbHVlVHlwZSk7XG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPbmVPZihwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihhcHBseUNhc2UodG9rZW4pKTtcbiAgICAgICAgaWZCbG9jayhvbmVvZiwgZnVuY3Rpb24gcGFyc2VPbmVPZl9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ob25lb2YsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgcGFyc2VGaWVsZChvbmVvZiwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBlbm0gPSBuZXcgRW51bSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2soZW5tLCBmdW5jdGlvbiBwYXJzZUVudW1fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICBzd2l0Y2godG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZW5tLCB0b2tlbik7XG4gICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgIHJlYWRSYW5nZXMoZW5tLnJlc2VydmVkIHx8IChlbm0ucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICBpZihlbm0ucmVzZXJ2ZWQgPT09IHVuZGVmaW5lZCkgZW5tLnJlc2VydmVkID0gW107XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBwYXJzZUVudW1WYWx1ZShlbm0sIHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGVubSk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHB0cikge1xuICAgICAgICAgICAgdG9wTGV2ZWxPYmplY3RzLnB1c2goZW5tKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSWQobmV4dCgpLCB0cnVlKSxcbiAgICAgICAgICAgIGR1bW15ID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZHVtbXkuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgZHVtbXkuc2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbi5jYWxsKGR1bW15LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGR1bW15LnNldFBhcnNlZE9wdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgaWZCbG9jayhkdW1teSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGR1bW15LCB0b2tlbik7IC8vIHNraXBcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZHVtbXkpOyAvLyBza2lwXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHRva2VuLCB2YWx1ZSwgZHVtbXkuY29tbWVudCwgZHVtbXkucGFyc2VkT3B0aW9ucyB8fCBkdW1teS5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uO1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgICAgICAgdmFyIGlzT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gIT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW5zVmFsdWUgPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNraXAoXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IFwiKFwiICsgcGFyZW5zVmFsdWUgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5pbmNsdWRlcyhcIi5cIikgJiYgIXRva2VuLmluY2x1ZGVzKFwiKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHRva2VuLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IHRva2Vuc1swXSArIFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lID8gcHJvcE5hbWUgKz0gdG9rZW4gOiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHByb3BOYW1lID8gb3B0aW9uLmNvbmNhdChwcm9wTmFtZSkgOiBvcHRpb247XG4gICAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lICYmIHByb3BOYW1lWzBdID09PSBcIi5cIiA/IHByb3BOYW1lLnNsaWNlKDEpIDogcHJvcE5hbWU7XG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb24gJiYgb3B0aW9uW29wdGlvbi5sZW5ndGggLSAxXSA9PT0gXCIuXCIgPyBvcHRpb24uc2xpY2UoMCwgLTEpIDogb3B0aW9uO1xuICAgICAgICAgICAgc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgb3B0aW9uLCBvcHRpb25WYWx1ZSwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKSB7XG4gICAgICAgIC8vIHsgYTogXCJmb29cIiBiIHsgYzogXCJiYXJcIiB9IH1cbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0UmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIHdoaWxlICghc2tpcChcIn1cIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJlbmQgb2YgaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHRva2VuO1xuXG4gICAgICAgICAgICAgICAgc2tpcChcIjpcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb24gKG15X29wdGlvbikgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICByZXBlYXRlZF92YWx1ZTogWyBcImZvb1wiLCBcImJhclwiIF1cbiAgICAgICAgICAgICAgICAgICAgLy8gfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVlaygpID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcChcIltcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcChcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuLCBsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IG9iamVjdFJlc3VsdFtwcm9wTmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBvYmplY3RSZXN1bHRbcHJvcE5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBTZW1pY29sb25zIGFuZCBjb21tYXMgY2FuIGJlIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgc2tpcChcIixcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltcGxlVmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHNpbXBsZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNpbXBsZVZhbHVlO1xuICAgICAgICAvLyBEb2VzIG5vdCBlbmZvcmNlIGEgZGVsaW1pdGVyIHRvIGJlIHVuaXZlcnNhbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwdHIgPT09IHBhcmVudCAmJiAvXmZlYXR1cmVzXFwuLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB0b3BMZXZlbE9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50LnNldE9wdGlvbilcbiAgICAgICAgICAgIHBhcmVudC5zZXRPcHRpb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAocGFyZW50LnNldFBhcnNlZE9wdGlvbilcbiAgICAgICAgICAgIHBhcmVudC5zZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlubGluZU9wdGlvbnMocGFyZW50KSB7XG4gICAgICAgIGlmIChza2lwKFwiW1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHBhcmVudCwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgICAgICBza2lwKFwiXVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2VydmljZShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJzZXJ2aWNlIG5hbWVcIik7XG5cbiAgICAgICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2soc2VydmljZSwgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VDb21tb24oc2VydmljZSwgdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcInJwY1wiKVxuICAgICAgICAgICAgICAgIHBhcnNlTWV0aG9kKHNlcnZpY2UsIHRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoc2VydmljZSk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHB0cikge1xuICAgICAgICAgICAgdG9wTGV2ZWxPYmplY3RzLnB1c2goc2VydmljZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1ldGhvZChwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIC8vIEdldCB0aGUgY29tbWVudCBvZiB0aGUgcHJlY2VkaW5nIGxpbmUgbm93IChpZiBvbmUgZXhpc3RzKSBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBtZXRob2QgaXMgZGVmaW5lZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMuXG4gICAgICAgIHZhciBjb21tZW50VGV4dCA9IGNtbnQoKTtcblxuICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuLFxuICAgICAgICAgICAgcmVxdWVzdFR5cGUsIHJlcXVlc3RTdHJlYW0sXG4gICAgICAgICAgICByZXNwb25zZVR5cGUsIHJlc3BvbnNlU3RyZWFtO1xuXG4gICAgICAgIHNraXAoXCIoXCIpO1xuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlcXVlc3RUeXBlID0gdG9rZW47XG4gICAgICAgIHNraXAoXCIpXCIpOyBza2lwKFwicmV0dXJuc1wiKTsgc2tpcChcIihcIik7XG4gICAgICAgIGlmIChza2lwKFwic3RyZWFtXCIsIHRydWUpKVxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlc3BvbnNlVHlwZSA9IHRva2VuO1xuICAgICAgICBza2lwKFwiKVwiKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gbmV3IE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSk7XG4gICAgICAgIG1ldGhvZC5jb21tZW50ID0gY29tbWVudFRleHQ7XG4gICAgICAgIGlmQmxvY2sobWV0aG9kLCBmdW5jdGlvbiBwYXJzZU1ldGhvZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24obWV0aG9kLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChtZXRob2QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInJlZmVyZW5jZVwiKTtcblxuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdG9rZW47XG4gICAgICAgIGlmQmxvY2sobnVsbCwgZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgdG9rZW4sIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwicHJvdG8zX29wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJvcHRpb25hbFwiLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvMlwiIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW47XG4gICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICBjYXNlIFwicGFja2FnZVwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlUGFja2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VJbXBvcnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlU3ludGF4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJlZGl0aW9uXCI6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgICAgICBwYXJzZUVkaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHB0ciwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VDb21tb24ocHRyLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzb2x2ZUZpbGVGZWF0dXJlcygpO1xuXG4gICAgcGFyc2UuZmlsZW5hbWUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwicGFja2FnZVwiICAgICA6IHBrZyxcbiAgICAgICAgXCJpbXBvcnRzXCIgICAgIDogaW1wb3J0cyxcbiAgICAgICAgIHdlYWtJbXBvcnRzICA6IHdlYWtJbXBvcnRzLFxuICAgICAgICAgcm9vdCAgICAgICAgIDogcm9vdFxuICAgIH07XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXG4gKiBAbmFtZSBwYXJzZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJwYXJzZSIsImZpbGVuYW1lIiwiZGVmYXVsdHMiLCJrZWVwQ2FzZSIsInRva2VuaXplIiwicmVxdWlyZSIsIlJvb3QiLCJUeXBlIiwiRmllbGQiLCJNYXBGaWVsZCIsIk9uZU9mIiwiRW51bSIsIlNlcnZpY2UiLCJNZXRob2QiLCJSZWZsZWN0aW9uT2JqZWN0IiwidHlwZXMiLCJ1dGlsIiwiYmFzZTEwUmUiLCJiYXNlMTBOZWdSZSIsImJhc2UxNlJlIiwiYmFzZTE2TmVnUmUiLCJiYXNlOFJlIiwiYmFzZThOZWdSZSIsIm51bWJlclJlIiwibmFtZVJlIiwidHlwZVJlZlJlIiwic291cmNlIiwicm9vdCIsIm9wdGlvbnMiLCJwcmVmZXJUcmFpbGluZ0NvbW1lbnQiLCJ0biIsImFsdGVybmF0ZUNvbW1lbnRNb2RlIiwibmV4dCIsInB1c2giLCJwZWVrIiwic2tpcCIsImNtbnQiLCJoZWFkIiwicGtnIiwiaW1wb3J0cyIsIndlYWtJbXBvcnRzIiwiZWRpdGlvbiIsInB0ciIsInRvcExldmVsT2JqZWN0cyIsInRvcExldmVsT3B0aW9ucyIsImFwcGx5Q2FzZSIsIm5hbWUiLCJjYW1lbENhc2UiLCJyZXNvbHZlRmlsZUZlYXR1cmVzIiwiZm9yRWFjaCIsIm9iaiIsIl9lZGl0aW9uIiwiT2JqZWN0Iiwia2V5cyIsIm9wdCIsImdldE9wdGlvbiIsInVuZGVmaW5lZCIsInNldE9wdGlvbiIsImlsbGVnYWwiLCJ0b2tlbiIsImluc2lkZVRyeUNhdGNoIiwiRXJyb3IiLCJsaW5lIiwicmVhZFN0cmluZyIsInZhbHVlcyIsImpvaW4iLCJyZWFkVmFsdWUiLCJhY2NlcHRUeXBlUmVmIiwicGFyc2VOdW1iZXIiLCJlIiwidGVzdCIsInJlYWRSYW5nZXMiLCJ0YXJnZXQiLCJhY2NlcHRTdHJpbmdzIiwic3RhcnQiLCJzdHIiLCJwYXJzZUlkIiwiZXJyIiwiZHVtbXkiLCJ2YWx1ZSIsImlmQmxvY2siLCJwYXJzZVJhbmdlX2Jsb2NrIiwicGFyc2VPcHRpb24iLCJwYXJzZVJhbmdlX2xpbmUiLCJwYXJzZUlubGluZU9wdGlvbnMiLCJzaWduIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiSW5maW5pdHkiLCJOYU4iLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJhY2NlcHROZWdhdGl2ZSIsInBhcnNlUGFja2FnZSIsImRlZmluZSIsInBhcnNlSW1wb3J0Iiwid2hpY2hJbXBvcnRzIiwicGFyc2VTeW50YXgiLCJwYXJzZUVkaXRpb24iLCJzdXBwb3J0ZWRFZGl0aW9ucyIsImluY2x1ZGVzIiwicGFyc2VDb21tb24iLCJwYXJlbnQiLCJwYXJzZVR5cGUiLCJwYXJzZUVudW0iLCJwYXJzZVNlcnZpY2UiLCJwYXJzZUV4dGVuc2lvbiIsImZuSWYiLCJmbkVsc2UiLCJ0cmFpbGluZ0xpbmUiLCJjb21tZW50IiwidHlwZSIsInBhcnNlVHlwZV9ibG9jayIsInBhcnNlTWFwRmllbGQiLCJwYXJzZUZpZWxkIiwicGFyc2VPbmVPZiIsImV4dGVuc2lvbnMiLCJyZXNlcnZlZCIsImFkZCIsInJ1bGUiLCJleHRlbmQiLCJwYXJzZUdyb3VwIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoIiwiZmllbGQiLCJwYXJzZUZpZWxkX2Jsb2NrIiwicGFyc2VGaWVsZF9saW5lIiwib25lb2YiLCJmaWVsZE5hbWUiLCJsY0ZpcnN0IiwidWNGaXJzdCIsImlkIiwiZ3JvdXAiLCJwYXJzZUdyb3VwX2Jsb2NrIiwia2V5VHlwZSIsIm1hcEtleSIsInZhbHVlVHlwZSIsInBhcnNlTWFwRmllbGRfYmxvY2siLCJwYXJzZU1hcEZpZWxkX2xpbmUiLCJwYXJzZU9uZU9mX2Jsb2NrIiwiZW5tIiwicGFyc2VFbnVtX2Jsb2NrIiwicGFyc2VFbnVtVmFsdWUiLCJwcm90b3R5cGUiLCJjYWxsIiwic2V0UGFyc2VkT3B0aW9uIiwicGFyc2VFbnVtVmFsdWVfYmxvY2siLCJwYXJzZUVudW1WYWx1ZV9saW5lIiwicGFyc2VkT3B0aW9ucyIsIm9wdGlvbiIsInByb3BOYW1lIiwiaXNPcHRpb24iLCJwYXJlbnNWYWx1ZSIsInRva2VucyIsInNwbGl0IiwiY29uY2F0Iiwib3B0aW9uVmFsdWUiLCJwYXJzZU9wdGlvblZhbHVlIiwic2xpY2UiLCJsZW5ndGgiLCJvYmplY3RSZXN1bHQiLCJsYXN0VmFsdWUiLCJwcmV2VmFsdWUiLCJzaW1wbGVWYWx1ZSIsInNlcnZpY2UiLCJwYXJzZVNlcnZpY2VfYmxvY2siLCJwYXJzZU1ldGhvZCIsImNvbW1lbnRUZXh0IiwicmVxdWVzdFR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VTdHJlYW0iLCJtZXRob2QiLCJwYXJzZU1ldGhvZF9ibG9jayIsInJlZmVyZW5jZSIsInBhcnNlRXh0ZW5zaW9uX2Jsb2NrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/parse.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/reader.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/reader.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Reader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar BufferReader; // cyclic\nvar LongBits = util.LongBits, utf8 = util.utf8;\n/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */ function Reader(buffer) {\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */ this.buf = buffer;\n    /**\n     * Read buffer position.\n     * @type {number}\n     */ this.pos = 0;\n    /**\n     * Read buffer length.\n     * @type {number}\n     */ this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n} : function create_array(buffer) {\n    if (Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n};\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);\n        })(buffer);\n    } : create_array;\n};\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */ Reader.create = create();\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.uint32 = function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n}();\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n/* eslint-disable no-invalid-this */ function readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) {\n        for(; i < 4; ++i){\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128) return bits;\n        i = 0;\n    } else {\n        for(; i < 3; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) {\n        for(; i < 5; ++i){\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    } else {\n        for(; i < 5; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    }\n    /* istanbul ignore next */ throw Error(\"invalid varint encoding\");\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */ Reader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end) {\n    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n}\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.fixed32 = function read_fixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.sfixed32 = function read_sfixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n/* eslint-disable no-invalid-this */ function readFixed64() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.float = function read_float() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.double = function read_double() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */ Reader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(), start = this.pos, end = this.pos + length;\n    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);\n    this.pos += length;\n    if (Array.isArray(this.buf)) return this.buf.slice(start, end);\n    if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */ Reader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */ Reader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n        }while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */ Reader.prototype.skipType = function(wireType) {\n    switch(wireType){\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while((wireType = this.uint32() & 7) !== 4){\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n        /* istanbul ignore next */ default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVlDLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUV4QyxJQUFJQyxjQUFjLFNBQVM7QUFFM0IsSUFBSUMsV0FBWUgsS0FBS0csUUFBUSxFQUN6QkMsT0FBWUosS0FBS0ksSUFBSTtBQUV6Qix3QkFBd0IsR0FDeEIsU0FBU0MsZ0JBQWdCQyxNQUFNLEVBQUVDLFdBQVc7SUFDeEMsT0FBT0MsV0FBVyx5QkFBeUJGLE9BQU9HLEdBQUcsR0FBRyxRQUFTRixDQUFBQSxlQUFlLEtBQUssUUFBUUQsT0FBT0ksR0FBRztBQUMzRztBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1gsT0FBT1ksTUFBTTtJQUVsQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBR0Q7SUFFWDs7O0tBR0MsR0FDRCxJQUFJLENBQUNGLEdBQUcsR0FBRztJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxPQUFPRSxNQUFNO0FBQzVCO0FBRUEsSUFBSUMsZUFBZSxPQUFPQyxlQUFlLGNBQ25DLFNBQVNDLG1CQUFtQkwsTUFBTTtJQUNoQyxJQUFJQSxrQkFBa0JJLGNBQWNFLE1BQU1DLE9BQU8sQ0FBQ1AsU0FDOUMsT0FBTyxJQUFJWixPQUFPWTtJQUN0QixNQUFNUSxNQUFNO0FBQ2hCLElBRUUsU0FBU0wsYUFBYUgsTUFBTTtJQUMxQixJQUFJTSxNQUFNQyxPQUFPLENBQUNQLFNBQ2QsT0FBTyxJQUFJWixPQUFPWTtJQUN0QixNQUFNUSxNQUFNO0FBQ2hCO0FBRUosSUFBSUMsU0FBUyxTQUFTQTtJQUNsQixPQUFPcEIsS0FBS3FCLE1BQU0sR0FDWixTQUFTQyxvQkFBb0JYLE1BQU07UUFDakMsT0FBTyxDQUFDWixPQUFPcUIsTUFBTSxHQUFHLFNBQVNHLGNBQWNaLE1BQU07WUFDakQsT0FBT1gsS0FB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LFlBQVlhLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ1MsR0FBRyxDQUFDO1FBQ3RDO0lBRUo7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanM/ZWRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHsgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgdmFyIG5hdGl2ZUJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgICAgICByZXR1cm4gbmF0aXZlQnVmZmVyXG4gICAgICAgICAgICA/IG5hdGl2ZUJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgOiBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFkZXIiLCJ1dGlsIiwicmVxdWlyZSIsIkJ1ZmZlclJlYWRlciIsIkxvbmdCaXRzIiwidXRmOCIsImluZGV4T3V0T2ZSYW5nZSIsInJlYWRlciIsIndyaXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsInBvcyIsImxlbiIsImJ1ZmZlciIsImJ1ZiIsImxlbmd0aCIsImNyZWF0ZV9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjcmVhdGVfdHlwZWRfYXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImNyZWF0ZSIsIkJ1ZmZlciIsImNyZWF0ZV9idWZmZXJfc2V0dXAiLCJjcmVhdGVfYnVmZmVyIiwiaXNCdWZmZXIiLCJwcm90b3R5cGUiLCJfc2xpY2UiLCJzdWJhcnJheSIsInNsaWNlIiwidWludDMyIiwicmVhZF91aW50MzJfc2V0dXAiLCJ2YWx1ZSIsInJlYWRfdWludDMyIiwiaW50MzIiLCJyZWFkX2ludDMyIiwic2ludDMyIiwicmVhZF9zaW50MzIiLCJyZWFkTG9uZ1ZhcmludCIsImJpdHMiLCJpIiwibG8iLCJoaSIsImJvb2wiLCJyZWFkX2Jvb2wiLCJyZWFkRml4ZWQzMl9lbmQiLCJlbmQiLCJmaXhlZDMyIiwicmVhZF9maXhlZDMyIiwic2ZpeGVkMzIiLCJyZWFkX3NmaXhlZDMyIiwicmVhZEZpeGVkNjQiLCJmbG9hdCIsInJlYWRfZmxvYXQiLCJyZWFkRmxvYXRMRSIsImRvdWJsZSIsInJlYWRfZG91YmxlIiwicmVhZERvdWJsZUxFIiwiYnl0ZXMiLCJyZWFkX2J5dGVzIiwic3RhcnQiLCJuYXRpdmVCdWZmZXIiLCJhbGxvYyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsInN0cmluZyIsInJlYWRfc3RyaW5nIiwicmVhZCIsInNraXAiLCJza2lwVHlwZSIsIndpcmVUeXBlIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlclJlYWRlcl8iLCJmbiIsIkxvbmciLCJtZXJnZSIsImludDY0IiwicmVhZF9pbnQ2NCIsInVpbnQ2NCIsInJlYWRfdWludDY0Iiwic2ludDY0IiwicmVhZF9zaW50NjQiLCJ6ekRlY29kZSIsImZpeGVkNjQiLCJyZWFkX2ZpeGVkNjQiLCJzZml4ZWQ2NCIsInJlYWRfc2ZpeGVkNjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/reader_buffer.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/reader_buffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferReader;\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */ function BufferReader(buffer) {\n    Reader.call(this, buffer);\n/**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */ }\nBufferReader._configure = function() {\n    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n/**\n * @override\n */ BufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */ BufferReader._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixpQkFBaUI7QUFDakIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDOUJGLENBQUFBLGFBQWFHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixPQUFPRSxTQUFTLEdBQUdHLFdBQVcsR0FBR047QUFFekUsSUFBSU8sT0FBT0wsbUJBQU9BLENBQUMsNEVBQWdCO0FBRW5DOzs7Ozs7Q0FNQyxHQUNELFNBQVNGLGFBQWFRLE1BQU07SUFDeEJQLE9BQU9RLElBQUksQ0FBQyxJQUFJLEVBQUVEO0FBRWxCOzs7O0tBSUMsR0FDTDtBQUVBUixhQUFhVSxVQUFVLEdBQUc7SUFDdEIsd0JBQXdCLEdBQ3hCLElBQUlILEtBQUtJLE1BQU0sRUFDWFgsYUFBYUcsU0FBUyxDQUFDUyxNQUFNLEdBQUdMLEtBQUtJLE1BQU0sQ0FBQ1IsU0FBUyxDQUFDVSxLQUFLO0FBQ25FO0FBR0E7O0NBRUMsR0FDRGIsYUFBYUcsU0FBUyxDQUFDVyxNQUFNLEdBQUcsU0FBU0M7SUFDckMsSUFBSUMsTUFBTSxJQUFJLENBQUNDLE1BQU0sSUFBSSxlQUFlO0lBQ3hDLE9BQU8sSUFBSSxDQUFDQyxHQUFHLENBQUNDLFNBQVMsR0FDbkIsSUFBSSxDQUFDRCxHQUFHLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUNDLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0YsR0FBRyxHQUFHSixLQUFLLElBQUksQ0FBQ0EsR0FBRyxLQUN6RSxJQUFJLENBQUNFLEdBQUcsQ0FBQ0ssUUFBUSxDQUFDLFNBQVMsSUFBSSxDQUFDSCxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNGLEdBQUcsR0FBR0osS0FBSyxJQUFJLENBQUNBLEdBQUc7QUFDM0Y7QUFFQTs7Ozs7Q0FLQyxHQUVEaEIsYUFBYVUsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzP2U5OTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJCdWZmZXJSZWFkZXIiLCJSZWFkZXIiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ1dGlsIiwiYnVmZmVyIiwiY2FsbCIsIl9jb25maWd1cmUiLCJCdWZmZXIiLCJfc2xpY2UiLCJzbGljZSIsInN0cmluZyIsInJlYWRfc3RyaW5nX2J1ZmZlciIsImxlbiIsInVpbnQzMiIsImJ1ZiIsInV0ZjhTbGljZSIsInBvcyIsIk1hdGgiLCJtaW4iLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/root.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/root.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Root;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Type, parse, common; // \"\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */ function Root(options) {\n    Namespace.call(this, \"\", options);\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */ this.deferred = [];\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */ this.files = [];\n    /**\n     * Edition, defaults to proto2 if unspecified.\n     * @type {string}\n     * @private\n     */ this._edition = \"proto2\";\n    /**\n     * Global lookup cache of fully qualified names.\n     * @type {Object.<string,ReflectionObject>}\n     * @private\n     */ this._fullyQualifiedObjects = {};\n}\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Namespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */ Root.fromJSON = function fromJSON(json, root) {\n    if (!root) root = new Root();\n    if (json.options) root.setOptions(json.options);\n    return root.addJSON(json.nested).resolveAll();\n};\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */ Root.prototype.resolvePath = util.path.resolve;\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.fetch = util.fetch;\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */ function SYNC() {} // eslint-disable-line no-empty-function\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback) {\n        return util.asPromise(load, self, filename, options);\n    }\n    var sync = callback === SYNC; // undocumented\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */ if (!callback) {\n            return;\n        }\n        if (sync) {\n            throw err;\n        }\n        if (root) {\n            root.resolveAll();\n        }\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\") source = JSON.parse(source);\n            if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options), resolved, i = 0;\n                if (parsed.imports) {\n                    for(; i < parsed.imports.length; ++i)if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i])) fetch(resolved);\n                }\n                if (parsed.weakImports) {\n                    for(i = 0; i < parsed.weakImports.length; ++i)if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);\n                }\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued) {\n            finish(null, self); // only once anyway\n        }\n    }\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1) {\n            return;\n        }\n        self.files.push(filename);\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync) {\n                process(filename, common[filename]);\n            } else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak) finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */ if (!callback) {\n                    return; // terminated meanwhile\n                }\n                if (err) {\n                    /* istanbul ignore else */ if (!weak) finish(err);\n                    else if (!queued) finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename)) {\n        filename = [\n            filename\n        ];\n    }\n    for(var i = 0, resolved; i < filename.length; ++i)if (resolved = self.resolvePath(\"\", filename[i])) fetch(resolved);\n    if (sync) {\n        self.resolveAll();\n        return self;\n    }\n    if (!queued) {\n        finish(null, self);\n    }\n    return self;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */ // function load(filename:string, [options:IParseOptions]):Promise<Root>\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */ Root.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode) throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n/**\n * @override\n */ Root.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n        return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n    }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */ function tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */ Root.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField) {\n            if (!tryHandleExtension(this, object)) this.deferred.push(object);\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n        if (object instanceof Type) for(var i = 0; i < this.deferred.length;)if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);\n        else ++i;\n        for(var j = 0; j < /* initializes */ object.nestedArray.length; ++j)this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n    if (object instanceof Type || object instanceof Enum || object instanceof Field) {\n        // Only store types and enums for quick lookup during resolve.\n        this._fullyQualifiedObjects[object.fullName] = object;\n    }\n// The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n// properties of namespaces just like static code does. This allows using a .d.ts generated for\n// a static module with reflection-based solutions where the condition is met.\n};\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */ Root.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) {\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else {\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */ if (index > -1) this.deferred.splice(index, 1);\n            }\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values\n    } else if (object instanceof Namespace) {\n        for(var i = 0; i < /* initializes */ object.nestedArray.length; ++i)this._handleRemove(object._nestedArray[i]);\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces\n    }\n    delete this._fullyQualifiedObjects[object.fullName];\n};\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type = Type_;\n    parse = parse_;\n    common = common_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsS0FBS0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUV2RixJQUFJQyxRQUFVTixtQkFBT0EsQ0FBQyw4REFBUyxHQUMzQk8sT0FBVVAsbUJBQU9BLENBQUMsNERBQVEsR0FDMUJRLFFBQVVSLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzNCUyxPQUFVVCxtQkFBT0EsQ0FBQyw0REFBUTtBQUU5QixJQUFJVSxNQUNBQyxPQUNBQyxRQUFRLElBQUk7QUFFaEI7Ozs7OztDQU1DLEdBQ0QsU0FBU2QsS0FBS2UsT0FBTztJQUNqQmQsVUFBVWUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJRDtJQUV6Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLFFBQVEsR0FBRyxFQUFFO0lBRWxCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFFZjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFFaEI7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsQ0FBQztBQUNuQztBQUVBOzs7OztDQUtDLEdBQ0RwQixLQUFLcUIsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsSUFBSTtJQUN4QyxJQUFJLENBQUNBLE1BQ0RBLE9BQU8sSUFBSXZCO0lBQ2YsSUFBSXNCLEtBQUtQLE9BQU8sRUFDWlEsS0FBS0MsVUFBVSxDQUFDRixLQUFLUCxPQUFPO0lBQ2hDLE9BQU9RLEtBQUtFLE9BQU8sQ0FBQ0gsS0FBS0ksTUFBTSxFQUFFQyxVQUFVO0FBQy9DO0FBRUE7Ozs7Ozs7Q0FP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QUlZLFFBQVEsSUFBSSxDQUFDbkYsUUFBUSxDQUFDNEMsT0FBTyxDQUFDOEI7Z0JBQ2xDLHdCQUF3QixHQUN4QixJQUFJUyxRQUFRLENBQUMsR0FDVCxJQUFJLENBQUNuRixRQUFRLENBQUM2RSxNQUFNLENBQUNNLE9BQU87WUFDcEM7UUFDSjtJQUVKLE9BQU8sSUFBSVQsa0JBQWtCbEYsTUFBTTtRQUUvQixJQUFJb0UsU0FBU2UsSUFBSSxDQUFDRCxPQUFPTCxJQUFJLEdBQ3pCLE9BQU9LLE9BQU9qQixNQUFNLENBQUNpQixPQUFPTCxJQUFJLENBQUMsRUFBRSx1QkFBdUI7SUFFbEUsT0FBTyxJQUFJSyxrQkFBa0IxRixXQUFXO1FBRXBDLElBQUssSUFBSXNELElBQUksR0FBR0EsSUFBSSxlQUFlLEdBQUdvQyxPQUFPSyxXQUFXLENBQUN2QyxNQUFNLEVBQUUsRUFBRUYsRUFDL0QsSUFBSSxDQUFDMkMsYUFBYSxDQUFDUCxPQUFPTSxZQUFZLENBQUMxQyxFQUFFO1FBRTdDLElBQUlzQixTQUFTZSxJQUFJLENBQUNELE9BQU9MLElBQUksR0FDekIsT0FBT0ssT0FBT2pCLE1BQU0sQ0FBQ2lCLE9BQU9MLElBQUksQ0FBQyxFQUFFLHNCQUFzQjtJQUVqRTtJQUVBLE9BQU8sSUFBSSxDQUFDbEUsc0JBQXNCLENBQUN1RSxPQUFPaEIsUUFBUSxDQUFDO0FBQ3ZEO0FBRUEsc0RBQXNEO0FBQ3REM0UsS0FBS3FHLFVBQVUsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUM3QzVGLE9BQVMwRjtJQUNUekYsUUFBUzBGO0lBQ1R6RixTQUFTMEY7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290LmpzPzgxNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJvb3Q7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChSb290LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gUm9vdCkuY2xhc3NOYW1lID0gXCJSb290XCI7XG5cbnZhciBGaWVsZCAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgT25lT2YgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgVHlwZSwgICAvLyBjeWNsaWNcbiAgICBwYXJzZSwgIC8vIG1pZ2h0IGJlIGV4Y2x1ZGVkXG4gICAgY29tbW9uOyAvLyBcIlxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcm9vdCBuYW1lc3BhY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJvb3QgbmFtZXNwYWNlIHdyYXBwaW5nIGFsbCB0eXBlcywgZW51bXMsIHNlcnZpY2VzLCBzdWItbmFtZXNwYWNlcyBldGMuIHRoYXQgYmVsb25nIHRvZ2V0aGVyLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gVG9wIGxldmVsIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUm9vdChvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgXCJcIiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnJlZCBleHRlbnNpb24gZmllbGRzLlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqL1xuICAgIHRoaXMuZGVmZXJyZWQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGZpbGUgbmFtZXMgb2YgbG9hZGVkIGZpbGVzLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFZGl0aW9uLCBkZWZhdWx0cyB0byBwcm90bzIgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VkaXRpb24gPSBcInByb3RvMlwiO1xuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGxvb2t1cCBjYWNoZSBvZiBmdWxseSBxdWFsaWZpZWQgbmFtZXMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLFJlZmxlY3Rpb25PYmplY3Q+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnVsbHlRdWFsaWZpZWRPYmplY3RzID0ge307XG59XG5cbi8qKlxuICogTG9hZHMgYSBuYW1lc3BhY2UgZGVzY3JpcHRvciBpbnRvIGEgcm9vdCBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge0lOYW1lc3BhY2V9IGpzb24gTmFtZXNwYWNlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWRcbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICovXG5Sb290LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgcm9vdCkge1xuICAgIGlmICghcm9vdClcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XG4gICAgaWYgKGpzb24ub3B0aW9ucylcbiAgICAgICAgcm9vdC5zZXRPcHRpb25zKGpzb24ub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJvb3QuYWRkSlNPTihqc29uLm5lc3RlZCkucmVzb2x2ZUFsbCgpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aCBvZiBhbiBpbXBvcnRlZCBmaWxlLCByZWxhdGl2ZSB0byB0aGUgaW1wb3J0aW5nIG9yaWdpbi5cbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMgaW4gY2FzZSB5b3VyIGltcG9ydHMgYXJlIHNjYXR0ZXJlZCBvdmVyIG11bHRpcGxlIGRpcmVjdG9yaWVzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIFRoZSBmaWxlIG5hbWUgb2YgdGhlIGltcG9ydGluZyBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRoZSBmaWxlIG5hbWUgYmVpbmcgaW1wb3J0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gUmVzb2x2ZWQgcGF0aCB0byBgdGFyZ2V0YCBvciBgbnVsbGAgdG8gc2tpcCB0aGUgZmlsZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IHV0aWwucGF0aC5yZXNvbHZlO1xuXG4vKipcbiAqIEZldGNoIGNvbnRlbnQgZnJvbSBmaWxlIHBhdGggb3IgdXJsXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXG4gKiBAcGFyYW0ge0ZldGNoQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5Sb290LnByb3RvdHlwZS5mZXRjaCA9IHV0aWwuZmV0Y2g7XG5cbi8vIEEgc3ltYm9sLWxpa2UgZnVuY3Rpb24gdG8gc2FmZWx5IHNpZ25hbCBzeW5jaHJvbm91cyBsb2FkaW5nXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gU1lOQygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBvcHRpb25zIFBhcnNlIG9wdGlvbnNcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UobG9hZCwgc2VsZiwgZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBzeW5jID0gY2FsbGJhY2sgPT09IFNZTkM7IC8vIHVuZG9jdW1lbnRlZFxuXG4gICAgLy8gRmluaXNoZXMgbG9hZGluZyBieSBjYWxsaW5nIHRoZSBjYWxsYmFjayAoZXhhY3RseSBvbmNlKVxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIsIHJvb3QpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYihlcnIsIHJvb3QpO1xuICAgIH1cblxuICAgIC8vIEJ1bmRsZWQgZGVmaW5pdGlvbiBleGlzdGVuY2UgY2hlY2tpbmdcbiAgICBmdW5jdGlvbiBnZXRCdW5kbGVkRmlsZU5hbWUoZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIGlkeCA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKFwiZ29vZ2xlL3Byb3RvYnVmL1wiKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgYWx0bmFtZSA9IGZpbGVuYW1lLnN1YnN0cmluZyhpZHgpO1xuICAgICAgICAgICAgaWYgKGFsdG5hbWUgaW4gY29tbW9uKSByZXR1cm4gYWx0bmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoc291cmNlKSAmJiBzb3VyY2UuY2hhckF0KDApID09PSBcIntcIilcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoc291cmNlKSlcbiAgICAgICAgICAgICAgICBzZWxmLnNldE9wdGlvbnMoc291cmNlLm9wdGlvbnMpLmFkZEpTT04oc291cmNlLm5lc3RlZCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZS5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIHNlbGYsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5pbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBhcnNlZC5pbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC5pbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQuaW1wb3J0c1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQud2Vha0ltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZWQud2Vha0ltcG9ydHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLndlYWtJbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQud2Vha0ltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN5bmMgJiYgIXF1ZXVlZCkge1xuICAgICAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpOyAvLyBvbmx5IG9uY2UgYW55d2F5XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGZXRjaGVzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBmZXRjaChmaWxlbmFtZSwgd2Vhaykge1xuICAgICAgICBmaWxlbmFtZSA9IGdldEJ1bmRsZWRGaWxlTmFtZShmaWxlbmFtZSkgfHwgZmlsZW5hbWU7XG5cbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGxvYWRlZCAvIGF0dGVtcHRlZFxuICAgICAgICBpZiAoc2VsZi5maWxlcy5pbmRleE9mKGZpbGVuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5maWxlcy5wdXNoKGZpbGVuYW1lKTtcblxuICAgICAgICAvLyBTaG9ydGN1dCBidW5kbGVkIGRlZmluaXRpb25zXG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiBjb21tb24pIHtcbiAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmZXRjaCBmcm9tIGRpc2sgb3IgbmV0d29ya1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5mcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgc2VsZi5mZXRjaChmaWxlbmFtZSwgZnVuY3Rpb24oZXJyLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAtLXF1ZXVlZDtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGVybWluYXRlZCBtZWFud2hpbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXVlZCkgLy8gY2FuJ3QgYmUgY292ZXJlZCByZWxpYWJseVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVldWVkID0gMDtcblxuICAgIC8vIEFzc2VtYmxpbmcgdGhlIHJvb3QgbmFtZXNwYWNlIGRvZXNuJ3QgcmVxdWlyZSB3b3JraW5nIHR5cGVcbiAgICAvLyByZWZlcmVuY2VzIGFueW1vcmUsIHNvIHdlIGNhbiBsb2FkIGV2ZXJ5dGhpbmcgaW4gcGFyYWxsZWxcbiAgICBpZiAodXRpbC5pc1N0cmluZyhmaWxlbmFtZSkpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBbIGZpbGVuYW1lIF07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCByZXNvbHZlZDsgaSA8IGZpbGVuYW1lLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocmVzb2x2ZWQgPSBzZWxmLnJlc29sdmVQYXRoKFwiXCIsIGZpbGVuYW1lW2ldKSlcbiAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcbiAgICBpZiAoc3luYykge1xuICAgICAgICBzZWxmLnJlc29sdmVBbGwoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGlmICghcXVldWVkKSB7XG4gICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn07XG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgb3B0aW9uczpJUGFyc2VPcHRpb25zLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbb3B0aW9uczpJUGFyc2VPcHRpb25zXSk6UHJvbWlzZTxSb290PlxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFN5bmNcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICovXG5Sb290LnByb3RvdHlwZS5sb2FkU3luYyA9IGZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlsLmlzTm9kZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub3Qgc3VwcG9ydGVkXCIpO1xuICAgIHJldHVybiB0aGlzLmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIFNZTkMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZVJlc29sdmUpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZGVmZXJyZWQubGVuZ3RoKVxuICAgICAgICB0aHJvdyBFcnJvcihcInVucmVzb2x2YWJsZSBleHRlbnNpb25zOiBcIiArIHRoaXMuZGVmZXJyZWQubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInZXh0ZW5kIFwiICsgZmllbGQuZXh0ZW5kICsgXCInIGluIFwiICsgZmllbGQucGFyZW50LmZ1bGxOYW1lO1xuICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8vIG9ubHkgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgY2hpbGRyZW4gYXJlIGV4cG9zZWQsIHNlZSBiZWxvd1xudmFyIGV4cG9zZVJlID0gL15bQS1aXS87XG5cbi8qKlxuICogSGFuZGxlcyBhIGRlZmVycmVkIGRlY2xhcmluZyBleHRlbnNpb24gZmllbGQgYnkgY3JlYXRpbmcgYSBzaXN0ZXIgZmllbGQgdG8gcmVwcmVzZW50IGl0IHdpdGhpbiBpdHMgZXh0ZW5kZWQgdHlwZS5cbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBEZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIHdpdGluIHRoZSBkZWNsYXJpbmcgdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBzdWNjZXNzZnVsbHkgYWRkZWQgdG8gdGhlIGV4dGVuZGVkIHR5cGUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gdHJ5SGFuZGxlRXh0ZW5zaW9uKHJvb3QsIGZpZWxkKSB7XG4gICAgdmFyIGV4dGVuZGVkVHlwZSA9IGZpZWxkLnBhcmVudC5sb29rdXAoZmllbGQuZXh0ZW5kKTtcbiAgICBpZiAoZXh0ZW5kZWRUeXBlKSB7XG4gICAgICAgIHZhciBzaXN0ZXJGaWVsZCA9IG5ldyBGaWVsZChmaWVsZC5mdWxsTmFtZSwgZmllbGQuaWQsIGZpZWxkLnR5cGUsIGZpZWxkLnJ1bGUsIHVuZGVmaW5lZCwgZmllbGQub3B0aW9ucyk7XG4gICAgICAgIC8vZG8gbm90IGFsbG93IHRvIGV4dGVuZCBzYW1lIGZpZWxkIHR3aWNlIHRvIHByZXZlbnQgdGhlIGVycm9yXG4gICAgICAgIGlmIChleHRlbmRlZFR5cGUuZ2V0KHNpc3RlckZpZWxkLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzaXN0ZXJGaWVsZC5kZWNsYXJpbmdGaWVsZCA9IGZpZWxkO1xuICAgICAgICBmaWVsZC5leHRlbnNpb25GaWVsZCA9IHNpc3RlckZpZWxkO1xuICAgICAgICBleHRlbmRlZFR5cGUuYWRkKHNpc3RlckZpZWxkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbnkgb2JqZWN0IGlzIGFkZGVkIHRvIHRoaXMgcm9vdCBvciBpdHMgc3ViLW5hbWVzcGFjZXMuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBPYmplY3QgYWRkZWRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5Sb290LnByb3RvdHlwZS5faGFuZGxlQWRkID0gZnVuY3Rpb24gX2hhbmRsZUFkZChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQpIHtcblxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkIChpbXBsaWVzIG5vdCBwYXJ0IG9mIGEgb25lb2YpICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCAmJiAvKiBub3QgYWxyZWFkeSBoYW5kbGVkICovICFvYmplY3QuZXh0ZW5zaW9uRmllbGQpXG4gICAgICAgICAgICBpZiAoIXRyeUhhbmRsZUV4dGVuc2lvbih0aGlzLCBvYmplY3QpKVxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucHVzaChvYmplY3QpO1xuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV0gPSBvYmplY3QudmFsdWVzOyAvLyBleHBvc2UgZW51bSB2YWx1ZXMgYXMgcHJvcGVydHkgb2YgaXRzIHBhcmVudFxuXG4gICAgfSBlbHNlIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSkgLyogZXZlcnl0aGluZyBlbHNlIGlzIGEgbmFtZXNwYWNlICovIHtcblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVHlwZSkgLy8gVHJ5IHRvIGhhbmRsZSBhbnkgZGVmZXJyZWQgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZmVycmVkLmxlbmd0aDspXG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhbmRsZUV4dGVuc2lvbih0aGlzLCB0aGlzLmRlZmVycmVkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgLyogaW5pdGlhbGl6ZXMgKi8gb2JqZWN0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytqKSAvLyByZWN1cnNlIGludG8gdGhlIG5hbWVzcGFjZVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQWRkKG9iamVjdC5fbmVzdGVkQXJyYXlbal0pO1xuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdDsgLy8gZXhwb3NlIG5hbWVzcGFjZSBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFR5cGUgfHwgb2JqZWN0IGluc3RhbmNlb2YgRW51bSB8fCBvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuICAgICAgICAvLyBPbmx5IHN0b3JlIHR5cGVzIGFuZCBlbnVtcyBmb3IgcXVpY2sgbG9va3VwIGR1cmluZyByZXNvbHZlLlxuICAgICAgICB0aGlzLl9mdWxseVF1YWxpZmllZE9iamVjdHNbb2JqZWN0LmZ1bGxOYW1lXSA9IG9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBUaGUgYWJvdmUgYWxzbyBhZGRzIHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIG5lc3RlZCB0eXBlcywgc2VydmljZXMgYW5kIGVudW1zIGFzXG4gICAgLy8gcHJvcGVydGllcyBvZiBuYW1lc3BhY2VzIGp1c3QgbGlrZSBzdGF0aWMgY29kZSBkb2VzLiBUaGlzIGFsbG93cyB1c2luZyBhIC5kLnRzIGdlbmVyYXRlZCBmb3JcbiAgICAvLyBhIHN0YXRpYyBtb2R1bGUgd2l0aCByZWZsZWN0aW9uLWJhc2VkIHNvbHV0aW9ucyB3aGVyZSB0aGUgY29uZGl0aW9uIGlzIG1ldC5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCByZW1vdmVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZVJlbW92ZSA9IGZ1bmN0aW9uIF9oYW5kbGVSZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgvKiBhbHJlYWR5IGhhbmRsZWQgKi8gb2JqZWN0LmV4dGVuc2lvbkZpZWxkKSB7IC8vIHJlbW92ZSBpdHMgc2lzdGVyIGZpZWxkXG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkLnBhcmVudC5yZW1vdmUob2JqZWN0LmV4dGVuc2lvbkZpZWxkKTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2FuY2VsIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRlZmVycmVkLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXTsgLy8gdW5leHBvc2UgZW51bSB2YWx1ZXNcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSZW1vdmUob2JqZWN0Ll9uZXN0ZWRBcnJheVtpXSk7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBuYW1lc3BhY2VzXG5cbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fZnVsbHlRdWFsaWZpZWRPYmplY3RzW29iamVjdC5mdWxsTmFtZV07XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcblJvb3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBwYXJzZV8sIGNvbW1vbl8pIHtcbiAgICBUeXBlICAgPSBUeXBlXztcbiAgICBwYXJzZSAgPSBwYXJzZV87XG4gICAgY29tbW9uID0gY29tbW9uXztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJvb3QiLCJOYW1lc3BhY2UiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJGaWVsZCIsIkVudW0iLCJPbmVPZiIsInV0aWwiLCJUeXBlIiwicGFyc2UiLCJjb21tb24iLCJvcHRpb25zIiwiY2FsbCIsImRlZmVycmVkIiwiZmlsZXMiLCJfZWRpdGlvbiIsIl9mdWxseVF1YWxpZmllZE9iamVjdHMiLCJmcm9tSlNPTiIsImpzb24iLCJyb290Iiwic2V0T3B0aW9ucyIsImFkZEpTT04iLCJuZXN0ZWQiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZVBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImZldGNoIiwiU1lOQyIsImxvYWQiLCJmaWxlbmFtZSIsImNhbGxiYWNrIiwidW5kZWZpbmVkIiwic2VsZiIsImFzUHJvbWlzZSIsInN5bmMiLCJmaW5pc2giLCJlcnIiLCJjYiIsImdldEJ1bmRsZWRGaWxlTmFtZSIsImlkeCIsImxhc3RJbmRleE9mIiwiYWx0bmFtZSIsInN1YnN0cmluZyIsInByb2Nlc3MiLCJzb3VyY2UiLCJpc1N0cmluZyIsImNoYXJBdCIsIkpTT04iLCJwYXJzZWQiLCJyZXNvbHZlZCIsImkiLCJpbXBvcnRzIiwibGVuZ3RoIiwid2Vha0ltcG9ydHMiLCJxdWV1ZWQiLCJ3ZWFrIiwiaW5kZXhPZiIsInB1c2giLCJzZXRUaW1lb3V0IiwiZnMiLCJyZWFkRmlsZVN5bmMiLCJ0b1N0cmluZyIsImxvYWRTeW5jIiwiaXNOb2RlIiwiRXJyb3IiLCJfbmVlZHNSZWN1cnNpdmVSZXNvbHZlIiwibWFwIiwiZmllbGQiLCJleHRlbmQiLCJwYXJlbnQiLCJmdWxsTmFtZSIsImpvaW4iLCJleHBvc2VSZSIsInRyeUhhbmRsZUV4dGVuc2lvbiIsImV4dGVuZGVkVHlwZSIsImxvb2t1cCIsInNpc3RlckZpZWxkIiwiaWQiLCJ0eXBlIiwicnVsZSIsImdldCIsIm5hbWUiLCJkZWNsYXJpbmdGaWVsZCIsImV4dGVuc2lvbkZpZWxkIiwiYWRkIiwiX2hhbmRsZUFkZCIsIm9iamVjdCIsInRlc3QiLCJ2YWx1ZXMiLCJzcGxpY2UiLCJqIiwibmVzdGVkQXJyYXkiLCJfbmVzdGVkQXJyYXkiLCJfaGFuZGxlUmVtb3ZlIiwicmVtb3ZlIiwiaW5kZXgiLCJfY29uZmlndXJlIiwiVHlwZV8iLCJwYXJzZV8iLCJjb21tb25fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/root.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/roots.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/roots.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {}; /**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBRyxDQUFDLEdBRWxCOzs7Ozs7Ozs7Ozs7OztDQWNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzPzY1NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/rpc.js":
/*!*********************************************!*\
  !*** ../node_modules/protobufjs/src/rpc.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Streaming RPC helpers.\n * @namespace\n */ var rpc = exports;\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */ /**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */ rpc.Service = __webpack_require__(/*! ./rpc/service */ \"(ssr)/../node_modules/protobufjs/src/rpc/service.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Q0FHQyxHQUNELElBQUlBLE1BQU1DO0FBRVY7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FFRDs7Ozs7OztDQU9DLEdBRURELElBQUlFLE9BQU8sR0FBR0MsbUJBQU9BLENBQUMsMEVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzPzNiZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIl0sIm5hbWVzIjpbInJwYyIsImV4cG9ydHMiLCJTZXJ2aWNlIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/rpc/service.js":
/*!*****************************************************!*\
  !*** ../node_modules/protobufjs/src/rpc/service.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */ /**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */ /**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */ function Service(rpcImpl, requestDelimited, responseDelimited) {\n    if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n    util.EventEmitter.call(this);\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */ this.rpcImpl = rpcImpl;\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */ this.requestDelimited = Boolean(requestDelimited);\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */ this.responseDelimited = Boolean(responseDelimited);\n}\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n    if (!request) throw TypeError(\"request must be specified\");\n    var self = this;\n    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n    if (!self.rpcImpl) {\n        setTimeout(function() {\n            callback(Error(\"already ended\"));\n        }, 0);\n        return undefined;\n    }\n    try {\n        return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n            if (err) {\n                self.emit(\"error\", err, method);\n                return callback(err);\n            }\n            if (response === null) {\n                self.end(/* endedByRPC */ true);\n                return undefined;\n            }\n            if (!(response instanceof responseCtor)) {\n                try {\n                    response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                } catch (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n            }\n            self.emit(\"data\", response, method);\n            return callback(null, response);\n        });\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() {\n            callback(err);\n        }, 0);\n        return undefined;\n    }\n};\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */ Service.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUMsNkVBQWlCO0FBRXBDLHVCQUF1QjtBQUN0QkYsQ0FBQUEsUUFBUUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLEtBQUtLLFlBQVksQ0FBQ0gsU0FBUyxHQUFHSSxXQUFXLEdBQUdQO0FBRS9FOzs7Ozs7Ozs7O0NBVUMsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQSxRQUFRUSxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUI7SUFFekQsSUFBSSxPQUFPRixZQUFZLFlBQ25CLE1BQU1HLFVBQVU7SUFFcEJWLEtBQUtLLFlBQVksQ0FBQ00sSUFBSSxDQUFDLElBQUk7SUFFM0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDSixPQUFPLEdBQUdBO0lBRWY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0ksUUFBUUo7SUFFaEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0csUUFBUUg7QUFDckM7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RWLFFBQVFHLFNBQVMsQ0FBQ1csT0FBTyxHQUFHLFNBQVNBLFFBQVFDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUU3RixJQUFJLENBQUNELFNBQ0QsTUFBTVAsVUFBVTtJQUVwQixJQUFJUyxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNELFVBQ0QsT0FBT2xCLEtBQUtvQixTQUFTLENBQUNQLFNBQVNNLE1BQU1MLFFBQVFDLGFBQWFDLGNBQWNDO0lBRTVFLElBQUksQ0FBQ0UsS0FBS1osT0FBTyxFQUFFO1FBQ2ZjLFdBQVc7WUFBYUgsU0FBU0ksTUFBTTtRQUFtQixHQUFHO1FBQzdELE9BQU9DO0lBQ1g7SUFFQSxJQUFJO1FBQ0EsT0FBT0osS0FBS1osT0FBTyxDQUNmTyxRQUNBQyxXQUFXLENBQUNJLEtBQUtYLGdCQUFnQixHQUFHLG9CQUFvQixTQUFTLENBQUNTLFNBQVNPLE1BQU0sSUFDakYsU0FBU0MsWUFBWUMsR0FBRyxFQUFFQyxRQUFRO1lBRTlCLElBQUlELEtBQUs7Z0JBQ0xQLEtBQUtTLElBQUksQ0FBQyxTQUFTRixLQUFLWjtnQkFDeEIsT0FBT0ksU0FBU1E7WUFDcEI7WUFFQSxJQUFJQyxhQUFhLE1BQU07Z0JBQ25CUixLQUFLVSxHQUFHLENBQUMsY0FBYyxHQUFHO2dCQUMxQixPQUFPTjtZQUNYO1lBRUEsSUFBSSxDQUFFSSxDQUFBQSxvQkFBb0JYLFlBQVcsR0FBSTtnQkFDckMsSUFBSTtvQkFDQVcsV0FBV1gsWUFBWSxDQUFDRyxLQUFLVixpQkFBaUIsR0FBRyxvQkFBb0IsU0FBUyxDQUFDa0I7Z0JBQ25GLEVBQUUsT0FBT0QsS0FBSztvQkFDVlAsS0FBS1MsSUFBSSxDQUFDLFNBQVNGLEtBQUtaO29CQUN4QixPQUFPSSxTQUFTUTtnQkFDcEI7WUFDSjtZQUVBUCxLQUFLUyxJQUFJLENBQUMsUUFBUUQsVUFBVWI7WUFDNUIsT0FBT0ksU0FBUyxNQUFNUztRQUMxQjtJQUVSLEVBQUUsT0FBT0QsS0FBSztRQUNWUCxLQUFLUyxJQUFJLENBQUMsU0FBU0YsS0FBS1o7UUFDeEJPLFdBQVc7WUFBYUgsU0FBU1E7UUFBTSxHQUFHO1FBQzFDLE9BQU9IO0lBQ1g7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRHhCLFFBQVFHLFNBQVMsQ0FBQzJCLEdBQUcsR0FBRyxTQUFTQSxJQUFJQyxVQUFVO0lBQzNDLElBQUksSUFBSSxDQUFDdkIsT0FBTyxFQUFFO1FBQ2QsSUFBSSxDQUFDdUIsWUFDRCxJQUFJLENBQUN2QixPQUFPLENBQUMsTUFBTSxNQUFNO1FBQzdCLElBQUksQ0FBQ0EsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDcUIsSUFBSSxDQUFDLE9BQU9HLEdBQUc7SUFDeEI7SUFDQSxPQUFPLElBQUk7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcz9mYjAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiU2VydmljZSIsInV0aWwiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJycGNJbXBsIiwicmVxdWVzdERlbGltaXRlZCIsInJlc3BvbnNlRGVsaW1pdGVkIiwiVHlwZUVycm9yIiwiY2FsbCIsIkJvb2xlYW4iLCJycGNDYWxsIiwibWV0aG9kIiwicmVxdWVzdEN0b3IiLCJyZXNwb25zZUN0b3IiLCJyZXF1ZXN0IiwiY2FsbGJhY2siLCJzZWxmIiwiYXNQcm9taXNlIiwic2V0VGltZW91dCIsIkVycm9yIiwidW5kZWZpbmVkIiwiZmluaXNoIiwicnBjQ2FsbGJhY2siLCJlcnIiLCJyZXNwb25zZSIsImVtaXQiLCJlbmQiLCJlbmRlZEJ5UlBDIiwib2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/service.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/service.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\nvar Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/../node_modules/protobufjs/src/rpc.js\");\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */ function Service(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */ this.methods = {}; // toJSON, marker\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */ this._methodsArray = null;\n}\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */ /**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */ Service.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */ if (json.methods) for(var names = Object.keys(json.methods), i = 0; i < names.length; ++i)service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested) service.addJSON(json.nested);\n    if (json.edition) service._edition = json.edition;\n    service.comment = json.comment;\n    service._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return service;\n};\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */ Service.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"methods\",\n        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */ Object.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n/**\n * @override\n */ Service.prototype.get = function get(name) {\n    return this.methods[name] || Namespace.prototype.get.call(this, name);\n};\n/**\n * @override\n */ Service.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    Namespace.prototype.resolve.call(this);\n    var methods = this.methodsArray;\n    for(var i = 0; i < methods.length; ++i)methods[i].resolve();\n    return this;\n};\n/**\n * @override\n */ Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    edition = this._edition || edition;\n    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.methodsArray.forEach((method)=>{\n        method._resolveFeaturesRecursive(edition);\n    });\n    return this;\n};\n/**\n * @override\n */ Service.prototype.add = function add(object) {\n    /* istanbul ignore if */ if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * @override\n */ Service.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n        /* istanbul ignore if */ if (this.methods[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */ Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for(var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i){\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\n            \"r\",\n            \"c\"\n        ], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsUUFBUUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixPQUFNLEVBQUdPLFNBQVMsR0FBRztBQUU3RixJQUFJQyxTQUFTTixtQkFBT0EsQ0FBQyxnRUFBVSxHQUMzQk8sT0FBU1AsbUJBQU9BLENBQUMsNERBQVEsR0FDekJRLE1BQVNSLG1CQUFPQSxDQUFDLDBEQUFPO0FBRTVCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0YsUUFBUVcsSUFBSSxFQUFFQyxPQUFPO0lBQzFCWCxVQUFVWSxJQUFJLENBQUMsSUFBSSxFQUFFRixNQUFNQztJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLE9BQU8sR0FBRyxDQUFDLEdBQUcsaUJBQWlCO0lBRXBDOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLGFBQWEsR0FBRztBQUN6QjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RmLFFBQVFnQixRQUFRLEdBQUcsU0FBU0EsU0FBU0wsSUFBSSxFQUFFTSxJQUFJO0lBQzNDLElBQUlDLFVBQVUsSUFBSWxCLFFBQVFXLE1BQU1NLEtBQUtMLE9BQU87SUFDNUMsd0JBQXdCLEdBQ3hCLElBQUlLLEtBQUtILE9BQU8sRUFDWixJQUFLLElBQUlLLFFBQVFmLE9BQU9nQixJQUFJLENBQUNILEtBQUtILE9BQU8sR0FBR08sSUFBSSxHQUFHQSxJQUFJRixNQUFNRyxNQUFNLEVBQUUsRUFBRUQsRUFDbkVILFFBQVFLLEdBQUcsQ0FBQ2YsT0FBT1EsUUFBUSxDQUFDRyxLQUFLLENBQUNFLEVBQUUsRUFBRUosS0FBS0gsT0FBTyxDQUFDSyxLQUFLLENBQUNFLEVBQUUs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U0FBUyxJQUFJLENBQUNuQyxhQUFhLENBQUNNLEVBQUUsRUFBRXlCLE9BQU8sR0FBR25DLElBQUksRUFBRWtELE9BQU8sQ0FBQyxZQUFZO1FBQ25HSCxVQUFVLENBQUNDLFdBQVcsR0FBR2xELEtBQUtxRCxPQUFPLENBQUM7WUFBQztZQUFJO1NBQUksRUFBRXJELEtBQUtzRCxVQUFVLENBQUNKLGNBQWNBLGFBQWEsTUFBTUEsWUFBWSxrQ0FBa0M7WUFDNUlLLEdBQUdkO1lBQ0hlLEdBQUdmLE9BQU9nQixtQkFBbUIsQ0FBQ0MsSUFBSTtZQUNsQ0MsR0FBR2xCLE9BQU9tQixvQkFBb0IsQ0FBQ0YsSUFBSTtRQUN2QztJQUNKO0lBQ0EsT0FBT1Q7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9zZXJ2aWNlLmpzP2U5Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZSkuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKFwiLi9tZXRob2RcIiksXG4gICAgdXRpbCAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBycGMgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgc2VydmljZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gU2VydmljZSBvcHRpb25zXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFNlcnZpY2UgbWV0aG9kcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsTWV0aG9kPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZHMgPSB7fTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBtZXRob2RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtNZXRob2RbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElNZXRob2Q+fSBtZXRob2RzIE1ldGhvZCBkZXNjcmlwdG9yc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHNlcnZpY2UgZnJvbSBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtJU2VydmljZX0ganNvbiBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBDcmVhdGVkIHNlcnZpY2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cblNlcnZpY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGpzb24ubWV0aG9kcylcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm1ldGhvZHMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgc2VydmljZS5hZGQoTWV0aG9kLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm1ldGhvZHNbbmFtZXNbaV1dKSk7XG4gICAgaWYgKGpzb24ubmVzdGVkKVxuICAgICAgICBzZXJ2aWNlLmFkZEpTT04oanNvbi5uZXN0ZWQpO1xuICAgIGlmIChqc29uLmVkaXRpb24pXG4gICAgICAgIHNlcnZpY2UuX2VkaXRpb24gPSBqc29uLmVkaXRpb247XG4gICAgc2VydmljZS5jb21tZW50ID0ganNvbi5jb21tZW50O1xuICAgIHNlcnZpY2UuX2RlZmF1bHRFZGl0aW9uID0gXCJwcm90bzNcIjsgIC8vIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAgICByZXR1cm4gc2VydmljZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBzZXJ2aWNlIHRvIGEgc2VydmljZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVNlcnZpY2V9IFNlcnZpY2UgZGVzY3JpcHRvclxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwiZWRpdGlvblwiICwgdGhpcy5fZWRpdGlvblRvSlNPTigpLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibWV0aG9kc1wiICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMubWV0aG9kc0FycmF5LCB0b0pTT05PcHRpb25zKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fSxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZHMgb2YgdGhpcyBzZXJ2aWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBTZXJ2aWNlI21ldGhvZHNBcnJheVxuICogQHR5cGUge01ldGhvZFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtZXRob2RzQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2RzQXJyYXkgfHwgKHRoaXMuX21ldGhvZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm1ldGhvZHMpKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gY2xlYXJDYWNoZShzZXJ2aWNlKSB7XG4gICAgc2VydmljZS5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RzW25hbWVdXG4gICAgICAgIHx8IE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kc0FycmF5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSlcbiAgICAgICAgbWV0aG9kc1tpXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlID0gZnVuY3Rpb24gX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZShlZGl0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uKSByZXR1cm4gdGhpcztcblxuICAgIGVkaXRpb24gPSB0aGlzLl9lZGl0aW9uIHx8IGVkaXRpb247XG5cbiAgICBOYW1lc3BhY2UucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUuY2FsbCh0aGlzLCBlZGl0aW9uKTtcbiAgICB0aGlzLm1ldGhvZHNBcnJheS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgIG1ldGhvZC5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJ1bnRpbWUgc2VydmljZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJwYyBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBSUEMgc2VydmljZS4gVXNlZnVsIHdoZXJlIHJlcXVlc3RzIGFuZC9vciByZXNwb25zZXMgYXJlIHN0cmVhbWVkLlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcbiAgICB2YXIgcnBjU2VydmljZSA9IG5ldyBycGMuU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG1ldGhvZDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdXRpbC5sY0ZpcnN0KChtZXRob2QgPSB0aGlzLl9tZXRob2RzQXJyYXlbaV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcbiAgICAgICAgcnBjU2VydmljZVttZXRob2ROYW1lXSA9IHV0aWwuY29kZWdlbihbXCJyXCIsXCJjXCJdLCB1dGlsLmlzUmVzZXJ2ZWQobWV0aG9kTmFtZSkgPyBtZXRob2ROYW1lICsgXCJfXCIgOiBtZXRob2ROYW1lKShcInJldHVybiB0aGlzLnJwY0NhbGwobSxxLHMscixjKVwiKSh7XG4gICAgICAgICAgICBtOiBtZXRob2QsXG4gICAgICAgICAgICBxOiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jdG9yLFxuICAgICAgICAgICAgczogbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBycGNTZXJ2aWNlO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiU2VydmljZSIsIk5hbWVzcGFjZSIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIk1ldGhvZCIsInV0aWwiLCJycGMiLCJuYW1lIiwib3B0aW9ucyIsImNhbGwiLCJtZXRob2RzIiwiX21ldGhvZHNBcnJheSIsImZyb21KU09OIiwianNvbiIsInNlcnZpY2UiLCJuYW1lcyIsImtleXMiLCJpIiwibGVuZ3RoIiwiYWRkIiwibmVzdGVkIiwiYWRkSlNPTiIsImVkaXRpb24iLCJfZWRpdGlvbiIsImNvbW1lbnQiLCJfZGVmYXVsdEVkaXRpb24iLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwiaW5oZXJpdGVkIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwiX2VkaXRpb25Ub0pTT04iLCJ1bmRlZmluZWQiLCJhcnJheVRvSlNPTiIsIm1ldGhvZHNBcnJheSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidG9BcnJheSIsImNsZWFyQ2FjaGUiLCJyZXNvbHZlQWxsIiwiX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSIsInJlc29sdmUiLCJfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlIiwiX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24iLCJmb3JFYWNoIiwibWV0aG9kIiwib2JqZWN0IiwiRXJyb3IiLCJwYXJlbnQiLCJyZW1vdmUiLCJycGNJbXBsIiwicmVxdWVzdERlbGltaXRlZCIsInJlc3BvbnNlRGVsaW1pdGVkIiwicnBjU2VydmljZSIsIm1ldGhvZE5hbWUiLCJsY0ZpcnN0IiwicmVwbGFjZSIsImNvZGVnZW4iLCJpc1Jlc2VydmVkIiwibSIsInEiLCJyZXNvbHZlZFJlcXVlc3RUeXBlIiwiY3RvciIsInMiLCJyZXNvbHZlZFJlc3BvbnNlVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/service.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/tokenize.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/tokenize.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g, stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g, stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\\s*\\*?\\/*/, setCommentSplitRe = /\\n/g, whitespaceRe = /\\s/, unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n    \"0\": \"\\x00\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\t\"\n};\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */ function unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch($1){\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\ntokenize.unescape = unescape;\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */ /**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */ /**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */ /**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */ /**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */ function tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */ source = source.toString();\n    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};\n    var stack = [];\n    var stringDelim = null;\n    /* istanbul ignore next */ /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */ function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */ function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match) throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */ function charAt(pos) {\n        return source.charAt(pos);\n    }\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */ function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3; // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback, c;\n        do {\n            if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        }while (c === \" \" || c === \"\t\");\n        var lines = source.substring(start, end).split(setCommentSplitRe);\n        for(var i = 0; i < lines.length; ++i)lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n        comment.text = lines.join(\"\\n\").trim();\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while(endOffset < length && charAt(endOffset) !== \"\\n\"){\n            endOffset++;\n        }\n        return endOffset;\n    }\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */ function next() {\n        if (stack.length > 0) return stack.shift();\n        if (stringDelim) return readString();\n        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;\n        do {\n            if (offset === length) return null;\n            repeat = false;\n            while(whitespaceRe.test(curr = charAt(offset))){\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length) return null;\n            }\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") {\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n                        while(charAt(++offset) !== \"\\n\"){\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    break;\n                                }\n                            }while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") {\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    }while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        }while (repeat);\n        // offset !== length if we got here\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim) while(end < length && !delimRe.test(charAt(end)))++end;\n        var token = source.substring(offset, offset = end);\n        if (token === '\"' || token === \"'\") stringDelim = token;\n        return token;\n    }\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */ function push(token) {\n        stack.push(token);\n    }\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */ function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null) return null;\n            push(token);\n        }\n        return stack[0];\n    }\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */ function skip(expected, optional) {\n        var actual = peek(), equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */ function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */ if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() {\n            return line;\n        }\n    });\n/* eslint-enable callback-return */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Rva2VuaXplLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsVUFBaUIsd0JBQ2pCQyxpQkFBaUIsbUNBQ2pCQyxpQkFBaUI7QUFFckIsSUFBSUMsZUFBZSxjQUNmQyxrQkFBa0IsY0FDbEJDLG9CQUFvQixPQUNwQkMsZUFBZSxNQUNmQyxhQUFhO0FBRWpCLElBQUlDLGNBQWM7SUFDZCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHO0lBQ2pCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQ0osWUFBWSxTQUFTSyxFQUFFLEVBQUVDLEVBQUU7UUFDMUMsT0FBUUE7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPQTtZQUNYO2dCQUNJLE9BQU9MLFdBQVcsQ0FBQ0ssR0FBRyxJQUFJO1FBQ2xDO0lBQ0o7QUFDSjtBQUVBZCxTQUFTVSxRQUFRLEdBQUdBO0FBRXBCOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUVEOzs7OztDQUtDLEdBQ0QsU0FBU1YsU0FBU2UsTUFBTSxFQUFFQyxvQkFBb0I7SUFDMUMsa0NBQWtDLEdBQ2xDRCxTQUFTQSxPQUFPRSxRQUFRO0lBRXhCLElBQUlDLFNBQVMsR0FDVEMsU0FBU0osT0FBT0ksTUFBTSxFQUN0QkMsT0FBTyxHQUNQQyxrQkFBa0IsR0FDbEJDLFdBQVcsQ0FBQztJQUVoQixJQUFJQyxRQUFRLEVBQUU7SUFFZCxJQUFJQyxjQUFjO0lBRWxCLHdCQUF3QixHQUN4Qjs7Ozs7S0FLQyxHQUNELFNBQVNDLFFBQVFDLE9BQU87UUFDcEIsT0FBT0MsTUFBTSxhQUFhRCxVQUFVLFlBQVlOLE9BQU87SUFDM0Q7SUFF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QUFJLENBQUNjLFVBQ0QsTUFBTW5ELFFBQVEsWUFBWW9ELFNBQVMsU0FBU0YsV0FBVztRQUMzRCxPQUFPO0lBQ1g7SUFFQTs7Ozs7S0FLQyxHQUNELFNBQVNJLEtBQUtDLFlBQVk7UUFDdEIsSUFBSUMsTUFBTTtRQUNWLElBQUl6QztRQUNKLElBQUl3QyxpQkFBaUJFLFdBQVc7WUFDNUIxQyxVQUFVbEIsUUFBUSxDQUFDRixPQUFPLEVBQUU7WUFDNUIsT0FBT0UsUUFBUSxDQUFDRixPQUFPLEVBQUU7WUFDekIsSUFBSW9CLFdBQVl4QixDQUFBQSx3QkFBd0J3QixRQUFRQyxJQUFJLEtBQUssT0FBT0QsUUFBUUUsU0FBUyxHQUFHO2dCQUNoRnVDLE1BQU16QyxRQUFRRyxPQUFPLEdBQUdILFFBQVFZLElBQUksR0FBRztZQUMzQztRQUNKLE9BQU87WUFDSCx3QkFBd0IsR0FDeEIsSUFBSS9CLGtCQUFrQjJELGNBQWM7Z0JBQ2hDUDtZQUNKO1lBQ0FqQyxVQUFVbEIsUUFBUSxDQUFDMEQsYUFBYTtZQUNoQyxPQUFPMUQsUUFBUSxDQUFDMEQsYUFBYTtZQUM3QixJQUFJeEMsV0FBVyxDQUFDQSxRQUFRRSxTQUFTLElBQUsxQixDQUFBQSx3QkFBd0J3QixRQUFRQyxJQUFJLEtBQUssR0FBRSxHQUFJO2dCQUNqRndDLE1BQU16QyxRQUFRRyxPQUFPLEdBQUcsT0FBT0gsUUFBUVksSUFBSTtZQUMvQztRQUNKO1FBQ0EsT0FBTzZCO0lBQ1g7SUFFQSxPQUFPRSxPQUFPQyxjQUFjLENBQUM7UUFDekJ0QixNQUFNQTtRQUNOVyxNQUFNQTtRQUNOeEMsTUFBTUE7UUFDTnlDLE1BQU1BO1FBQ05LLE1BQU1BO0lBQ1YsR0FBRyxRQUFRO1FBQ1BNLEtBQUs7WUFBYSxPQUFPakU7UUFBTTtJQUNuQztBQUNBLGlDQUFpQyxHQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90b2tlbml6ZS5qcz82MGU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB0b2tlbml6ZTtcblxudmFyIGRlbGltUmUgICAgICAgID0gL1tcXHN7fT07OltcXF0sJ1wiKCk8Pl0vZyxcbiAgICBzdHJpbmdEb3VibGVSZSA9IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXG4gICAgc3RyaW5nU2luZ2xlUmUgPSAvKD86JyhbXidcXFxcXSooPzpcXFxcLlteJ1xcXFxdKikqKScpL2c7XG5cbnZhciBzZXRDb21tZW50UmUgPSAvXiAqWyovXSsgKi8sXG4gICAgc2V0Q29tbWVudEFsdFJlID0gL15cXHMqXFwqP1xcLyovLFxuICAgIHNldENvbW1lbnRTcGxpdFJlID0gL1xcbi9nLFxuICAgIHdoaXRlc3BhY2VSZSA9IC9cXHMvLFxuICAgIHVuZXNjYXBlUmUgPSAvXFxcXCguPykvZztcblxudmFyIHVuZXNjYXBlTWFwID0ge1xuICAgIFwiMFwiOiBcIlxcMFwiLFxuICAgIFwiclwiOiBcIlxcclwiLFxuICAgIFwiblwiOiBcIlxcblwiLFxuICAgIFwidFwiOiBcIlxcdFwiXG59O1xuXG4vKipcbiAqIFVuZXNjYXBlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHVuZXNjYXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVbmVzY2FwZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IG1hcCBTcGVjaWFsIGNoYXJhY3RlcnMgbWFwXG4gKiBAbWVtYmVyb2YgdG9rZW5pemVcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVuZXNjYXBlUmUsIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgICBzd2l0Y2ggKCQxKSB7XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZXNjYXBlTWFwWyQxXSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnRva2VuaXplLnVuZXNjYXBlID0gdW5lc2NhcGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMuXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVOZXh0XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICovXG5cbi8qKlxuICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUGVla1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAqL1xuXG4vKipcbiAqIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUHVzaFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgdG9rZW4uXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVTa2lwXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsPWZhbHNlXSBJZiBvcHRpb25hbFxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIG1hdGNoZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdG9rZW4gZGlkbid0IG1hdGNoIGFuZCBpcyBub3Qgb3B0aW9uYWxcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IsIGFsdGVybmF0aXZlbHksIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlQ21udFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lXSBMaW5lIG51bWJlclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHQgb3IgYG51bGxgIGlmIG5vbmVcbiAqL1xuXG4vKipcbiAqIEhhbmRsZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgdG9rZW5pemV9LlxuICogQGludGVyZmFjZSBJVG9rZW5pemVySGFuZGxlXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZU5leHR9IG5leHQgR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgKGBudWxsYCBvbiBlb2YpXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVBlZWt9IHBlZWsgUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuIChgbnVsbGAgb24gZW9mKVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVQdXNofSBwdXNoIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVNraXB9IHNraXAgU2tpcHMgYSB0b2tlbiwgcmV0dXJucyBpdHMgcHJlc2VuY2UgYW5kIGFkdmFuY2VzIG9yLCBpZiBub24tb3B0aW9uYWwgYW5kIG5vdCBwcmVzZW50LCB0aHJvd3NcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlQ21udH0gY21udCBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lIEN1cnJlbnQgbGluZSBudW1iZXJcbiAqL1xuXG4vKipcbiAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtib29sZWFufSBhbHRlcm5hdGVDb21tZW50TW9kZSBXaGV0aGVyIHdlIHNob3VsZCBhY3RpdmF0ZSBhbHRlcm5hdGUgY29tbWVudCBwYXJzaW5nIG1vZGUuXG4gKiBAcmV0dXJucyB7SVRva2VuaXplckhhbmRsZX0gVG9rZW5pemVyIGhhbmRsZVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXG4gICAgc291cmNlID0gc291cmNlLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aCxcbiAgICAgICAgbGluZSA9IDEsXG4gICAgICAgIGxhc3RDb21tZW50TGluZSA9IDAsXG4gICAgICAgIGNvbW1lbnRzID0ge307XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgIHZhciBzdHJpbmdEZWxpbSA9IG51bGw7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgZm9yIGlsbGVnYWwgc3ludGF4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqZWN0IFN1YmplY3RcbiAgICAgKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIGNyZWF0ZWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHN1YmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIHN1YmplY3QgKyBcIiAobGluZSBcIiArIGxpbmUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBzdHJpbmcgdGlsbCBpdHMgZW5kLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHJlID0gc3RyaW5nRGVsaW0gPT09IFwiJ1wiID8gc3RyaW5nU2luZ2xlUmUgOiBzdHJpbmdEb3VibGVSZTtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhzb3VyY2UpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInN0cmluZ1wiKTtcbiAgICAgICAgb2Zmc2V0ID0gcmUubGFzdEluZGV4O1xuICAgICAgICBwdXNoKHN0cmluZ0RlbGltKTtcbiAgICAgICAgc3RyaW5nRGVsaW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUobWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciBhdCBgcG9zYCB3aXRoaW4gdGhlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIFBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ2hhcmFjdGVyXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhckF0KHBvcykge1xuICAgICAgICByZXR1cm4gc291cmNlLmNoYXJBdChwb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgY29tbWVudCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVhZGluZyBzZXQgaWYgYSBsZWFkaW5nIGNvbW1lbnRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENvbW1lbnQoc3RhcnQsIGVuZCwgaXNMZWFkaW5nKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogc291cmNlLmNoYXJBdChzdGFydCsrKSxcbiAgICAgICAgICAgIGxpbmVFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBsZWFkaW5nOiBpc0xlYWRpbmcsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb29rYmFjaztcbiAgICAgICAgaWYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgICAgICAgICBsb29rYmFjayA9IDI7ICAvLyBhbHRlcm5hdGUgY29tbWVudCBwYXJzaW5nOiBcIi8vXCIgb3IgXCIvKlwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29rYmFjayA9IDM7ICAvLyBcIi8vL1wiIG9yIFwiLyoqXCJcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tbWVudE9mZnNldCA9IHN0YXJ0IC0gbG9va2JhY2ssXG4gICAgICAgICAgICBjO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoLS1jb21tZW50T2Zmc2V0IDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAoYyA9IHNvdXJjZS5jaGFyQXQoY29tbWVudE9mZnNldCkpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudC5saW5lRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiKTtcbiAgICAgICAgdmFyIGxpbmVzID0gc291cmNlXG4gICAgICAgICAgICAuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAuc3BsaXQoc2V0Q29tbWVudFNwbGl0UmUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGFsdGVybmF0ZUNvbW1lbnRNb2RlID8gc2V0Q29tbWVudEFsdFJlIDogc2V0Q29tbWVudFJlLCBcIlwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIGNvbW1lbnQudGV4dCA9IGxpbmVzXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgLnRyaW0oKTtcblxuICAgICAgICBjb21tZW50c1tsaW5lXSA9IGNvbW1lbnQ7XG4gICAgICAgIGxhc3RDb21tZW50TGluZSA9IGxpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lKHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmaW5kRW5kT2ZMaW5lKHN0YXJ0T2Zmc2V0KTtcblxuICAgICAgICAvLyBzZWUgaWYgcmVtYWluaW5nIGxpbmUgbWF0Y2hlcyBjb21tZW50IHBhdHRlcm5cbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gc291cmNlLnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgdmFyIGlzQ29tbWVudCA9IC9eXFxzKlxcL1xcLy8udGVzdChsaW5lVGV4dCk7XG4gICAgICAgIHJldHVybiBpc0NvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEVuZE9mTGluZShjdXJzb3IpIHtcbiAgICAgICAgLy8gZmluZCBlbmQgb2YgY3Vyc29yJ3MgbGluZVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gY3Vyc29yO1xuICAgICAgICB3aGlsZSAoZW5kT2Zmc2V0IDwgbGVuZ3RoICYmIGNoYXJBdChlbmRPZmZzZXQpICE9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zaGlmdCgpO1xuICAgICAgICBpZiAoc3RyaW5nRGVsaW0pXG4gICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZygpO1xuICAgICAgICB2YXIgcmVwZWF0LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIGN1cnIsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGlzRG9jLFxuICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IG9mZnNldCA9PT0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAod2hpdGVzcGFjZVJlLnRlc3QoY3VyciA9IGNoYXJBdChvZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYXJBdChvZmZzZXQpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7IC8vIExpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRyaXBsZS1zbGFzaCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGNoYXJBdChzdGFydCA9IG9mZnNldCArIDEpID09PSBcIi9cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJBdCgrK29mZnNldCkgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQgLSAxLCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFpbGluZyBjb21tZW50IGNhbm5vdCBub3QgYmUgbXVsdGktbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBsZWFkaW5nIGNvbW1lbnQgc3RhdGUgc2hvdWxkIGJlIHJlc2V0IHRvIGhhbmRsZSBwb3RlbnRpYWwgbmV4dCBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkb3VibGUtc2xhc2ggY29tbWVudHMsIGNvbnNvbGlkYXRpbmcgY29uc2VjdXRpdmUgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBmaW5kRW5kT2ZMaW5lKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNMZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhaWxpbmcgY29tbWVudCBjYW5ub3Qgbm90IGJlIG11bHRpLWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lKG9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIGZpbmRFbmRPZkxpbmUob2Zmc2V0KSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0LCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjdXJyID0gY2hhckF0KG9mZnNldCkpID09PSBcIipcIikgeyAvKiBCbG9jayAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgLyoqIChyZWd1bGFyIGNvbW1lbnQgbW9kZSkgb3IgLyogKGFsdGVybmF0ZSBjb21tZW50IG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjaGFyQXQoc3RhcnQpID09PSBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY2hhckF0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgIT09IFwiKlwiIHx8IGN1cnIgIT09IFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0IC0gMiwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XG5cbiAgICAgICAgLy8gb2Zmc2V0ICE9PSBsZW5ndGggaWYgd2UgZ290IGhlcmVcblxuICAgICAgICB2YXIgZW5kID0gb2Zmc2V0O1xuICAgICAgICBkZWxpbVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBkZWxpbSA9IGRlbGltUmUudGVzdChjaGFyQXQoZW5kKyspKTtcbiAgICAgICAgaWYgKCFkZWxpbSlcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGggJiYgIWRlbGltUmUudGVzdChjaGFyQXQoZW5kKSkpXG4gICAgICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgIHZhciB0b2tlbiA9IHNvdXJjZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgPSBlbmQpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIilcbiAgICAgICAgICAgIHN0cmluZ0RlbGltID0gdG9rZW47XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1c2godG9rZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcHMgYSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gV2hldGhlciB0aGUgdG9rZW4gaXMgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiBub3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiBhIHJlcXVpcmVkIHRva2VuIGlzIG5vdCBwcmVzZW50XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2tpcChleHBlY3RlZCwgb3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGFjdHVhbCA9IHBlZWsoKSxcbiAgICAgICAgICAgIGVxdWFscyA9IGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIGlmIChlcXVhbHMpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwidG9rZW4gJ1wiICsgYWN0dWFsICsgXCInLCAnXCIgKyBleHBlY3RlZCArIFwiJyBleHBlY3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb21tZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHJhaWxpbmdMaW5lXSBMaW5lIG51bWJlciBpZiBsb29raW5nIGZvciBhIHRyYWlsaW5nIGNvbW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IENvbW1lbnQgdGV4dFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNtbnQodHJhaWxpbmdMaW5lKSB7XG4gICAgICAgIHZhciByZXQgPSBudWxsO1xuICAgICAgICB2YXIgY29tbWVudDtcbiAgICAgICAgaWYgKHRyYWlsaW5nTGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbbGluZSAtIDFdO1xuICAgICAgICAgICAgZGVsZXRlIGNvbW1lbnRzW2xpbmUgLSAxXTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ICYmIChhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjb21tZW50LnR5cGUgPT09IFwiKlwiIHx8IGNvbW1lbnQubGluZUVtcHR5KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnQubGVhZGluZyA/IGNvbW1lbnQudGV4dCA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGxhc3RDb21tZW50TGluZSA8IHRyYWlsaW5nTGluZSkge1xuICAgICAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1t0cmFpbGluZ0xpbmVdO1xuICAgICAgICAgICAgZGVsZXRlIGNvbW1lbnRzW3RyYWlsaW5nTGluZV07XG4gICAgICAgICAgICBpZiAoY29tbWVudCAmJiAhY29tbWVudC5saW5lRW1wdHkgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnQudHlwZSA9PT0gXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tbWVudC5sZWFkaW5nID8gbnVsbCA6IGNvbW1lbnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICBuZXh0OiBuZXh0LFxuICAgICAgICBwZWVrOiBwZWVrLFxuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBza2lwOiBza2lwLFxuICAgICAgICBjbW50OiBjbW50XG4gICAgfSwgXCJsaW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmU7IH1cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbGxiYWNrLXJldHVybiAqL1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ0b2tlbml6ZSIsImRlbGltUmUiLCJzdHJpbmdEb3VibGVSZSIsInN0cmluZ1NpbmdsZVJlIiwic2V0Q29tbWVudFJlIiwic2V0Q29tbWVudEFsdFJlIiwic2V0Q29tbWVudFNwbGl0UmUiLCJ3aGl0ZXNwYWNlUmUiLCJ1bmVzY2FwZVJlIiwidW5lc2NhcGVNYXAiLCJ1bmVzY2FwZSIsInN0ciIsInJlcGxhY2UiLCIkMCIsIiQxIiwic291cmNlIiwiYWx0ZXJuYXRlQ29tbWVudE1vZGUiLCJ0b1N0cmluZyIsIm9mZnNldCIsImxlbmd0aCIsImxpbmUiLCJsYXN0Q29tbWVudExpbmUiLCJjb21tZW50cyIsInN0YWNrIiwic3RyaW5nRGVsaW0iLCJpbGxlZ2FsIiwic3ViamVjdCIsIkVycm9yIiwicmVhZFN0cmluZyIsInJlIiwibGFzdEluZGV4IiwibWF0Y2giLCJleGVjIiwicHVzaCIsImNoYXJBdCIsInBvcyIsInNldENvbW1lbnQiLCJzdGFydCIsImVuZCIsImlzTGVhZGluZyIsImNvbW1lbnQiLCJ0eXBlIiwibGluZUVtcHR5IiwibGVhZGluZyIsImxvb2tiYWNrIiwiY29tbWVudE9mZnNldCIsImMiLCJsaW5lcyIsInN1YnN0cmluZyIsInNwbGl0IiwiaSIsInRyaW0iLCJ0ZXh0Iiwiam9pbiIsImlzRG91YmxlU2xhc2hDb21tZW50TGluZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiZmluZEVuZE9mTGluZSIsImxpbmVUZXh0IiwiaXNDb21tZW50IiwidGVzdCIsImN1cnNvciIsIm5leHQiLCJzaGlmdCIsInJlcGVhdCIsInByZXYiLCJjdXJyIiwiaXNEb2MiLCJpc0xlYWRpbmdDb21tZW50IiwiTWF0aCIsIm1pbiIsImRlbGltIiwidG9rZW4iLCJwZWVrIiwic2tpcCIsImV4cGVjdGVkIiwib3B0aW9uYWwiLCJhY3R1YWwiLCJlcXVhbHMiLCJjbW50IiwidHJhaWxpbmdMaW5lIiwicmV0IiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/tokenize.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/type.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/type.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Type;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\"), Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\"), Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\"), Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/../node_modules/protobufjs/src/encoder.js\"), decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../node_modules/protobufjs/src/decoder.js\"), verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/../node_modules/protobufjs/src/verifier.js\"), converter = __webpack_require__(/*! ./converter */ \"(ssr)/../node_modules/protobufjs/src/converter.js\"), wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/../node_modules/protobufjs/src/wrappers.js\");\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */ function Type(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */ this.fields = {}; // toJSON, marker\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */ this.oneofs = undefined; // toJSON\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */ this.extensions = undefined; // toJSON\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */ this.group = undefined; // toJSON\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */ this._fieldsById = null;\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */ this._fieldsArray = null;\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */ this._oneofsArray = null;\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */ this._ctor = null;\n}\nObject.defineProperties(Type.prototype, {\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */ fieldsById: {\n        get: function() {\n            /* istanbul ignore if */ if (this._fieldsById) return this._fieldsById;\n            this._fieldsById = {};\n            for(var names = Object.keys(this.fields), i = 0; i < names.length; ++i){\n                var field = this.fields[names[i]], id = field.id;\n                /* istanbul ignore if */ if (this._fieldsById[id]) throw Error(\"duplicate id \" + id + \" in \" + this);\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */ fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */ oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */ ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n            this._ctor = ctor;\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for(; i < /* initializes */ this.fieldsArray.length; ++i)this._fieldsArray[i].resolve(); // ensures a proper value\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for(i = 0; i < /* initializes */ this.oneofsArray.length; ++i)ctorProperties[this._oneofsArray[i].resolve().name] = {\n                get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                set: util.oneOfSetter(this._oneofsArray[i].oneof)\n            };\n            if (i) Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ Type.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"p\"\n    ], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for(var i = 0, field; i < mtype.fieldsArray.length; ++i)if ((field = mtype._fieldsArray[i]).map) gen(\"this%s={}\", util.safeProp(field.name));\n    else if (field.repeated) gen(\"this%s=[]\", util.safeProp(field.name));\n    return gen(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n    (\"this[ks[i]]=p[ks[i]]\");\n/* eslint-enable no-unexpected-multiline */ };\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */ /**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */ Type.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields), i = 0;\n    for(; i < names.length; ++i)type.add((typeof json.fields[names[i]].keyType !== \"undefined\" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));\n    if (json.oneofs) for(names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested) for(names = Object.keys(json.nested), i = 0; i < names.length; ++i){\n        var nested = json.nested[names[i]];\n        type.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n    if (json.extensions && json.extensions.length) type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length) type.reserved = json.reserved;\n    if (json.group) type.group = true;\n    if (json.comment) type.comment = json.comment;\n    if (json.edition) type._edition = json.edition;\n    type._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return type;\n};\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */ Type.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"oneofs\",\n        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\",\n        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {\n            return !obj.declaringField;\n        }), toJSONOptions) || {},\n        \"extensions\",\n        this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\",\n        this.group || undefined,\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ Type.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    Namespace.prototype.resolveAll.call(this);\n    var oneofs = this.oneofsArray;\n    i = 0;\n    while(i < oneofs.length)oneofs[i++].resolve();\n    var fields = this.fieldsArray, i = 0;\n    while(i < fields.length)fields[i++].resolve();\n    return this;\n};\n/**\n * @override\n */ Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    edition = this._edition || edition;\n    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.oneofsArray.forEach((oneof)=>{\n        oneof._resolveFeatures(edition);\n    });\n    this.fieldsArray.forEach((field)=>{\n        field._resolveFeatures(edition);\n    });\n    return this;\n};\n/**\n * @override\n */ Type.prototype.get = function get(name) {\n    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;\n};\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */ Type.prototype.add = function add(object) {\n    if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id)) throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name)) throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n        if (object.parent) object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs) this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */ Type.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n        /* istanbul ignore if */ if (!this.fields || this.fields[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        /* istanbul ignore if */ if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */ Type.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */ Type.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n    var fullName = this.fullName, types = [];\n    for(var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)types.push(this._fieldsArray[i].resolve().resolvedType);\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer: Writer,\n        types: types,\n        util: util\n    });\n    this.decode = decoder(this)({\n        Reader: Reader,\n        types: types,\n        util: util\n    });\n    this.verify = verifier(this)({\n        types: types,\n        util: util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types: types,\n        util: util\n    });\n    this.toObject = converter.toObject(this)({\n        types: types,\n        util: util\n    });\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n        originalThis.fromObject = this.fromObject;\n        this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n        originalThis.toObject = this.toObject;\n        this.toObject = wrapper.toObject.bind(originalThis);\n    // }\n    }\n    return this;\n};\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */ Type.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */ Type.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader)) reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */ Type.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */ Type.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */ /**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */ Type.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */ /**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */ Type.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsS0FBS0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUV2RixJQUFJQyxPQUFZTixtQkFBT0EsQ0FBQyw0REFBUSxHQUM1Qk8sUUFBWVAsbUJBQU9BLENBQUMsOERBQVMsR0FDN0JRLFFBQVlSLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzdCUyxXQUFZVCxtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ1UsVUFBWVYsbUJBQU9BLENBQUMsa0VBQVcsR0FDL0JXLFVBQVlYLG1CQUFPQSxDQUFDLGtFQUFXLEdBQy9CWSxTQUFZWixtQkFBT0EsQ0FBQyxnRUFBVSxHQUM5QmEsU0FBWWIsbUJBQU9BLENBQUMsZ0VBQVUsR0FDOUJjLE9BQVlkLG1CQUFPQSxDQUFDLDREQUFRLEdBQzVCZSxVQUFZZixtQkFBT0EsQ0FBQyxrRUFBVyxHQUMvQmdCLFVBQVloQixtQkFBT0EsQ0FBQyxrRUFBVyxHQUMvQmlCLFdBQVlqQixtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ2tCLFlBQVlsQixtQkFBT0EsQ0FBQyxzRUFBYSxHQUNqQ21CLFdBQVluQixtQkFBT0EsQ0FBQyxvRUFBWTtBQUVwQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0YsS0FBS3NCLElBQUksRUFBRUMsT0FBTztJQUN2QnRCLFVBQVV1QixJQUFJLENBQUMsSUFBSSxFQUFFRixNQUFNQztJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLE1BQU0sR0FBRyxDQUFDLEdBQUksaUJBQWlCO0lBRXBDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHQyxXQUFXLFNBQVM7SUFF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ZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcz82ZmE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFR5cGUpLmNsYXNzTmFtZSA9IFwiVHlwZVwiO1xuXG52YXIgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1lc3NhZ2UgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIiksXG4gICAgUmVhZGVyICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpLFxuICAgIFdyaXRlciAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIGVuY29kZXIgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIiksXG4gICAgZGVjb2RlciAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKSxcbiAgICB2ZXJpZmllciAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKSxcbiAgICBjb252ZXJ0ZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIiksXG4gICAgd3JhcHBlcnMgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0ZWQgbWVzc2FnZSB0eXBlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSB0eXBlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFR5cGUobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWVsZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLEZpZWxkPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkcyA9IHt9OyAgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBkZWNsYXJlZCB3aXRoaW4gdGhpcyBuYW1lc3BhY2UsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsT25lT2Y+fVxuICAgICAqL1xuICAgIHRoaXMub25lb2ZzID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbiByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyW11bXX1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyo/XG4gICAgICogV2hldGhlciB0aGlzIHR5cGUgaXMgYSBsZWdhY3kgZ3JvdXAuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBmaWVsZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge0ZpZWxkW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBvbmVvZnMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge09uZU9mW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uZW9mc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3RvciA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFR5cGUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0J5SWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZpZWxkc0J5SWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcblxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZmllbGQuaWQ7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZFtpZF0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZFtpZF0gPSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0FycmF5XG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNBcnJheSB8fCAodGhpcy5fZmllbGRzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5maWVsZHMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbmVvZnMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQG5hbWUgVHlwZSNvbmVvZnNBcnJheVxuICAgICAqIEB0eXBlIHtPbmVPZltdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIG9uZW9mc0FycmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lb2ZzQXJyYXkgfHwgKHRoaXMuX29uZW9mc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMub25lb2ZzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IsIGlmIGFueSByZWdpc3RlcmVkLCBvdGhlcndpc2UgYSBnZW5lcmljIGNvbnN0cnVjdG9yLlxuICAgICAqIEFzc2lnbmluZyBhIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGV4dGVuZCB7QGxpbmsgTWVzc2FnZX0geWV0LCBpdHMgcHJvdG90eXBlIHdpbGwgYmUgc2V0dXAgYWNjb3JkaW5nbHkgYW5kIHN0YXRpYyBtZXRob2RzIHdpbGwgYmUgcG9wdWxhdGVkLiBJZiBpdCBhbHJlYWR5IGV4dGVuZHMge0BsaW5rIE1lc3NhZ2V9LCBpdCB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29uc3RydWN0b3IuXG4gICAgICogQG5hbWUgVHlwZSNjdG9yXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cbiAgICAgKi9cbiAgICBjdG9yOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3RvciB8fCAodGhpcy5jdG9yID0gVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yKHRoaXMpKCkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgKGN0b3IucHJvdG90eXBlID0gbmV3IE1lc3NhZ2UoKSkuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UoY3Rvci5wcm90b3R5cGUsIHByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsYXNzZXMgYW5kIG1lc3NhZ2VzIHJlZmVyZW5jZSB0aGVpciByZWZsZWN0ZWQgdHlwZVxuICAgICAgICAgICAgY3Rvci4kdHlwZSA9IGN0b3IucHJvdG90eXBlLiR0eXBlID0gdGhpcztcblxuICAgICAgICAgICAgLy8gTWl4IGluIHN0YXRpYyBtZXRob2RzXG4gICAgICAgICAgICB1dGlsLm1lcmdlKGN0b3IsIE1lc3NhZ2UsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jdG9yID0gY3RvcjtcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBkZWZhdWx0IHZhbHVlcyBvbiB0aGVpciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCk7IC8vIGVuc3VyZXMgYSBwcm9wZXIgdmFsdWVcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBlYWNoIHZpcnR1YWwgb25lb2YgZmllbGRcbiAgICAgICAgICAgIHZhciBjdG9yUHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3RvclByb3BlcnRpZXNbdGhpcy5fb25lb2ZzQXJyYXlbaV0ucmVzb2x2ZSgpLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN0b3IucHJvdG90eXBlLCBjdG9yUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cblR5cGUuZ2VuZXJhdGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RydWN0b3IobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wicFwiXSwgbXR5cGUubmFtZSk7XG4gICAgLy8gZXhwbGljaXRseSBpbml0aWFsaXplIG11dGFibGUgb2JqZWN0L2FycmF5IGZpZWxkcyBzbyB0aGF0IHRoZXNlIGFyZW4ndCBqdXN0IGluaGVyaXRlZCBmcm9tIHRoZSBwcm90b3R5cGVcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXSkubWFwKSBnZW5cbiAgICAgICAgICAgIChcInRoaXMlcz17fVwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPVtdXCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgIHJldHVybiBnZW5cbiAgICAoXCJpZihwKWZvcih2YXIga3M9T2JqZWN0LmtleXMocCksaT0wO2k8a3MubGVuZ3RoOysraSlpZihwW2tzW2ldXSE9bnVsbClcIikgLy8gb21pdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAoXCJ0aGlzW2tzW2ldXT1wW2tzW2ldXVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59O1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHR5cGUpIHtcbiAgICB0eXBlLl9maWVsZHNCeUlkID0gdHlwZS5fZmllbGRzQXJyYXkgPSB0eXBlLl9vbmVvZnNBcnJheSA9IG51bGw7XG4gICAgZGVsZXRlIHR5cGUuZW5jb2RlO1xuICAgIGRlbGV0ZSB0eXBlLmRlY29kZTtcbiAgICBkZWxldGUgdHlwZS52ZXJpZnk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElUeXBlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElPbmVPZj59IFtvbmVvZnNdIE9uZW9mIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElGaWVsZD59IGZpZWxkcyBGaWVsZCBkZXNjcmlwdG9yc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbZXh0ZW5zaW9uc10gRXh0ZW5zaW9uIHJhbmdlc1xuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyW118c3RyaW5nPn0gW3Jlc2VydmVkXSBSZXNlcnZlZCByYW5nZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwPWZhbHNlXSBXaGV0aGVyIGEgbGVnYWN5IGdyb3VwIG9yIG5vdFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1lc3NhZ2UgdHlwZSBmcm9tIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7SVR5cGV9IGpzb24gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtUeXBlfSBDcmVhdGVkIG1lc3NhZ2UgdHlwZVxuICovXG5UeXBlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSwganNvbi5vcHRpb25zKTtcbiAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgdHlwZS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5maWVsZHMpLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICB0eXBlLmFkZChcbiAgICAgICAgICAgICggdHlwZW9mIGpzb24uZmllbGRzW25hbWVzW2ldXS5rZXlUeXBlICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IE1hcEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICA6IEZpZWxkLmZyb21KU09OICkobmFtZXNbaV0sIGpzb24uZmllbGRzW25hbWVzW2ldXSlcbiAgICAgICAgKTtcbiAgICBpZiAoanNvbi5vbmVvZnMpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm9uZW9mcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChPbmVPZi5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5vbmVvZnNbbmFtZXNbaV1dKSk7XG4gICAgaWYgKGpzb24ubmVzdGVkKVxuICAgICAgICBmb3IgKG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5uZXN0ZWQpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkID0ganNvbi5uZXN0ZWRbbmFtZXNbaV1dO1xuICAgICAgICAgICAgdHlwZS5hZGQoIC8vIG1vc3QgdG8gbGVhc3QgbGlrZWx5XG4gICAgICAgICAgICAgICAgKCBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBOYW1lc3BhY2UuZnJvbUpTT04gKShuYW1lc1tpXSwgbmVzdGVkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIGlmIChqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zLmxlbmd0aClcbiAgICAgICAgdHlwZS5leHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zO1xuICAgIGlmIChqc29uLnJlc2VydmVkICYmIGpzb24ucmVzZXJ2ZWQubGVuZ3RoKVxuICAgICAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICBpZiAoanNvbi5ncm91cClcbiAgICAgICAgdHlwZS5ncm91cCA9IHRydWU7XG4gICAgaWYgKGpzb24uY29tbWVudClcbiAgICAgICAgdHlwZS5jb21tZW50ID0ganNvbi5jb21tZW50O1xuICAgIGlmIChqc29uLmVkaXRpb24pXG4gICAgICAgIHR5cGUuX2VkaXRpb24gPSBqc29uLmVkaXRpb247XG4gICAgdHlwZS5fZGVmYXVsdEVkaXRpb24gPSBcInByb3RvM1wiOyAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1lc3NhZ2UgdHlwZSB0byBhIG1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVR5cGV9IE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yXG4gKi9cblR5cGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGluaGVyaXRlZCA9IE5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgdG9KU09OT3B0aW9ucyk7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJlZGl0aW9uXCIgICAgLCB0aGlzLl9lZGl0aW9uVG9KU09OKCksXG4gICAgICAgIFwib3B0aW9uc1wiICAgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJvbmVvZnNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5vbmVvZnNBcnJheSwgdG9KU09OT3B0aW9ucyksXG4gICAgICAgIFwiZmllbGRzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMuZmllbGRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gIW9iai5kZWNsYXJpbmdGaWVsZDsgfSksIHRvSlNPTk9wdGlvbnMpIHx8IHt9LFxuICAgICAgICBcImV4dGVuc2lvbnNcIiAsIHRoaXMuZXh0ZW5zaW9ucyAmJiB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoID8gdGhpcy5leHRlbnNpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICBcInJlc2VydmVkXCIgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImdyb3VwXCIgICAgICAsIHRoaXMuZ3JvdXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm5lc3RlZFwiICAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIGlmICghdGhpcy5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlKSByZXR1cm4gdGhpcztcblxuICAgIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xuICAgIHZhciBvbmVvZnMgPSB0aGlzLm9uZW9mc0FycmF5OyBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG9uZW9mcy5sZW5ndGgpXG4gICAgICAgIG9uZW9mc1tpKytdLnJlc29sdmUoKTtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHNBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoKVxuICAgICAgICBmaWVsZHNbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlID0gZnVuY3Rpb24gX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZShlZGl0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uKSByZXR1cm4gdGhpcztcblxuICAgIGVkaXRpb24gPSB0aGlzLl9lZGl0aW9uIHx8IGVkaXRpb247XG5cbiAgICBOYW1lc3BhY2UucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUuY2FsbCh0aGlzLCBlZGl0aW9uKTtcbiAgICB0aGlzLm9uZW9mc0FycmF5LmZvckVhY2gob25lb2YgPT4ge1xuICAgICAgICBvbmVvZi5fcmVzb2x2ZUZlYXR1cmVzKGVkaXRpb24pO1xuICAgIH0pO1xuICAgIHRoaXMuZmllbGRzQXJyYXkuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgIGZpZWxkLl9yZXNvbHZlRmVhdHVyZXMoZWRpdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkc1tuYW1lXVxuICAgICAgICB8fCB0aGlzLm9uZW9mcyAmJiB0aGlzLm9uZW9mc1tuYW1lXVxuICAgICAgICB8fCB0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXVxuICAgICAgICB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmVzdGVkIG9iamVjdCB0byB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIGFkZFxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZSBvciwgaWYgYSBmaWVsZCwgd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGEgZmllbGQgd2l0aCB0aGlzIGlkXG4gKi9cblR5cGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICh0aGlzLmdldChvYmplY3QubmFtZSkpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogRXh0ZW5zaW9uIGZpZWxkcyBhcmVuJ3QgYWN0dWFsIGZpZWxkcyBvbiB0aGUgZGVjbGFyaW5nIHR5cGUsIGJ1dCBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgLy8gVGhlIHJvb3Qgb2JqZWN0IHRha2VzIGNhcmUgb2YgYWRkaW5nIGRpc3RpbmN0IHNpc3Rlci1maWVsZHMgdG8gdGhlIHJlc3BlY3RpdmUgZXh0ZW5kZWRcbiAgICAgICAgLy8gdHlwZSBpbnN0ZWFkLlxuXG4gICAgICAgIC8vIGF2b2lkcyBjYWxsaW5nIHRoZSBnZXR0ZXIgaWYgbm90IGFic29sdXRlbHkgbmVjZXNzYXJ5IGJlY2F1c2UgaXQncyBjYWxsZWQgcXVpdGUgZnJlcXVlbnRseVxuICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZCA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRoaXMuX2ZpZWxkc0J5SWRbb2JqZWN0LmlkXSA6IHRoaXMuZmllbGRzQnlJZFtvYmplY3QuaWRdKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBvYmplY3QuaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2VydmVkSWQob2JqZWN0LmlkKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBvYmplY3QuaWQgKyBcIiBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShvYmplY3QubmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgICAgICBpZiAob2JqZWN0LnBhcmVudClcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0Lm1lc3NhZ2UgPSB0aGlzO1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZW9mcylcbiAgICAgICAgICAgIHRoaXMub25lb2ZzID0ge307XG4gICAgICAgIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgb2JqZWN0YCBpcyBub3QgYSBtZW1iZXIgb2YgdGhpcyB0eXBlXG4gKi9cblR5cGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFNlZSBUeXBlI2FkZCBmb3IgdGhlIHJlYXNvbiB3aHkgZXh0ZW5zaW9uIGZpZWxkcyBhcmUgZXhjbHVkZWQgaGVyZS5cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcyB8fCB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV0gIT09IG9iamVjdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLm9uZW9mcyB8fCB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV0gIT09IG9iamVjdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5UeXBlLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IocHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIFNldHMgdXAge0BsaW5rIFR5cGUjZW5jb2RlfGVuY29kZX0sIHtAbGluayBUeXBlI2RlY29kZXxkZWNvZGV9IGFuZCB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fS5cbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqL1xuVHlwZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAvLyBTZXRzIHVwIGV2ZXJ5dGhpbmcgYXQgb25jZSBzbyB0aGF0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG9lcyBub3QgaGF2ZSB0byBiZSByZS1ldmFsdWF0ZWRcbiAgICAvLyBtdWx0aXBsZSB0aW1lcyAoVjgsIHNvZnQtZGVvcHQgcHJvdG90eXBlLWNoZWNrKS5cblxuICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZnVsbE5hbWUsXG4gICAgICAgIHR5cGVzICAgID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICB0eXBlcy5wdXNoKHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKS5yZXNvbHZlZFR5cGUpO1xuXG4gICAgLy8gUmVwbGFjZSBzZXR1cCBtZXRob2RzIHdpdGggdHlwZS1zcGVjaWZpYyBnZW5lcmF0ZWQgZnVuY3Rpb25zXG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGVyKHRoaXMpKHtcbiAgICAgICAgV3JpdGVyIDogV3JpdGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMuZGVjb2RlID0gZGVjb2Rlcih0aGlzKSh7XG4gICAgICAgIFJlYWRlciA6IFJlYWRlcixcbiAgICAgICAgdHlwZXMgIDogdHlwZXMsXG4gICAgICAgIHV0aWwgICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLnZlcmlmeSA9IHZlcmlmaWVyKHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5mcm9tT2JqZWN0ID0gY29udmVydGVyLmZyb21PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLnRvT2JqZWN0ID0gY29udmVydGVyLnRvT2JqZWN0KHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG5cbiAgICAvLyBJbmplY3QgY3VzdG9tIHdyYXBwZXJzIGZvciBjb21tb24gdHlwZXNcbiAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJzW2Z1bGxOYW1lXTtcbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgICB2YXIgb3JpZ2luYWxUaGlzID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgLy8gaWYgKHdyYXBwZXIuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgb3JpZ2luYWxUaGlzLmZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLmZyb21PYmplY3QgPSB3cmFwcGVyLmZyb21PYmplY3QuYmluZChvcmlnaW5hbFRoaXMpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh3cmFwcGVyLnRvT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMudG9PYmplY3QgPSB0aGlzLnRvT2JqZWN0O1xuICAgICAgICAgICAgdGhpcy50b09iamVjdCA9IHdyYXBwZXIudG9PYmplY3QuYmluZChvcmlnaW5hbFRoaXMpO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT58T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gKiBAcmV0dXJucyB7V3JpdGVyfSB3cml0ZXJcbiAqL1xuVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlX3NldHVwKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT58T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gKiBAcmV0dXJucyB7V3JpdGVyfSB3cml0ZXJcbiAqL1xuVHlwZS5wcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIgJiYgd3JpdGVyLmxlbiA/IHdyaXRlci5mb3JrKCkgOiB3cml0ZXIpLmxkZWxpbSgpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBvZiB0aGUgbWVzc2FnZSwgaWYga25vd24gYmVmb3JlaGFuZFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gKiBAdGhyb3dzIHt1dGlsLlByb3RvY29sRXJyb3I8e30+fSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqL1xuVHlwZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlX3NldHVwKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5kZWNvZGUocmVhZGVyLCBsZW5ndGgpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gKiBAdGhyb3dzIHt1dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgUmVhZGVyKSlcbiAgICAgICAgcmVhZGVyID0gUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgZmllbGQgdmFsdWVzIGFyZSB2YWxpZCBhbmQgdGhhdCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gKi9cblR5cGUucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeV9zZXR1cChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS52ZXJpZnkobWVzc2FnZSk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICovXG5UeXBlLnByb3RvdHlwZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmZyb21PYmplY3Qob2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ29udmVyc2lvbiBvcHRpb25zIGFzIHVzZWQgYnkge0BsaW5rIFR5cGUjdG9PYmplY3R9IGFuZCB7QGxpbmsgTWVzc2FnZS50b09iamVjdH0uXG4gKiBAaW50ZXJmYWNlIElDb252ZXJzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xvbmdzXSBMb25nIGNvbnZlcnNpb24gdHlwZS5cbiAqIFZhbGlkIHZhbHVlcyBhcmUgYFN0cmluZ2AgYW5kIGBOdW1iZXJgICh0aGUgZ2xvYmFsIHR5cGVzKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIGEgcG9zc2libHkgdW5zYWZlIG51bWJlciB3aXRob3V0IGFuZCBhIHtAbGluayBMb25nfSB3aXRoIGEgbG9uZyBsaWJyYXJ5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2VudW1zXSBFbnVtIHZhbHVlIGNvbnZlcnNpb24gdHlwZS5cbiAqIE9ubHkgdmFsaWQgdmFsdWUgaXMgYFN0cmluZ2AgKHRoZSBnbG9iYWwgdHlwZSkuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCBpcyB0aGUgbnVtZXJpYyBpZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtieXRlc10gQnl0ZXMgdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgQXJyYXlgIGFuZCAoYSBiYXNlNjQgZW5jb2RlZCkgYFN0cmluZ2AgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggdXN1YWxseSBpcyBhIEJ1ZmZlciB1bmRlciBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIHRoZSBicm93c2VyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVmYXVsdHM9ZmFsc2VdIEFsc28gc2V0cyBkZWZhdWx0IHZhbHVlcyBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXJyYXlzPWZhbHNlXSBTZXRzIGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyByZXBlYXRlZCBmaWVsZHMgZXZlbiBpZiBgZGVmYXVsdHM9ZmFsc2VgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvYmplY3RzPWZhbHNlXSBTZXRzIGVtcHR5IG9iamVjdHMgZm9yIG1pc3NpbmcgbWFwIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uZW9mcz1mYWxzZV0gSW5jbHVkZXMgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHNldCB0byB0aGUgcHJlc2VudCBmaWVsZCdzIG5hbWUsIGlmIGFueVxuICogQHByb3BlcnR5IHtib29sZWFufSBbanNvbj1mYWxzZV0gUGVyZm9ybXMgYWRkaXRpb25hbCBKU09OIGNvbXBhdGliaWxpdHkgY29udmVyc2lvbnMsIGkuZS4gTmFOIGFuZCBJbmZpbml0eSB0byBzdHJpbmdzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBUeXBlLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIFR5cGVEZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IHRhcmdldCBUYXJnZXQgY29uc3RydWN0b3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuXG4vKipcbiAqIFR5cGUgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZU5hbWVdIFR5cGUgbmFtZSwgZGVmYXVsdHMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZVxuICogQHJldHVybnMge1R5cGVEZWNvcmF0b3I8VD59IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKi9cblR5cGUuZCA9IGZ1bmN0aW9uIGRlY29yYXRlVHlwZSh0eXBlTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB0eXBlRGVjb3JhdG9yKHRhcmdldCkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZSh0YXJnZXQsIHR5cGVOYW1lKTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiVHlwZSIsIk5hbWVzcGFjZSIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkVudW0iLCJPbmVPZiIsIkZpZWxkIiwiTWFwRmllbGQiLCJTZXJ2aWNlIiwiTWVzc2FnZSIsIlJlYWRlciIsIldyaXRlciIsInV0aWwiLCJlbmNvZGVyIiwiZGVjb2RlciIsInZlcmlmaWVyIiwiY29udmVydGVyIiwid3JhcHBlcnMiLCJuYW1lIiwib3B0aW9ucyIsImNhbGwiLCJmaWVsZHMiLCJvbmVvZnMiLCJ1bmRlZmluZWQiLCJleHRlbnNpb25zIiwicmVzZXJ2ZWQiLCJncm91cCIsIl9maWVsZHNCeUlkIiwiX2ZpZWxkc0FycmF5IiwiX29uZW9mc0FycmF5IiwiX2N0b3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZmllbGRzQnlJZCIsImdldCIsIm5hbWVzIiwia2V5cyIsImkiLCJsZW5ndGgiLCJmaWVsZCIsImlkIiwiRXJyb3IiLCJmaWVsZHNBcnJheSIsInRvQXJyYXkiLCJvbmVvZnNBcnJheSIsImN0b3IiLCJnZW5lcmF0ZUNvbnN0cnVjdG9yIiwic2V0IiwibWVyZ2UiLCIkdHlwZSIsInJlc29sdmUiLCJjdG9yUHJvcGVydGllcyIsIm9uZU9mR2V0dGVyIiwib25lb2YiLCJvbmVPZlNldHRlciIsIm10eXBlIiwiZ2VuIiwiY29kZWdlbiIsIm1hcCIsInNhZmVQcm9wIiwicmVwZWF0ZWQiLCJjbGVhckNhY2hlIiwidHlwZSIsImVuY29kZSIsImRlY29kZSIsInZlcmlmeSIsImZyb21KU09OIiwianNvbiIsImFkZCIsImtleVR5cGUiLCJuZXN0ZWQiLCJ2YWx1ZXMiLCJtZXRob2RzIiwiY29tbWVudCIsImVkaXRpb24iLCJfZWRpdGlvbiIsIl9kZWZhdWx0RWRpdGlvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJpbmhlcml0ZWQiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJfZWRpdGlvblRvSlNPTiIsImFycmF5VG9KU09OIiwiZmlsdGVyIiwib2JqIiwiZGVjbGFyaW5nRmllbGQiLCJyZXNvbHZlQWxsIiwiX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSIsIl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUiLCJfbmVlZHNSZWN1cnNpdmVGZWF0dXJlUmVzb2x1dGlvbiIsImZvckVhY2giLCJfcmVzb2x2ZUZlYXR1cmVzIiwib2JqZWN0IiwiZXh0ZW5kIiwiaXNSZXNlcnZlZElkIiwiaXNSZXNlcnZlZE5hbWUiLCJwYXJlbnQiLCJyZW1vdmUiLCJtZXNzYWdlIiwib25BZGQiLCJvblJlbW92ZSIsInByb3BlcnRpZXMiLCJzZXR1cCIsImZ1bGxOYW1lIiwidHlwZXMiLCJwdXNoIiwicmVzb2x2ZWRUeXBlIiwiZnJvbU9iamVjdCIsIndyYXBwZXIiLCJvcmlnaW5hbFRoaXMiLCJiaW5kIiwiZW5jb2RlX3NldHVwIiwid3JpdGVyIiwiZW5jb2RlRGVsaW1pdGVkIiwibGVuIiwiZm9yayIsImxkZWxpbSIsImRlY29kZV9zZXR1cCIsInJlYWRlciIsImRlY29kZURlbGltaXRlZCIsInVpbnQzMiIsInZlcmlmeV9zZXR1cCIsImQiLCJkZWNvcmF0ZVR5cGUiLCJ0eXBlTmFtZSIsInR5cGVEZWNvcmF0b3IiLCJ0YXJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/type.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/types.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Common type constants.\n * @namespace\n */ var types = exports;\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar s = [\n    \"double\",\n    \"float\",\n    \"int32\",\n    \"uint32\",\n    \"sint32\",\n    \"fixed32\",\n    \"sfixed32\",\n    \"int64\",\n    \"uint64\",\n    \"sint64\",\n    \"fixed64\",\n    \"sfixed64\",\n    \"bool\",\n    \"string\",\n    \"bytes\" // 14\n];\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while(i < values.length)o[s[i + offset]] = values[i++];\n    return o;\n}\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */ types.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */ types.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */ types.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */ types.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */ types.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsSUFBSUEsUUFBUUM7QUFFWixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQixJQUFJQyxJQUFJO0lBQ0o7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFFBQVksS0FBSztDQUNwQjtBQUVELFNBQVNDLEtBQUtDLE1BQU0sRUFBRUMsTUFBTTtJQUN4QixJQUFJQyxJQUFJLEdBQUdDLElBQUksQ0FBQztJQUNoQkYsVUFBVTtJQUNWLE1BQU9DLElBQUlGLE9BQU9JLE1BQU0sQ0FBRUQsQ0FBQyxDQUFDTCxDQUFDLENBQUNJLElBQUlELE9BQU8sQ0FBQyxHQUFHRCxNQUFNLENBQUNFLElBQUk7SUFDeEQsT0FBT0M7QUFDWDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0RULE1BQU1XLEtBQUssR0FBR04sS0FBSztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNETCxNQUFNWSxRQUFRLEdBQUdQLEtBQUs7SUFDbEIsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHSCxLQUFLVyxVQUFVO0lBQzlCLFlBQVksR0FBRztDQUNsQjtBQUVEOzs7Ozs7Ozs7Q0FTQyxHQUNEYixNQUFNYyxJQUFJLEdBQUdULEtBQUs7SUFDZCxZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7Q0FDbEIsRUFBRTtBQUVIOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RMLE1BQU1lLE1BQU0sR0FBR1YsS0FBSztJQUNoQixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7Q0FDbEIsRUFBRTtBQUVIOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNETCxNQUFNZ0IsTUFBTSxHQUFHWCxLQUFLO0lBQ2hCLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlcy5qcz81NzhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIGNvbnN0YW50cy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHR5cGVzID0gZXhwb3J0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgcyA9IFtcbiAgICBcImRvdWJsZVwiLCAgIC8vIDBcbiAgICBcImZsb2F0XCIsICAgIC8vIDFcbiAgICBcImludDMyXCIsICAgIC8vIDJcbiAgICBcInVpbnQzMlwiLCAgIC8vIDNcbiAgICBcInNpbnQzMlwiLCAgIC8vIDRcbiAgICBcImZpeGVkMzJcIiwgIC8vIDVcbiAgICBcInNmaXhlZDMyXCIsIC8vIDZcbiAgICBcImludDY0XCIsICAgIC8vIDdcbiAgICBcInVpbnQ2NFwiLCAgIC8vIDhcbiAgICBcInNpbnQ2NFwiLCAgIC8vIDlcbiAgICBcImZpeGVkNjRcIiwgIC8vIDEwXG4gICAgXCJzZml4ZWQ2NFwiLCAvLyAxMVxuICAgIFwiYm9vbFwiLCAgICAgLy8gMTJcbiAgICBcInN0cmluZ1wiLCAgIC8vIDEzXG4gICAgXCJieXRlc1wiICAgICAvLyAxNFxuXTtcblxuZnVuY3Rpb24gYmFrZSh2YWx1ZXMsIG9mZnNldCkge1xuICAgIHZhciBpID0gMCwgbyA9IHt9O1xuICAgIG9mZnNldCB8PSAwO1xuICAgIHdoaWxlIChpIDwgdmFsdWVzLmxlbmd0aCkgb1tzW2kgKyBvZmZzZXRdXSA9IHZhbHVlc1tpKytdO1xuICAgIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEJhc2ljIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJpbmc9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXM9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmJhc2ljID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMCxcbiAgICAvKiBzdHJpbmcgICAqLyAyLFxuICAgIC8qIGJ5dGVzICAgICovIDJcbl0pO1xuXG4vKipcbiAqIEJhc2ljIHR5cGUgZGVmYXVsdHMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MCBEb3VibGUgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTAgRmxvYXQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgSW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFVpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgU2ludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTAgRml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9MCBTZml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBJbnQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVWludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MCBGaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0wIFNmaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYm9vbD1mYWxzZSBCb29sIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHJpbmc9XCJcIiBTdHJpbmcgZGVmYXVsdFxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gYnl0ZXM9QXJyYXkoMCkgQnl0ZXMgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudWxsfSBtZXNzYWdlPW51bGwgTWVzc2FnZSBkZWZhdWx0XG4gKi9cbnR5cGVzLmRlZmF1bHRzID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMCxcbiAgICAvKiBmbG9hdCAgICAqLyAwLFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDAsXG4gICAgLyogc2ZpeGVkMzIgKi8gMCxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAwLFxuICAgIC8qIHNmaXhlZDY0ICovIDAsXG4gICAgLyogYm9vbCAgICAgKi8gZmFsc2UsXG4gICAgLyogc3RyaW5nICAgKi8gXCJcIixcbiAgICAvKiBieXRlcyAgICAqLyB1dGlsLmVtcHR5QXJyYXksXG4gICAgLyogbWVzc2FnZSAgKi8gbnVsbFxuXSk7XG5cbi8qKlxuICogQmFzaWMgbG9uZyB0eXBlIHdpcmUgdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICovXG50eXBlcy5sb25nID0gYmFrZShbXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxXG5dLCA3KTtcblxuLyoqXG4gKiBBbGxvd2VkIHR5cGVzIGZvciBtYXAga2V5cyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMubWFwS2V5ID0gYmFrZShbXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDJcbl0sIDIpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdpcmUgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqL1xudHlwZXMucGFja2VkID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMFxuXSk7XG4iXSwibmFtZXMiOlsidHlwZXMiLCJleHBvcnRzIiwidXRpbCIsInJlcXVpcmUiLCJzIiwiYmFrZSIsInZhbHVlcyIsIm9mZnNldCIsImkiLCJvIiwibGVuZ3RoIiwiYmFzaWMiLCJkZWZhdWx0cyIsImVtcHR5QXJyYXkiLCJsb25nIiwibWFwS2V5IiwicGFja2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Various utility functions.\n * @namespace\n */ var util = module.exports = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar roots = __webpack_require__(/*! ./roots */ \"(ssr)/../node_modules/protobufjs/src/roots.js\");\nvar Type, Enum;\nutil.codegen = __webpack_require__(/*! @protobufjs/codegen */ \"(ssr)/../node_modules/@protobufjs/codegen/index.js\");\nutil.fetch = __webpack_require__(/*! @protobufjs/fetch */ \"(ssr)/../node_modules/@protobufjs/fetch/index.js\");\nutil.path = __webpack_require__(/*! @protobufjs/path */ \"(ssr)/../node_modules/@protobufjs/path/index.js\");\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */ util.fs = util.inquire(\"fs\");\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */ util.toArray = function toArray(object) {\n    if (object) {\n        var keys = Object.keys(object), array = new Array(keys.length), index = 0;\n        while(index < keys.length)array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */ util.toObject = function toObject(array) {\n    var object = {}, index = 0;\n    while(index < array.length){\n        var key = array[index++], val = array[index++];\n        if (val !== undefined) object[key] = val;\n    }\n    return object;\n};\nvar safePropBackslashRe = /\\\\/g, safePropQuoteRe = /\"/g;\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ util.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */ util.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return '[\"' + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, '\\\\\"') + '\"]';\n    return \".\" + prop;\n};\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar camelCaseRe = /_([a-z])/g;\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.camelCase = function camelCase(str) {\n    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {\n        return $1.toUpperCase();\n    });\n};\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */ util.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */ util.decorateType = function decorateType(ctor, typeName) {\n    /* istanbul ignore if */ if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n    /* istanbul ignore next */ if (!Type) Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\");\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    Object.defineProperty(ctor.prototype, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    return type;\n};\nvar decorateEnumIndex = 0;\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */ util.decorateEnum = function decorateEnum(object) {\n    /* istanbul ignore if */ if (object.$type) return object.$type;\n    /* istanbul ignore next */ if (!Enum) Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\");\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", {\n        value: enm,\n        enumerable: false\n    });\n    return enm;\n};\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {Object.<string,*>} Destination object\n */ util.setProperty = function setProperty(dst, path, value, ifNotSet) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n            return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue && ifNotSet) return dst;\n            if (prevValue) value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n    if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n    if (!path) throw TypeError(\"path must be specified\");\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */ Object.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (__webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\"))());\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7O0NBR0MsR0FDRCxJQUFJQSxPQUFPQyxrSEFBMEM7QUFFckQsSUFBSUcsUUFBUUQsbUJBQU9BLENBQUMsOERBQVM7QUFFN0IsSUFBSUUsTUFDQUM7QUFFSk4sS0FBS08sT0FBTyxHQUFHSixtQkFBT0EsQ0FBQywrRUFBcUI7QUFDNUNILEtBQUtRLEtBQUssR0FBS0wsbUJBQU9BLENBQUMsMkVBQW1CO0FBQzFDSCxLQUFLUyxJQUFJLEdBQU1OLG1CQUFPQSxDQUFDLHlFQUFrQjtBQUV6Qzs7O0NBR0MsR0FDREgsS0FBS1UsRUFBRSxHQUFHVixLQUFLVyxPQUFPLENBQUM7QUFFdkI7Ozs7Q0FJQyxHQUNEWCxLQUFLWSxPQUFPLEdBQUcsU0FBU0EsUUFBUUMsTUFBTTtJQUNsQyxJQUFJQSxRQUFRO1FBQ1IsSUFBSUMsT0FBUUMsT0FBT0QsSUFBSSxDQUFDRCxTQUNwQkcsUUFBUSxJQUFJQyxNQUFNSCxLQUFLSSxNQUFNLEdBQzdCQyxRQUFRO1FBQ1osTUFBT0EsUUFBUUwsS0FBS0ksTUFBTSxDQUN0QkYsS0FBSyxDQUFDRyxNQUFNLEdBQUdOLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDSyxRQUFRLENBQUM7UUFDeEMsT0FBT0g7SUFDWDtJQUNBLE9BQU8sRUFBRTtBQUNiO0FBRUE7Ozs7Q0FJQyxHQUNEaEIsS0FBS29CLFFBQVEsR0FBRyxTQUFTQSxTQUFTSixLQUFLO0lBQ25DLElBQUlILFNBQVMsQ0FBQyxHQUNWTSxRQUFTO0lBQ2IsTUFBT0EsUUFBUUgsTUFBTUUsTUFBTSxDQUFFO1FBQ3pCLElBQUlHLE1BQU1MLEtBQUssQ0FBQ0csUUFBUSxFQUNwQkcsTUFBTU4sS0FBSyxDQUFDRyxRQUFRO1FBQ3hCLElBQUlHLFFBQVFDLFdBQ1JWLE1BQU0sQ0FBQ1EsSUFBSSxHQUFHQztJQUN0QjtJQUNBLE9BQU9UO0FBQ1g7QUFFQSxJQUFJVyxzQkFBc0Is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RCxLQUFLNEQsV0FBVyxHQUFHLFNBQVNBLFlBQVlDLEdBQUcsRUFBRXBELElBQUksRUFBRTZDLEtBQUssRUFBRVEsUUFBUTtJQUM5RCxTQUFTQyxRQUFRRixHQUFHLEVBQUVwRCxJQUFJLEVBQUU2QyxLQUFLO1FBQzdCLElBQUlVLE9BQU92RCxLQUFLd0QsS0FBSztRQUNyQixJQUFJRCxTQUFTLGVBQWVBLFNBQVMsYUFBYTtZQUNoRCxPQUFPSDtRQUNUO1FBQ0EsSUFBSXBELEtBQUtTLE1BQU0sR0FBRyxHQUFHO1lBQ2pCMkMsR0FBRyxDQUFDRyxLQUFLLEdBQUdELFFBQVFGLEdBQUcsQ0FBQ0csS0FBSyxJQUFJLENBQUMsR0FBR3ZELE1BQU02QztRQUMvQyxPQUFPO1lBQ0gsSUFBSVksWUFBWUwsR0FBRyxDQUFDRyxLQUFLO1lBQ3pCLElBQUlFLGFBQWFKLFVBQ2IsT0FBT0Q7WUFDWCxJQUFJSyxXQUNBWixRQUFRLEVBQUUsQ0FBQ2EsTUFBTSxDQUFDRCxXQUFXQyxNQUFNLENBQUNiO1lBQ3hDTyxHQUFHLENBQUNHLEtBQUssR0FBR1Y7UUFDaEI7UUFDQSxPQUFPTztJQUNYO0lBRUEsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTU8sVUFBVTtJQUNwQixJQUFJLENBQUMzRCxNQUNELE1BQU0yRCxVQUFVO0lBRXBCM0QsT0FBT0EsS0FBSzRELEtBQUssQ0FBQztJQUNsQixPQUFPTixRQUFRRixLQUFLcEQsTUFBTTZDO0FBQzlCO0FBRUE7Ozs7O0NBS0MsR0FDRHZDLE9BQU9zQyxjQUFjLENBQUNyRCxNQUFNLGdCQUFnQjtJQUN4Q3NFLEtBQUs7UUFDRCxPQUFPbEUsS0FBSyxDQUFDLFlBQVksSUFBS0EsQ0FBQUEsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFLRCxDQUFBQSxtQkFBT0EsQ0FBQyw0REFBUSxJQUFHO0lBQy9FO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC5qcz80YmYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciByb290cyA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xuXG52YXIgVHlwZSwgLy8gY3ljbGljXG4gICAgRW51bTtcblxudXRpbC5jb2RlZ2VuID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2NvZGVnZW5cIik7XG51dGlsLmZldGNoICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmV0Y2hcIik7XG51dGlsLnBhdGggICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcGF0aFwiKTtcblxuLyoqXG4gKiBOb2RlJ3MgZnMgbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqL1xudXRpbC5mcyA9IHV0aWwuaW5xdWlyZShcImZzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCdzIHZhbHVlcyB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBPYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge0FycmF5LjwqPn0gQ29udmVydGVkIGFycmF5XG4gKi9cbnV0aWwudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIga2V5cyAgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IG9iamVjdFtrZXlzW2luZGV4KytdXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGtleXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSB0byBhbiBvYmplY3QsIG9taXR0aW5nIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBDb252ZXJ0ZWQgb2JqZWN0XG4gKi9cbnV0aWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICAgIHZhciBvYmplY3QgPSB7fSxcbiAgICAgICAgaW5kZXggID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGFycmF5W2luZGV4KytdLFxuICAgICAgICAgICAgdmFsID0gYXJyYXlbaW5kZXgrK107XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIHNhZmVQcm9wQmFja3NsYXNoUmUgPSAvXFxcXC9nLFxuICAgIHNhZmVQcm9wUXVvdGVSZSAgICAgPSAvXCIvZztcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSlMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xuICAgIHJldHVybiAvXig/OmRvfGlmfGlufGZvcnxsZXR8bmV3fHRyeXx2YXJ8Y2FzZXxlbHNlfGVudW18ZXZhbHxmYWxzZXxudWxsfHRoaXN8dHJ1ZXx2b2lkfHdpdGh8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGV4cG9ydHxpbXBvcnR8cHVibGljfHJldHVybnxzdGF0aWN8c3dpdGNofHR5cGVvZnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258YXJndW1lbnRzfGludGVyZmFjZXxwcm90ZWN0ZWR8aW1wbGVtZW50c3xpbnN0YW5jZW9mKSQvLnRlc3QobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzYWZlIHByb3BlcnR5IGFjY2Vzc29yIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYWZlIGFjY2Vzc29yXG4gKi9cbnV0aWwuc2FmZVByb3AgPSBmdW5jdGlvbiBzYWZlUHJvcChwcm9wKSB7XG4gICAgaWYgKCEvXlskXFx3X10rJC8udGVzdChwcm9wKSB8fCB1dGlsLmlzUmVzZXJ2ZWQocHJvcCkpXG4gICAgICAgIHJldHVybiBcIltcXFwiXCIgKyBwcm9wLnJlcGxhY2Uoc2FmZVByb3BCYWNrc2xhc2hSZSwgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKHNhZmVQcm9wUXVvdGVSZSwgXCJcXFxcXFxcIlwiKSArIFwiXFxcIl1cIjtcbiAgICByZXR1cm4gXCIuXCIgKyBwcm9wO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwudWNGaXJzdCA9IGZ1bmN0aW9uIHVjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgY2FtZWxDYXNlUmUgPSAvXyhbYS16XSkvZztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZShjYW1lbENhc2VSZSwgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgcmVmbGVjdGVkIGZpZWxkcyBieSBpZC5cbiAqIEBwYXJhbSB7RmllbGR9IGEgRmlyc3QgZmllbGRcbiAqIEBwYXJhbSB7RmllbGR9IGIgU2Vjb25kIGZpZWxkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBDb21wYXJpc29uIHZhbHVlXG4gKi9cbnV0aWwuY29tcGFyZUZpZWxkc0J5SWQgPSBmdW5jdGlvbiBjb21wYXJlRmllbGRzQnlJZChhLCBiKSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciB0eXBlcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlfSBSZWZsZWN0ZWQgdHlwZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgRGVjb3JhdG9ycyByb290XG4gKi9cbnV0aWwuZGVjb3JhdGVUeXBlID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKGN0b3IsIHR5cGVOYW1lKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3Rvci4kdHlwZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUgJiYgY3Rvci4kdHlwZS5uYW1lICE9PSB0eXBlTmFtZSkge1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QucmVtb3ZlKGN0b3IuJHR5cGUpO1xuICAgICAgICAgICAgY3Rvci4kdHlwZS5uYW1lID0gdHlwZU5hbWU7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoY3Rvci4kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3IuJHR5cGU7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIVR5cGUpXG4gICAgICAgIFR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuXG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0eXBlTmFtZSB8fCBjdG9yLm5hbWUpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZCh0eXBlKTtcbiAgICB0eXBlLmN0b3IgPSBjdG9yOyAvLyBzZXRzIHVwIC5lbmNvZGUsIC5kZWNvZGUgZXRjLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbnZhciBkZWNvcmF0ZUVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgZW51bXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBFbnVtIG9iamVjdFxuICogQHJldHVybnMge0VudW19IFJlZmxlY3RlZCBlbnVtXG4gKi9cbnV0aWwuZGVjb3JhdGVFbnVtID0gZnVuY3Rpb24gZGVjb3JhdGVFbnVtKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9iamVjdC4kdHlwZSlcbiAgICAgICAgcmV0dXJuIG9iamVjdC4kdHlwZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFFbnVtKVxuICAgICAgICBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKTtcblxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcIkVudW1cIiArIGRlY29yYXRlRW51bUluZGV4KyssIG9iamVjdCk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGVubSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCIkdHlwZVwiLCB7IHZhbHVlOiBlbm0sIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiBlbm07XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBwcm9wZXJ0eSBwYXRoLiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCBpcyB0dXJuZWQgdG8gYW4gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRvdCAnLicgZGVsaW1pdGVkIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IFtpZk5vdFNldF0gU2V0cyB0aGUgb3B0aW9uIG9ubHkgaWYgaXQgaXNuJ3QgY3VycmVudGx5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xudXRpbC5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRzdCwgcGF0aCwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgZnVuY3Rpb24gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocGFydCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwYXJ0ID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSBzZXRQcm9wKGRzdFtwYXJ0XSB8fCB7fSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGRzdFtwYXJ0XTtcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUgJiYgaWZOb3RTZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZHN0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIGlmICghcGF0aClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicGF0aCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIHJvb3QgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgdXRpbC5kZWNvcmF0ZVJvb3RcbiAqIEB0eXBlIHtSb290fVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1dGlsLCBcImRlY29yYXRlUm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RzW1wiZGVjb3JhdGVkXCJdIHx8IChyb290c1tcImRlY29yYXRlZFwiXSA9IG5ldyAocmVxdWlyZShcIi4vcm9vdFwiKSkoKSk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsidXRpbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwicm9vdHMiLCJUeXBlIiwiRW51bSIsImNvZGVnZW4iLCJmZXRjaCIsInBhdGgiLCJmcyIsImlucXVpcmUiLCJ0b0FycmF5Iiwib2JqZWN0Iiwia2V5cyIsIk9iamVjdCIsImFycmF5IiwiQXJyYXkiLCJsZW5ndGgiLCJpbmRleCIsInRvT2JqZWN0Iiwia2V5IiwidmFsIiwidW5kZWZpbmVkIiwic2FmZVByb3BCYWNrc2xhc2hSZSIsInNhZmVQcm9wUXVvdGVSZSIsImlzUmVzZXJ2ZWQiLCJuYW1lIiwidGVzdCIsInNhZmVQcm9wIiwicHJvcCIsInJlcGxhY2UiLCJ1Y0ZpcnN0Iiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJjYW1lbENhc2VSZSIsImNhbWVsQ2FzZSIsIiQwIiwiJDEiLCJjb21wYXJlRmllbGRzQnlJZCIsImEiLCJiIiwiaWQiLCJkZWNvcmF0ZVR5cGUiLCJjdG9yIiwidHlwZU5hbWUiLCIkdHlwZSIsImRlY29yYXRlUm9vdCIsInJlbW92ZSIsImFkZCIsInR5cGUiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsInByb3RvdHlwZSIsImRlY29yYXRlRW51bUluZGV4IiwiZGVjb3JhdGVFbnVtIiwiZW5tIiwic2V0UHJvcGVydHkiLCJkc3QiLCJpZk5vdFNldCIsInNldFByb3AiLCJwYXJ0Iiwic2hpZnQiLCJwcmV2VmFsdWUiLCJjb25jYXQiLCJUeXBlRXJyb3IiLCJzcGxpdCIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util/longbits.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/util/longbits.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = LongBits;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */ function LongBits(lo, hi) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n    /**\n     * Low bits.\n     * @type {number}\n     */ this.lo = lo >>> 0;\n    /**\n     * High bits.\n     * @type {number}\n     */ this.hi = hi >>> 0;\n}\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */ var zero = LongBits.zero = new LongBits(0, 0);\nzero.toNumber = function() {\n    return 0;\n};\nzero.zzEncode = zero.zzDecode = function() {\n    return this;\n};\nzero.length = function() {\n    return 1;\n};\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */ var zeroHash = LongBits.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.fromNumber = function fromNumber(value) {\n    if (value === 0) return zero;\n    var sign = value < 0;\n    if (sign) value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295) hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.from = function from(value) {\n    if (typeof value === \"number\") return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);\n        else return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */ LongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo) hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */ LongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n        low: this.lo | 0,\n        high: this.hi | 0,\n        unsigned: Boolean(unsigned)\n    };\n};\nvar charCodeAt = String.prototype.charCodeAt;\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */ LongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash) return zero;\n    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n};\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */ LongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n};\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */ LongBits.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw2RUFBaUI7QUFFcEM7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNGLFNBQVNHLEVBQUUsRUFBRUMsRUFBRTtJQUVwQiw0RkFBNEY7SUFDNUYsMEZBQTBGO0lBRTFGOzs7S0FHQyxHQUNELElBQUksQ0FBQ0QsRUFBRSxHQUFHQSxPQUFPO0lBRWpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxPQUFPO0FBQ3JCO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlDLE9BQU9MLFNBQVNLLElBQUksR0FBRyxJQUFJTCxTQUFTLEdBQUc7QUFFM0NLLEtBQUtDLFFBQVEsR0FBRztJQUFhLE9BQU87QUFBRztBQUN2Q0QsS0FBS0UsUUFBUSxHQUFHRixLQUFLRyxRQUFRLEdBQUc7SUFBYSxPQUFPLElBQUk7QUFBRTtBQUMxREgsS0FBS0ksTUFBTSxHQUFHO0lBQWEsT0FBTztBQUFHO0FBRXJDOzs7O0NBSUMsR0FDRCxJQUFJQyxXQUFXVixTQUFTVSxRQUFRLEdBQUc7QUFFbkM7Ozs7Q0FJQyxHQUNEVixTQUFTVyxVQUFVLEdBQUcsU0FBU0EsV0FBV0MsS0FBSztJQUMzQyxJQUFJQSxVQUFVLEdBQ1YsT0FBT1A7SUFDWCxJQUFJUSxPQUFPRCxRQUFRO0lBQ25CLElBQUlDLE1BQ0FELFFBQVEsQ0FBQ0E7SUFDYixJQUFJVCxLQUFLUyxVQUFVLEdBQ2ZSLEtBQUssQ0FBQ1EsUUFBUVQsRUFBQyxJQUFLLGVBQWU7SUFDdkMsSUFBSVUsTUFBTTtRQUNOVCxLQUFLLENBQUNBLE9BQU87UUFDYkQsS0FBSyxDQUFDQSxPQUFPO1FBQ2IsSUFBSSxFQUFFQSxLQUFLLFlBQVk7WUFDbkJBLEtBQUs7WUFDTCxJQUFJLEVBQUVDLEtBQUssWUFDUEEsS0FBSztRQUNiO0lB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QUMxQkMsUUFBUSxNQUFNLElBQUk7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcz9hZTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJMb25nQml0cyIsInV0aWwiLCJyZXF1aXJlIiwibG8iLCJoaSIsInplcm8iLCJ0b051bWJlciIsInp6RW5jb2RlIiwienpEZWNvZGUiLCJsZW5ndGgiLCJ6ZXJvSGFzaCIsImZyb21OdW1iZXIiLCJ2YWx1ZSIsInNpZ24iLCJmcm9tIiwiaXNTdHJpbmciLCJMb25nIiwiZnJvbVN0cmluZyIsInBhcnNlSW50IiwibG93IiwiaGlnaCIsInByb3RvdHlwZSIsInVuc2lnbmVkIiwidG9Mb25nIiwiQm9vbGVhbiIsImNoYXJDb2RlQXQiLCJTdHJpbmciLCJmcm9tSGFzaCIsImhhc2giLCJjYWxsIiwidG9IYXNoIiwiZnJvbUNoYXJDb2RlIiwibWFzayIsInBhcnQwIiwicGFydDEiLCJwYXJ0MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util/minimal.js":
/*!******************************************************!*\
  !*** ../node_modules/protobufjs/src/util/minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar util = exports;\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(ssr)/../node_modules/@protobufjs/aspromise/index.js\");\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(ssr)/../node_modules/@protobufjs/base64/index.js\");\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(ssr)/../node_modules/@protobufjs/eventemitter/index.js\");\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(ssr)/../node_modules/@protobufjs/float/index.js\");\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(ssr)/../node_modules/@protobufjs/inquire/index.js\");\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(ssr)/../node_modules/@protobufjs/utf8/index.js\");\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(ssr)/../node_modules/@protobufjs/pool/index.js\");\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(ssr)/../node_modules/protobufjs/src/util/longbits.js\");\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */ util.isNode = Boolean(typeof global !== \"undefined\" && global && global.process && global.process.versions && global.process.versions.node);\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */ util.global = util.isNode && global ||  false && 0 || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */ util.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */ util.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isset = /**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */ /**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */ util.Buffer = function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */ return null;\n    }\n}();\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */ util.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */ return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */ util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */  : Array;\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */ /**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire(\"long\");\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */ util.key2Re = /^true|false|0|1$/;\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */ util.longToHash = function longToHash(value) {\n    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */ util.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */ function merge(dst, src, ifNotSet) {\n    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n    return dst;\n}\nutil.merge = merge;\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */ function newError(name) {\n    function CustomError(message, properties) {\n        if (!(this instanceof CustomError)) return new CustomError(message, properties);\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n        Object.defineProperty(this, \"message\", {\n            get: function() {\n                return message;\n            }\n        });\n        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);\n        else Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n        });\n        if (properties) merge(this, properties);\n    }\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        name: {\n            get: function get() {\n                return name;\n            },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true\n        },\n        toString: {\n            value: function value() {\n                return this.name + \": \" + this.message;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    return CustomError;\n}\nutil.newError = newError;\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */ util.ProtocolError = newError(\"ProtocolError\");\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */ /**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */ /**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */ util.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */ return function() {\n        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n    };\n};\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */ /**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */ util.oneOfSetter = function setOneOf(fieldNames) {\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */ return function(name) {\n        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];\n    };\n};\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */ util.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */ if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n    };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLE9BQU9DO0FBRVgscURBQXFEO0FBQ3JERCxLQUFLRSxTQUFTLEdBQUdDLG1CQUFPQSxDQUFDLG1GQUF1QjtBQUVoRCw0Q0FBNEM7QUFDNUNILEtBQUtJLE1BQU0sR0FBR0QsbUJBQU9BLENBQUMsNkVBQW9CO0FBRTFDLDRCQUE0QjtBQUM1QkgsS0FBS0ssWUFBWSxHQUFHRixtQkFBT0EsQ0FBQyx5RkFBMEI7QUFFdEQsa0NBQWtDO0FBQ2xDSCxLQUFLTSxLQUFLLEdBQUdILG1CQUFPQSxDQUFDLDJFQUFtQjtBQUV4QywrREFBK0Q7QUFDL0RILEtBQUtPLE9BQU8sR0FBR0osbUJBQU9BLENBQUMsK0VBQXFCO0FBRTVDLDBDQUEwQztBQUMxQ0gsS0FBS1EsSUFBSSxHQUFHTCxtQkFBT0EsQ0FBQyx5RUFBa0I7QUFFdEMsa0RBQWtEO0FBQ2xESCxLQUFLUyxJQUFJLEdBQUdOLG1CQUFPQSxDQUFDLHlFQUFrQjtBQUV0QywrREFBK0Q7QUFDL0RILEtBQUtVLFFBQVEsR0FBR1AsbUJBQU9BLENBQUMseUVBQVk7QUFFcEM7Ozs7Q0FJQyxHQUNESCxLQUFLVyxNQUFNLEdBQUdDLFFBQVEsT0FBT0MsV0FBVyxlQUNsQkEsVUFDQUEsT0FBT0MsT0FBTyxJQUNkRCxPQUFPQyxPQUFPLENBQUNDLFFBQVEsSUFDdkJGLE9BQU9DLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO0FBRWxEOzs7O0NBSUMsR0FDRGhCLEtBQUthLE1BQU0sR0FBR2IsS0FBS1csTUFBTSxJQUFJRSxVQUNmLE1BQTZCLElBQUlJLENBQU1BLElBQ3ZDLE9BQU9DLFNBQVcsZUFBZUEsUUFDakMsSUFBSSxFQUFFLHNDQUFzQztBQUUxRDs7Ozs7Q0FLQyxHQUNEbEIsS0FBS21CLFVBQVUsR0FBR0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUMsRUFB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LEdBQ3RCLElBQUksQ0FBQ0EsUUFBUTtRQUNUekMsS0FBSzZDLFlBQVksR0FBRzdDLEtBQUs4QyxtQkFBbUIsR0FBRztRQUMvQztJQUNKO0lBQ0Esd0RBQXdEO0lBQ3hELHVEQUF1RDtJQUN2RDlDLEtBQUs2QyxZQUFZLEdBQUdKLE9BQU9lLElBQUksS0FBS1AsV0FBV08sSUFBSSxJQUFJZixPQUFPZSxJQUFJLElBQzlELHdCQUF3QixHQUN4QixTQUFTcUQsWUFBWXBGLEtBQUssRUFBRXFGLFFBQVE7UUFDaEMsT0FBTyxJQUFJckUsT0FBT2hCLE9BQU9xRjtJQUM3QjtJQUNKOUcsS0FBSzhDLG1CQUFtQixHQUFHTCxPQUFPc0UsV0FBVyxJQUN6Qyx3QkFBd0IsR0FDeEIsU0FBU0MsbUJBQW1CQyxJQUFJO1FBQzVCLE9BQU8sSUFBSXhFLE9BQU93RTtJQUN0QjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcz8wM2RmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7IHJldHVybiBuYW1lOyB9LFxuICAgICAgICAgICAgc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogZmFsc2Ugd291bGQgYWNjdXJhdGVseSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYnV0IEknbSBndWVzc2luZyB0aGF0IHdhcyBub3QgaW50ZW50aW9uYWwuXG4gICAgICAgICAgICAvLyBGb3IgYW4gYWN0dWFsIGVycm9yIHN1YmNsYXNzLCB0aGlzIHByb3BlcnR5IHdvdWxkXG4gICAgICAgICAgICAvLyBiZSBjb25maWd1cmFibGUuXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwiZXhwb3J0cyIsImFzUHJvbWlzZSIsInJlcXVpcmUiLCJiYXNlNjQiLCJFdmVudEVtaXR0ZXIiLCJmbG9hdCIsImlucXVpcmUiLCJ1dGY4IiwicG9vbCIsIkxvbmdCaXRzIiwiaXNOb2RlIiwiQm9vbGVhbiIsImdsb2JhbCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJ3aW5kb3ciLCJzZWxmIiwiZW1wdHlBcnJheSIsIk9iamVjdCIsImZyZWV6ZSIsImVtcHR5T2JqZWN0IiwiaXNJbnRlZ2VyIiwiTnVtYmVyIiwidmFsdWUiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImlzU3RyaW5nIiwiU3RyaW5nIiwiaXNPYmplY3QiLCJpc3NldCIsImlzU2V0Iiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwia2V5cyIsIkJ1ZmZlciIsInByb3RvdHlwZSIsInV0ZjhXcml0ZSIsImUiLCJfQnVmZmVyX2Zyb20iLCJfQnVmZmVyX2FsbG9jVW5zYWZlIiwibmV3QnVmZmVyIiwic2l6ZU9yQXJyYXkiLCJVaW50OEFycmF5IiwiTG9uZyIsImRjb2RlSU8iLCJrZXkyUmUiLCJrZXkzMlJlIiwia2V5NjRSZSIsImxvbmdUb0hhc2giLCJmcm9tIiwidG9IYXNoIiwiemVyb0hhc2giLCJsb25nRnJvbUhhc2giLCJoYXNoIiwidW5zaWduZWQiLCJiaXRzIiwiZnJvbUhhc2giLCJmcm9tQml0cyIsImxvIiwiaGkiLCJ0b051bWJlciIsIm1lcmdlIiwiZHN0Iiwic3JjIiwiaWZOb3RTZXQiLCJpIiwidW5kZWZpbmVkIiwibGNGaXJzdCIsInN0ciIsImNoYXJBdCIsInRvTG93ZXJDYXNlIiwic3Vic3RyaW5nIiwibmV3RXJyb3IiLCJuYW1lIiwiQ3VzdG9tRXJyb3IiLCJtZXNzYWdlIiwicHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJzZXQiLCJ0b1N0cmluZyIsIlByb3RvY29sRXJyb3IiLCJvbmVPZkdldHRlciIsImdldE9uZU9mIiwiZmllbGROYW1lcyIsImZpZWxkTWFwIiwib25lT2ZTZXR0ZXIiLCJzZXRPbmVPZiIsInRvSlNPTk9wdGlvbnMiLCJsb25ncyIsImVudW1zIiwiYnl0ZXMiLCJqc29uIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlcl9mcm9tIiwiZW5jb2RpbmciLCJhbGxvY1Vuc2FmZSIsIkJ1ZmZlcl9hbGxvY1Vuc2FmZSIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/verifier.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/verifier.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = verifier;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\" + field.keyType + \"}\" : \"\") + \" expected\";\n}\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(%s){\", ref)(\"default:\")(\"return%j\", invalid(field, \"enum value\"));\n            for(var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)gen(\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen(\"break\")(\"}\");\n        } else {\n            gen(\"{\")(\"var e=types[%i].verify(%s);\", fieldIndex, ref)(\"if(e)\")(\"return%j+e\", field.name + \".\")(\"}\");\n        }\n    } else {\n        switch(field.type){\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n                gen(\"if(!util.isInteger(%s))\", ref)(\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)(\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\":\n                gen('if(typeof %s!==\"number\")', ref)(\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\":\n                gen('if(typeof %s!==\"boolean\")', ref)(\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\":\n                gen(\"if(!util.isString(%s))\", ref)(\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\":\n                gen('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', ref, ref, ref)(\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */ switch(field.keyType){\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\":\n            gen(\"if(!util.key32Re.test(%s))\", ref)(\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\":\n            gen(\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n            (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\":\n            gen(\"if(!util.key2Re.test(%s))\", ref)(\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"m\"\n    ], mtype.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray, seenFirstField = {};\n    if (oneofs.length) gen(\"var p={}\");\n    for(var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), ref = \"m\" + util.safeProp(field.name);\n        if (field.optional) gen(\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n        // map fields\n        if (field.map) {\n            gen(\"if(!util.isObject(%s))\", ref)(\"return%j\", invalid(field, \"object\"))(\"var k=Object.keys(%s)\", ref)(\"for(var i=0;i<k.length;++i){\");\n            genVerifyKey(gen, field, \"k[i]\");\n            genVerifyValue(gen, field, i, ref + \"[k[i]]\")(\"}\");\n        // repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!Array.isArray(%s))\", ref)(\"return%j\", invalid(field, \"array\"))(\"for(var i=0;i<%s.length;++i){\", ref);\n            genVerifyValue(gen, field, i, ref + \"[i]\")(\"}\");\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen(\"if(p%s===1)\", oneofProp)(\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen(\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen(\"}\");\n    }\n    return gen(\"return null\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3ZlcmlmaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsNERBQVEsR0FDNUJDLE9BQVlELG1CQUFPQSxDQUFDLDREQUFRO0FBRWhDLFNBQVNFLFFBQVFDLEtBQUssRUFBRUMsUUFBUTtJQUM1QixPQUFPRCxNQUFNRSxJQUFJLEdBQUcsT0FBT0QsV0FBWUQsQ0FBQUEsTUFBTUcsUUFBUSxJQUFJRixhQUFhLFVBQVUsT0FBT0QsTUFBTUksR0FBRyxJQUFJSCxhQUFhLFdBQVcsUUFBTUQsTUFBTUssT0FBTyxHQUFDLE1BQU0sRUFBQyxJQUFLO0FBQ2hLO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQyxlQUFlQyxHQUFHLEVBQUVQLEtBQUssRUFBRVEsVUFBVSxFQUFFQyxHQUFHO0lBQy9DLDBDQUEwQyxHQUMxQyxJQUFJVCxNQUFNVSxZQUFZLEVBQUU7UUFDcEIsSUFBSVYsTUFBTVUsWUFBWSxZQUFZZCxNQUFNO1lBQUVXLElBQ3JDLGVBQWVFLEtBQ1gsWUFDSSxZQUFZVixRQUFRQyxPQUFPO1lBQ3BDLElBQUssSUFBSVcsT0FBT0MsT0FBT0QsSUFBSSxDQUFDWCxNQUFNVSxZQUFZLENBQUNHLE1BQU0sR0FBR0MsSUFBSSxHQUFHQSxJQUFJSCxLQUFLSSxNQUFNLEVBQUUsRUFBRUQsRUFBR1AsSUFDaEYsWUFBWVAsTUFBTVUsWUFBWSxDQUFDRyxNQUFNLENBQUNGLElBQUksQ0FBQ0csRUFBRSxDQUFDO1lBQ25EUCxJQUNTLFNBQ1I7UUFDTCxPQUFPO1lBQ0hBLElBQ0MsS0FDSSwrQkFBK0JDLFlBQVlDLEtBQzNDLFNBQ0ksY0FBY1QsTUFBTUUsSUFBSSxHQUFHLEtBQ25DO1FBQ0w7SUFDSixPQUFPO1FBQ0gsT0FBUUYsTUFBTWdCLElBQUk7WUFDZCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFBWVQsSUFDWiwyQkFBMkJFLEtBQ3ZCLFlBQVlWLFFBQVFDLE9BQU87Z0JBQ2hDO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQVlPLElBQ1osbUZBQW1GRSxLQUFLQSxLQUFLQSxLQUFLQSxLQUM5RixZQUFZVixRQUFRQyxPQUFPO2dCQUNoQztZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUFVTyxJQUNWLDRCQUE4QkUsS0FDMUIsWUFBWVYsUUFBUUMsT0FBTztnQkFDaEM7WUFDSixLQUFLO2dCQUFRTyxJQUNSLDZCQUErQkUsS0FDM0IsWUFBWVYsUUFBUUMsT0FBTztnQkFDaEM7WUFDSixLQUFLO2dCQUFVTyxJQUNWLDBCQUEwQkUsS0FDdEIsWUFBWVYsUUFBUUMsT0FBTztnQkFDaEM7WUFDSixLQUFLO2dCQUFTTyxJQUNULDZEQUErREUsS0FBS0EsS0FBS0EsS0FDckUsWUFBWVYsUUFBUUMsT0FBTztnQkFDaEM7UUFDUjtJQUNKO0lBQ0EsT0FBT087QUFDUCx5Q0FBeUMsR0FDN0M7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1UsYUFBYVYsR0FBRyxFQUFFUCxLQUFLLEVBQUVTLEdBQUc7SUFDakMsMENBQTBDLEdBQzFDLE9BQVFULE1BQU1LLE9BQU87UUFDakIsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFBWUUsSUFDWiw4QkFBOEJFLEtBQzFCLFlBQVlWLFFBQVFDLE9BQU87WUFDaEM7UUFDSixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUFZTyxJQUNaLDhCQUE4QkUsS0FBSyx1Q0FBdUM7YUFDdEUsWUFBWVYsUUFBUUMsT0FBTztZQUNoQztRQUNKLEtBQUs7WUFBUU8sSUFDUiw2QkFBNkJFLEtBQ3pCLFlBQVlWLFFBQVFDLE9BQU87WUFDaEM7SUFDUjtJQUNBLE9BQU9PO0FBQ1AseUNBQXlDLEdBQzdDO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNaLFNBQVN1QixLQUFLO0lBQ25CLDBDQUEwQyxHQUUxQyxJQUFJWCxNQUFNVCxLQUFLcUIsT0FBTyxDQUFDO1FBQUM7S0FBSSxFQUFFRCxNQUFNaEIsSUFBSSxHQUFHLFdBQzFDLHFDQUNJLFlBQVk7SUFDakIsSUFBSWtCLFNBQVNGLE1BQU1HLFdBQVcsRUFDMUJDLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlGLE9BQU9MLE1BQU0sRUFBRVIsSUFDbEI7SUFFRCxJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUksZUFBZSxHQUFHTCxNQUFNTSxXQUFXLENBQUNULE1BQU0sRUFBRSxFQUFFUSxFQUFHO1FBQ2pFLElBQUl2QixRQUFRa0IsTUFBTU8sWUFBWSxDQUFDRixFQUFFLENBQUNHLE9BQU8sSUFDckNqQixNQUFRLE1BQU1YLEtBQUs2QixRQUFRLENBQUMzQixNQUFNRSxJQUFJO1FBRTFDLElBQUlGLE1BQU00QixRQUFRLEVBQUVyQixJQUNuQix1Q0FBdUNFLEtBQUtULE1BQU1FLElBQUksR0FBRyw0QkFBNEI7UUFFdEYsYUFBYTtRQUNiLElBQUlGLE1BQU1JLEdBQUcsRUFBRTtZQUFFRyxJQUNaLDBCQUEwQkUsS0FDdEIsWUFBWVYsUUFBUUMsT0FBTyxXQUMvQix5QkFBeUJTLEtBQ3pCO1lBQ0dRLGFBQWFWLEtBQUtQLE9BQU87WUFDekJNLGVBQWVDLEtBQUtQLE9BQU91QixHQUFHZCxNQUFNLFVBQ3ZDO1FBRUwsa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSVQsTUFBTUcsUUFBUSxFQUFFO1lBQUVJLElBQ3hCLDBCQUEwQkUsS0FDdEIsWUFBWVYsUUFBUUMsT0FBTyxVQUMvQixpQ0FBaUNTO1lBQzlCSCxlQUFlQyxLQUFLUCxPQUFPdUIsR0FBR2QsTUFBTSxPQUN2QztRQUVMLDZCQUE2QjtRQUM3QixPQUFPO1lBQ0gsSUFBSVQsTUFBTTZCLE1BQU0sRUFBRTtnQkFDZCxJQUFJQyxZQUFZaEMsS0FBSzZCLFFBQVEsQ0FBQzNCLE1BQU02QixNQUFNLENBQUMzQixJQUFJO2dCQUMvQyxJQUFJb0IsY0FBYyxDQUFDdEIsTUFBTTZCLE1BQU0sQ0FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUdLLElBQ2hELGVBQWV1QixXQUNYLFlBQVk5QixNQUFNNkIsTUFBTSxDQUFDM0IsSUFBSSxHQUFHO2dCQUNqQ29CLGNBQWMsQ0FBQ3RCLE1BQU02QixNQUFNLENBQUMzQixJQUFJLENBQUMsR0FBRztnQkFDcENLLElBQ0gsU0FBU3VCO1lBQ1Y7WUFDQXhCLGVBQWVDLEtBQUtQLE9BQU91QixHQUFHZDtRQUNsQztRQUNBLElBQUlULE1BQU00QixRQUFRLEVBQUVyQixJQUNuQjtJQUNMO0lBQ0EsT0FBT0EsSUFDTjtBQUNELHlDQUF5QyxHQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy92ZXJpZmllci5qcz80MmJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZmllcjtcblxudmFyIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gaW52YWxpZChmaWVsZCwgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmllbGQubmFtZSArIFwiOiBcIiArIGV4cGVjdGVkICsgKGZpZWxkLnJlcGVhdGVkICYmIGV4cGVjdGVkICE9PSBcImFycmF5XCIgPyBcIltdXCIgOiBmaWVsZC5tYXAgJiYgZXhwZWN0ZWQgIT09IFwib2JqZWN0XCIgPyBcIntrOlwiK2ZpZWxkLmtleVR5cGUrXCJ9XCIgOiBcIlwiKSArIFwiIGV4cGVjdGVkXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goJXMpe1wiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJlbnVtIHZhbHVlXCIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzKSwgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzW2tleXNbal1dKTtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwie1wiKVxuICAgICAgICAgICAgICAgIChcInZhciBlPXR5cGVzWyVpXS52ZXJpZnkoJXMpO1wiLCBmaWVsZEluZGV4LCByZWYpXG4gICAgICAgICAgICAgICAgKFwiaWYoZSlcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWorZVwiLCBmaWVsZC5uYW1lICsgXCIuXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykmJiEoJXMmJnV0aWwuaXNJbnRlZ2VyKCVzLmxvdykmJnV0aWwuaXNJbnRlZ2VyKCVzLmhpZ2gpKSlcIiwgcmVmLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcIm51bWJlclxcXCIpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJudW1iZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcImJvb2xlYW5cXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhblwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzU3RyaW5nKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcInN0cmluZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmdHlwZW9mICVzLmxlbmd0aD09PVxcXCJudW1iZXJcXFwifHx1dGlsLmlzU3RyaW5nKCVzKSkpXCIsIHJlZiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYnVmZmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIGtleSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHN3aXRjaCAoZmllbGQua2V5VHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTMyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXIga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTY0UmUudGVzdCglcykpXCIsIHJlZikgLy8gc2VlIGNvbW1lbnQgYWJvdmU6IHggaXMgb2ssIGQgaXMgbm90XG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmcga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTJSZS50ZXN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhbiBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHZlcmlmaWVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmaWVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cblxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiXSwgbXR5cGUubmFtZSArIFwiJHZlcmlmeVwiKVxuICAgIChcImlmKHR5cGVvZiBtIT09XFxcIm9iamVjdFxcXCJ8fG09PT1udWxsKVwiKVxuICAgICAgICAoXCJyZXR1cm4lalwiLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcbiAgICB2YXIgb25lb2ZzID0gbXR5cGUub25lb2ZzQXJyYXksXG4gICAgICAgIHNlZW5GaXJzdEZpZWxkID0ge307XG4gICAgaWYgKG9uZW9mcy5sZW5ndGgpIGdlblxuICAgIChcInZhciBwPXt9XCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwiaWYoJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcmVmLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgIC8vIG1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmlzT2JqZWN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwib2JqZWN0XCIpKVxuICAgICAgICAgICAgKFwidmFyIGs9T2JqZWN0LmtleXMoJXMpXCIsIHJlZilcbiAgICAgICAgICAgIChcImZvcih2YXIgaT0wO2k8ay5sZW5ndGg7KytpKXtcIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIFwia1tpXVwiKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltrW2ldXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYXJyYXlcIikpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpe1wiLCByZWYpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2ldXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIHJlcXVpcmVkIG9yIHByZXNlbnQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uZW9mUHJvcCA9IHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPT09IDEpIGdlblxuICAgICAgICAgICAgKFwiaWYocCVzPT09MSlcIiwgb25lb2ZQcm9wKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGZpZWxkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwicCVzPTFcIiwgb25lb2ZQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBudWxsXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn0iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInZlcmlmaWVyIiwiRW51bSIsInJlcXVpcmUiLCJ1dGlsIiwiaW52YWxpZCIsImZpZWxkIiwiZXhwZWN0ZWQiLCJuYW1lIiwicmVwZWF0ZWQiLCJtYXAiLCJrZXlUeXBlIiwiZ2VuVmVyaWZ5VmFsdWUiLCJnZW4iLCJmaWVsZEluZGV4IiwicmVmIiwicmVzb2x2ZWRUeXBlIiwia2V5cyIsIk9iamVjdCIsInZhbHVlcyIsImoiLCJsZW5ndGgiLCJ0eXBlIiwiZ2VuVmVyaWZ5S2V5IiwibXR5cGUiLCJjb2RlZ2VuIiwib25lb2ZzIiwib25lb2ZzQXJyYXkiLCJzZWVuRmlyc3RGaWVsZCIsImkiLCJmaWVsZHNBcnJheSIsIl9maWVsZHNBcnJheSIsInJlc29sdmUiLCJzYWZlUHJvcCIsIm9wdGlvbmFsIiwicGFydE9mIiwib25lb2ZQcm9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/verifier.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/wrappers.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/wrappers.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */ var wrappers = exports;\nvar Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\");\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */ /**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */ /**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */ // Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n    fromObject: function(object) {\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n        return this.fromObject(object);\n    },\n    toObject: function(message, options) {\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) message = type.decode(message.value);\n        }\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ? message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n        return this.toObject(message, options);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyYXBwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7Ozs7Q0FJQyxHQUNELElBQUlBLFdBQVdDO0FBRWYsSUFBSUMsVUFBVUMsbUJBQU9BLENBQUMsa0VBQVc7QUFFakM7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7OztDQVFDLEdBRUQ7Ozs7O0NBS0MsR0FFRCx5QkFBeUI7QUFDekJILFFBQVEsQ0FBQyx1QkFBdUIsR0FBRztJQUUvQkksWUFBWSxTQUFTQyxNQUFNO1FBRXZCLDhCQUE4QjtRQUM5QixJQUFJQSxVQUFVQSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQzFCLHdEQUF3RDtZQUN6RCxJQUFJQyxPQUFPRCxNQUFNLENBQUMsUUFBUSxDQUFDRSxTQUFTLENBQUNGLE1BQU0sQ0FBQyxRQUFRLENBQUNHLFdBQVcsQ0FBQyxPQUFPO1lBQ3hFLElBQUlDLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNKO1lBQ3ZCLHdCQUF3QixHQUN4QixJQUFJRyxNQUFNO2dCQUNOLHVDQUF1QztnQkFDdkMsSUFBSUUsV0FBV04sTUFBTSxDQUFDLFFBQVEsQ0FBQ08sTUFBTSxDQUFDLE9BQU8sTUFDekNQLE1BQU0sQ0FBQyxRQUFRLENBQUNRLEtBQUssQ0FBQyxLQUFLUixNQUFNLENBQUMsUUFBUTtnQkFDOUMsOERBQThEO2dCQUM5RCxJQUFJTSxTQUFTRyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7b0JBQzlCSCxXQUFXLE1BQU1BO2dCQUNyQjtnQkFDQSxPQUFPLElBQUksQ0FBQ0ksTUFBTSxDQUFDO29CQUNmSixVQUFVQTtvQkFDVkssT0FBT1AsS0FBS1EsTUFBTSxDQUFDUixLQUFLTCxVQUFVLENBQUNDLFNBQVNhLE1BQU07Z0JBQ3REO1lBQ0o7UUFDSjtRQUVBLE9BQU8sSUFBSSxDQUFDZCxVQUFVLENBQUNDO0lBQzNCO0lBRUFjLFVBQVUsU0FBU0MsT0FBTyxFQUFFQyxPQUFPO1FBRS9CLGlCQUFpQjtRQUNqQixJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLFNBQVM7UUFDYixJQUFJakIsT0FBTztRQUVYLHlDQUF5QztRQUN6QyxJQUFJZSxXQUFXQSxRQUFRRyxJQUFJLElBQUlKLFFBQVFULFFBQVEsSUFBSVMsUUFBUUosS0FBSyxFQUFFO1lBQzlELHdEQUF3RDtZQUN4RFYsT0FBT2MsUUFBUVQsUUFBUSxDQUFDSixTQUFTLENBQUNhLFFBQVFULFFBQVEsQ0FBQ0gsV0FBVyxDQUFDLE9BQU87WUFDdEUsMkJBQTJCO1lBQzNCZSxTQUFTSCxRQUFRVCxRQUFRLENBQUNKLFNBQVMsQ0FBQyxHQUFHYSxRQUFRVCxRQUFRLENBQUNILFdBQVcsQ0FBQyxPQUFPO1lBQzNFLElBQUlDLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNKO1lBQ3ZCLHdCQUF3QixHQUN4QixJQUFJRyxNQUNBVyxVQUFVWCxLQUFLZ0IsTUFBTSxDQUFDTCxRQUFRSixLQUFLO1FBQzNDO1FBRUEseUJBQXlCO1FBQ3pCLElBQUksQ0FBRUksQ0FBQUEsbUJBQW1CLElBQUksQ0FBQ00sSUFBSSxLQUFLTixtQkFBbUJsQixTQUFTO1lBQy9ELElBQUlHLFNBQVNlLFFBQVFPLEtBQUssQ0FBQ1IsUUFBUSxDQUFDQyxTQUFTQztZQUM3QyxJQUFJTyxjQUFjUixRQUFRTyxLQUFLLENBQUNFLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFDNUNULFFBQVFPLEtBQUssQ0FBQ0UsUUFBUSxDQUFDaEIsS0FBSyxDQUFDLEtBQUtPLFFBQVFPLEtBQUssQ0FBQ0UsUUFBUTtZQUM1RCw2REFBNkQ7WUFDN0QsSUFBSU4sV0FBVyxJQUFJO2dCQUNmQSxTQUFTRDtZQUNiO1lBQ0FoQixPQUFPaUIsU0FBU0s7WUFDaEJ2QixNQUFNLENBQUMsUUFBUSxHQUFHQztZQUNsQixPQUFPRDtRQUNYO1FBRUEsT0FBTyxJQUFJLENBQUNjLFFBQVEsQ0FBQ0MsU0FBU0M7SUFDbEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaXZlLWNsb25lLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cmFwcGVycy5qcz9hM2M0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFdyYXBwZXJzIGZvciBjb21tb24gdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsSVdyYXBwZXI+fVxuICogQGNvbnN0XG4gKi9cbnZhciB3cmFwcGVycyA9IGV4cG9ydHM7XG5cbnZhciBNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcblxuLyoqXG4gKiBGcm9tIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxuICogQHR5cGVkZWYgV3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRoaXMgVHlwZVxuICovXG5cbi8qKlxuICogVG8gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBDb21tb24gdHlwZSB3cmFwcGVyIHBhcnQgb2Yge0BsaW5rIHdyYXBwZXJzfS5cbiAqIEBpbnRlcmZhY2UgSVdyYXBwZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJ9IFtmcm9tT2JqZWN0XSBGcm9tIG9iamVjdCBjb252ZXJ0ZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlclRvT2JqZWN0Q29udmVydGVyfSBbdG9PYmplY3RdIFRvIG9iamVjdCBjb252ZXJ0ZXJcbiAqL1xuXG4vLyBDdXN0b20gd3JhcHBlciBmb3IgQW55XG53cmFwcGVyc1tcIi5nb29nbGUucHJvdG9idWYuQW55XCJdID0ge1xuXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgLy8gdW53cmFwIHZhbHVlIHR5cGUgaWYgbWFwcGVkXG4gICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0W1wiQHR5cGVcIl0pIHtcbiAgICAgICAgICAgICAvLyBPbmx5IHVzZSBmdWxseSBxdWFsaWZpZWQgdHlwZSBuYW1lIGFmdGVyIHRoZSBsYXN0ICcvJ1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHJpbmcob2JqZWN0W1wiQHR5cGVcIl0ubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gdHlwZV91cmwgZG9lcyBub3QgYWNjZXB0IGxlYWRpbmcgXCIuXCJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZV91cmwgPSBvYmplY3RbXCJAdHlwZVwiXS5jaGFyQXQoMCkgPT09IFwiLlwiID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0uc2xpY2UoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBwcmVmaXggaXMgb3B0aW9uYWwsIGJ1dCBwYXRoIHNlcGVyYXRvciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlX3VybC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlLmVuY29kZSh0eXBlLmZyb21PYmplY3Qob2JqZWN0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHByZWZpeFxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIGRlY29kZSB2YWx1ZSBpZiByZXF1ZXN0ZWQgYW5kIHVubWFwcGVkXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiBtZXNzYWdlLnR5cGVfdXJsICYmIG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICBuYW1lID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcobWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHRoZSBwcmVmaXggdXNlZFxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGUuZGVjb2RlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB2YWx1ZSBpZiB1bm1hcHBlZFxuICAgICAgICBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgdGhpcy5jdG9yKSAmJiBtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lWzBdID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgbWVzc2FnZS4kdHlwZS5mdWxsTmFtZS5zbGljZSgxKSA6IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWU7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHR5cGUuZ29vZ2xlYXBpcy5jb20gcHJlZml4IGlmIG5vIHByZWZpeCBpcyB1c2VkXG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ29vZ2xlQXBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHByZWZpeCArIG1lc3NhZ2VOYW1lO1xuICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsid3JhcHBlcnMiLCJleHBvcnRzIiwiTWVzc2FnZSIsInJlcXVpcmUiLCJmcm9tT2JqZWN0Iiwib2JqZWN0IiwibmFtZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwidHlwZSIsImxvb2t1cCIsInR5cGVfdXJsIiwiY2hhckF0Iiwic2xpY2UiLCJpbmRleE9mIiwiY3JlYXRlIiwidmFsdWUiLCJlbmNvZGUiLCJmaW5pc2giLCJ0b09iamVjdCIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiZ29vZ2xlQXBpIiwicHJlZml4IiwianNvbiIsImRlY29kZSIsImN0b3IiLCIkdHlwZSIsIm1lc3NhZ2VOYW1lIiwiZnVsbE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/wrappers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/writer.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/writer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Writer;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar BufferWriter; // cyclic\nvar LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */ function Op(fn, len, val) {\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */ this.fn = fn;\n    /**\n     * Value byte length.\n     * @type {number}\n     */ this.len = len;\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */ this.next = undefined;\n    /**\n     * Value to write.\n     * @type {*}\n     */ this.val = val; // type varies\n}\n/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */ function State(writer) {\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */ this.head = writer.head;\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */ this.tail = writer.tail;\n    /**\n     * Current buffer length.\n     * @type {number}\n     */ this.len = writer.len;\n    /**\n     * Next state.\n     * @type {State|null}\n     */ this.next = writer.states;\n}\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */ function Writer() {\n    /**\n     * Current length.\n     * @type {number}\n     */ this.len = 0;\n    /**\n     * Operations head.\n     * @type {Object}\n     */ this.head = new Op(noop, 0, 0);\n    /**\n     * Operations tail\n     * @type {Object}\n     */ this.tail = this.head;\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */ this.states = null;\n// When a value is written, the writer calculates its byte length and puts it into a linked\n// list of operations to perform when finish() is called. This both allows us to allocate\n// buffers of the exact required size and reduces the amount of work we have to do compared\n// to first calculating over objects and then encoding over objects. In our case, the encoding\n// part is just a linked list walk calling operations with already prepared values.\n}\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    } : function create_array() {\n        return new Writer();\n    };\n};\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */ Writer.create = create();\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */ Writer.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */ Writer.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while(val > 127){\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */ function VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n    return this;\n};\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.int32 = function write_int32(value) {\n    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n     : this.uint32(value);\n};\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n    while(val.hi){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while(val.lo > 127){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.int64 = Writer.prototype.uint64;\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n    buf.set(val, pos); // also works for plain array values\n} : function writeBytes_for(val, buf, pos) {\n    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];\n};\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */ Writer.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len) return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */ Writer.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */ Writer.prototype.reset = function reset() {\n    if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n    }\n    return this;\n};\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */ Writer.prototype.ldelim = function ldelim() {\n    var head = this.head, tail = this.tail, len = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */ Writer.prototype.finish = function finish() {\n    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n    while(head){\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVlDLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUV4QyxJQUFJQyxjQUFjLFNBQVM7QUFFM0IsSUFBSUMsV0FBWUgsS0FBS0csUUFBUSxFQUN6QkMsU0FBWUosS0FBS0ksTUFBTSxFQUN2QkMsT0FBWUwsS0FBS0ssSUFBSTtBQUV6Qjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLEdBQUdDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsRUFBRSxHQUFHQTtJQUVWOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsSUFBSSxHQUFHQztJQUVaOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsR0FBRyxHQUFHQSxLQUFLLGNBQWM7QUFDbEM7QUFFQSx3QkFBd0IsR0FDeEIsU0FBU0csUUFBUSxFQUFFLHdDQUF3QztBQUUzRDs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsTUFBTUMsTUFBTTtJQUVqQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBR0QsT0FBT0MsSUFBSTtJQUV2Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBR0YsT0FBT0UsSUFBSTtJQUV2Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNSLEdBQUcsR0FBR00sT0FBT04sR0FBRztJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLElBQUksR0FBR0ksT0FBT0csTUFBTTtBQUM3QjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTbEI7SUFFTDs7O0tBR0MsR0FDRCxJQUFJLENBQUNTLEdBQUcsR0FBRztJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ08sSUFBSSxHQUFHLElBQUlULEdBQUdNLE1BQU0sR0FBRztJQUU1Qjs7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Oi8vZHJpdmUtY2xvbmUtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcz84YzhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIldyaXRlciIsInV0aWwiLCJyZXF1aXJlIiwiQnVmZmVyV3JpdGVyIiwiTG9uZ0JpdHMiLCJiYXNlNjQiLCJ1dGY4IiwiT3AiLCJmbiIsImxlbiIsInZhbCIsIm5leHQiLCJ1bmRlZmluZWQiLCJub29wIiwiU3RhdGUiLCJ3cml0ZXIiLCJoZWFkIiwidGFpbCIsInN0YXRlcyIsImNyZWF0ZSIsIkJ1ZmZlciIsImNyZWF0ZV9idWZmZXJfc2V0dXAiLCJjcmVhdGVfYnVmZmVyIiwiY3JlYXRlX2FycmF5IiwiYWxsb2MiLCJzaXplIiwiQXJyYXkiLCJwb29sIiwicHJvdG90eXBlIiwic3ViYXJyYXkiLCJfcHVzaCIsInB1c2giLCJ3cml0ZUJ5dGUiLCJidWYiLCJwb3MiLCJ3cml0ZVZhcmludDMyIiwiVmFyaW50T3AiLCJPYmplY3QiLCJ1aW50MzIiLCJ3cml0ZV91aW50MzIiLCJ2YWx1ZSIsImludDMyIiwid3JpdGVfaW50MzIiLCJ3cml0ZVZhcmludDY0IiwiZnJvbU51bWJlciIsInNpbnQzMiIsIndyaXRlX3NpbnQzMiIsImhpIiwibG8iLCJ1aW50NjQiLCJ3cml0ZV91aW50NjQiLCJiaXRzIiwiZnJvbSIsImxlbmd0aCIsImludDY0Iiwic2ludDY0Iiwid3JpdGVfc2ludDY0IiwienpFbmNvZGUiLCJib29sIiwid3JpdGVfYm9vbCIsIndyaXRlRml4ZWQzMiIsImZpeGVkMzIiLCJ3cml0ZV9maXhlZDMyIiwic2ZpeGVkMzIiLCJmaXhlZDY0Iiwid3JpdGVfZml4ZWQ2NCIsInNmaXhlZDY0IiwiZmxvYXQiLCJ3cml0ZV9mbG9hdCIsIndyaXRlRmxvYXRMRSIsImRvdWJsZSIsIndyaXRlX2RvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZUJ5dGVzIiwic2V0Iiwid3JpdGVCeXRlc19zZXQiLCJ3cml0ZUJ5dGVzX2ZvciIsImkiLCJieXRlcyIsIndyaXRlX2J5dGVzIiwiaXNTdHJpbmciLCJkZWNvZGUiLCJzdHJpbmciLCJ3cml0ZV9zdHJpbmciLCJ3cml0ZSIsImZvcmsiLCJyZXNldCIsImxkZWxpbSIsImZpbmlzaCIsImNvbnN0cnVjdG9yIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlcldyaXRlcl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/writer_buffer.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/writer_buffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferWriter;\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */ function BufferWriter() {\n    Writer.call(this);\n}\nBufferWriter._configure = function() {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */ BufferWriter.alloc = util._Buffer_allocUnsafe;\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n    } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) val.copy(buf, pos, 0, val.length);\n        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];\n    };\n};\n/**\n * @override\n */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write) buf.utf8Write(val, pos);\n    else buf.write(val, pos);\n}\n/**\n * @override\n */ BufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len) this._push(writeStringBuffer, len, value);\n    return this;\n};\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */ BufferWriter._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixpQkFBaUI7QUFDakIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDOUJGLENBQUFBLGFBQWFHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixPQUFPRSxTQUFTLEdBQUdHLFdBQVcsR0FBR047QUFFekUsSUFBSU8sT0FBT0wsbUJBQU9BLENBQUMsNEVBQWdCO0FBRW5DOzs7OztDQUtDLEdBQ0QsU0FBU0Y7SUFDTEMsT0FBT08sSUFBSSxDQUFDLElBQUk7QUFDcEI7QUFFQVIsYUFBYVMsVUFBVSxHQUFHO0lBQ3RCOzs7OztLQUtDLEdBQ0RULGFBQWFVLEtBQUssR0FBR0gsS0FBS0ksbUJBQW1CO0lBRTdDWCxhQUFhWSxnQkFBZ0IsR0FBR0wsS0FBS00sTUFBTSxJQUFJTixLQUFLTSxNQUFNLENBQUNWLFNBQVMsWUFBWVcsY0FBY1AsS0FBS00sTUFBTSxDQUFDVixTQUFTLENBQUNZLEdBQUcsQ0FBQ0MsSUFBSSxLQUFLLFFBQzNILFNBQVNDLHFCQUFxQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7UUFDM0NELElBQUlKLEdBQUcsQ0FBQ0csS0FBS0UsTUFBTSxzR0FBc0c7SUFDekgsb0NBQW9DO0lBQ3RDLElBRUUsU0FBU0Msc0JBQXNCSCxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUM1QyxJQUFJRixJQUFJSSxJQUFJLEVBQ1ZKLElBQUlJLElBQUksQ0FBQ0gsS0FBS0MsS0FBSyxHQUFHRixJQUFJSyxNQUFNO2FBQzdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixJQUFJSyxNQUFNLEVBQ2pDSixHQUFHLENBQUNDLE1BQU0sR0FBR0YsR0FBRyxDQUFDTSxJQUFJO0lBQ3pCO0FBQ1I7QUFHQTs7Q0FFQyxHQUNEeEIsYUFBYUcsU0FBUyxDQUFDc0IsS0FBSyxHQUFHLFNBQVNDLG1CQUFtQkMsS0FBSztJQUM1RCxJQUFJcEIsS0FBS3FCLFFBQVEsQ0FBQ0QsUUFDZEEsUUFBUXBCLEtBQUtzQixZQUFZLENBQUNGLE9BQU87SUFDckMsSUFBSUcsTUFBTUgsTUFBTUosTUFBTSxLQUFLO0lBQzNCLElBQUksQ0FBQ1EsTUFBTSxDQUFDRDtJQUNaLElBQUlBLEtBQ0EsSUFBSSxDQUFDRSxLQUFLLENBQUNoQyxhQUFhWSxnQkFBZ0IsRUFBRWtCLEtBQUtIO0lBQ25ELE9BQU8sSUFBSTtBQUNmO0FBRUEsU0FBU00sa0JBQWtCZixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUNwQyxJQUFJRixJQUFJSyxNQUFNLEdBQUcsSUFDYmhCLEtBQUsyQixJQUFJLENBQUNDLEtBQUssQ0FBQ2pCLEtBQUtDLEtBQUtDO1NBQ3pCLElBQUlELElBQUlpQixTQUFTLEVBQ2xCakIsSUFBSWlCLFNBQVMsQ0FBQ2xCLEtBQUtFO1NBRW5CRCxJQUFJZ0IsS0FBSyxDQUFDakIsS0FBS0U7QUFDdkI7QUFFQTs7Q0FFQyxHQUNEcEIsYUFBYUcsU0FBUyxDQUFDa0MsTUFBTSxHQUFHLFNBQVNDLG9CQUFvQlgsS0FBSztJQUM5RCxJQUFJRyxNQUFNdkIsS0FBS00sTUFBTSxDQUFDMEIsVUFBVSxDQUFDWjtJQUNqQyxJQUFJLENBQUNJLE1BQU0sQ0FBQ0Q7SUFDWixJQUFJQSxLQUNBLElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxtQkFBbUJILEtBQUtIO0lBQ3ZDLE9BQU8sSUFBSTtBQUNmO0FBR0E7Ozs7O0NBS0MsR0FFRDNCLGFBQWFTLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcml2ZS1jbG9uZS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcz9hYTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyV3JpdGVyIiwiV3JpdGVyIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidXRpbCIsImNhbGwiLCJfY29uZmlndXJlIiwiYWxsb2MiLCJfQnVmZmVyX2FsbG9jVW5zYWZlIiwid3JpdGVCeXRlc0J1ZmZlciIsIkJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJuYW1lIiwid3JpdGVCeXRlc0J1ZmZlcl9zZXQiLCJ2YWwiLCJidWYiLCJwb3MiLCJ3cml0ZUJ5dGVzQnVmZmVyX2NvcHkiLCJjb3B5IiwibGVuZ3RoIiwiaSIsImJ5dGVzIiwid3JpdGVfYnl0ZXNfYnVmZmVyIiwidmFsdWUiLCJpc1N0cmluZyIsIl9CdWZmZXJfZnJvbSIsImxlbiIsInVpbnQzMiIsIl9wdXNoIiwid3JpdGVTdHJpbmdCdWZmZXIiLCJ1dGY4Iiwid3JpdGUiLCJ1dGY4V3JpdGUiLCJzdHJpbmciLCJ3cml0ZV9zdHJpbmdfYnVmZmVyIiwiYnl0ZUxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/api.json":
/*!***********************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/api.json ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Api":{"fields":{"name":{"type":"string","id":1},"methods":{"rule":"repeated","type":"Method","id":2},"options":{"rule":"repeated","type":"Option","id":3},"version":{"type":"string","id":4},"sourceContext":{"type":"SourceContext","id":5},"mixins":{"rule":"repeated","type":"Mixin","id":6},"syntax":{"type":"Syntax","id":7}}},"Method":{"fields":{"name":{"type":"string","id":1},"requestTypeUrl":{"type":"string","id":2},"requestStreaming":{"type":"bool","id":3},"responseTypeUrl":{"type":"string","id":4},"responseStreaming":{"type":"bool","id":5},"options":{"rule":"repeated","type":"Option","id":6},"syntax":{"type":"Syntax","id":7}}},"Mixin":{"fields":{"name":{"type":"string","id":1},"root":{"type":"string","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/descriptor.json":
/*!******************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/descriptor.json ***!
  \******************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"options":{"go_package":"google.golang.org/protobuf/types/descriptorpb","java_package":"com.google.protobuf","java_outer_classname":"DescriptorProtos","csharp_namespace":"Google.Protobuf.Reflection","objc_class_prefix":"GPB","cc_enable_arenas":true,"optimize_for":"SPEED"},"nested":{"FileDescriptorSet":{"edition":"proto2","fields":{"file":{"rule":"repeated","type":"FileDescriptorProto","id":1}},"extensions":[[536000000,536000000]]},"Edition":{"edition":"proto2","values":{"EDITION_UNKNOWN":0,"EDITION_LEGACY":900,"EDITION_PROTO2":998,"EDITION_PROTO3":999,"EDITION_2023":1000,"EDITION_2024":1001,"EDITION_1_TEST_ONLY":1,"EDITION_2_TEST_ONLY":2,"EDITION_99997_TEST_ONLY":99997,"EDITION_99998_TEST_ONLY":99998,"EDITION_99999_TEST_ONLY":99999,"EDITION_MAX":2147483647}},"FileDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"package":{"type":"string","id":2},"dependency":{"rule":"repeated","type":"string","id":3},"publicDependency":{"rule":"repeated","type":"int32","id":10},"weakDependency":{"rule":"repeated","type":"int32","id":11},"optionDependency":{"rule":"repeated","type":"string","id":15},"messageType":{"rule":"repeated","type":"DescriptorProto","id":4},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":5},"service":{"rule":"repeated","type":"ServiceDescriptorProto","id":6},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":7},"options":{"type":"FileOptions","id":8},"sourceCodeInfo":{"type":"SourceCodeInfo","id":9},"syntax":{"type":"string","id":12},"edition":{"type":"Edition","id":14}}},"DescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"field":{"rule":"repeated","type":"FieldDescriptorProto","id":2},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":6},"nestedType":{"rule":"repeated","type":"DescriptorProto","id":3},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":4},"extensionRange":{"rule":"repeated","type":"ExtensionRange","id":5},"oneofDecl":{"rule":"repeated","type":"OneofDescriptorProto","id":8},"options":{"type":"MessageOptions","id":7},"reservedRange":{"rule":"repeated","type":"ReservedRange","id":9},"reservedName":{"rule":"repeated","type":"string","id":10},"visibility":{"type":"SymbolVisibility","id":11}},"nested":{"ExtensionRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2},"options":{"type":"ExtensionRangeOptions","id":3}}},"ReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"ExtensionRangeOptions":{"edition":"proto2","fields":{"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999},"declaration":{"rule":"repeated","type":"Declaration","id":2,"options":{"retention":"RETENTION_SOURCE"}},"features":{"type":"FeatureSet","id":50},"verification":{"type":"VerificationState","id":3,"options":{"default":"UNVERIFIED","retention":"RETENTION_SOURCE"}}},"extensions":[[1000,536870911]],"nested":{"Declaration":{"fields":{"number":{"type":"int32","id":1},"fullName":{"type":"string","id":2},"type":{"type":"string","id":3},"reserved":{"type":"bool","id":5},"repeated":{"type":"bool","id":6}},"reserved":[[4,4]]},"VerificationState":{"values":{"DECLARATION":0,"UNVERIFIED":1}}}},"FieldDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":3},"label":{"type":"Label","id":4},"type":{"type":"Type","id":5},"typeName":{"type":"string","id":6},"extendee":{"type":"string","id":2},"defaultValue":{"type":"string","id":7},"oneofIndex":{"type":"int32","id":9},"jsonName":{"type":"string","id":10},"options":{"type":"FieldOptions","id":8},"proto3Optional":{"type":"bool","id":17}},"nested":{"Type":{"values":{"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Label":{"values":{"LABEL_OPTIONAL":1,"LABEL_REPEATED":3,"LABEL_REQUIRED":2}}}},"OneofDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"options":{"type":"OneofOptions","id":2}}},"EnumDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"value":{"rule":"repeated","type":"EnumValueDescriptorProto","id":2},"options":{"type":"EnumOptions","id":3},"reservedRange":{"rule":"repeated","type":"EnumReservedRange","id":4},"reservedName":{"rule":"repeated","type":"string","id":5},"visibility":{"type":"SymbolVisibility","id":6}},"nested":{"EnumReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"EnumValueDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"type":"EnumValueOptions","id":3}}},"ServiceDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"method":{"rule":"repeated","type":"MethodDescriptorProto","id":2},"options":{"type":"ServiceOptions","id":3}}},"MethodDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"inputType":{"type":"string","id":2},"outputType":{"type":"string","id":3},"options":{"type":"MethodOptions","id":4},"clientStreaming":{"type":"bool","id":5},"serverStreaming":{"type":"bool","id":6}}},"FileOptions":{"edition":"proto2","fields":{"javaPackage":{"type":"string","id":1},"javaOuterClassname":{"type":"string","id":8},"javaMultipleFiles":{"type":"bool","id":10},"javaGenerateEqualsAndHash":{"type":"bool","id":20,"options":{"deprecated":true}},"javaStringCheckUtf8":{"type":"bool","id":27},"optimizeFor":{"type":"OptimizeMode","id":9,"options":{"default":"SPEED"}},"goPackage":{"type":"string","id":11},"ccGenericServices":{"type":"bool","id":16},"javaGenericServices":{"type":"bool","id":17},"pyGenericServices":{"type":"bool","id":18},"deprecated":{"type":"bool","id":23},"ccEnableArenas":{"type":"bool","id":31,"options":{"default":true}},"objcClassPrefix":{"type":"string","id":36},"csharpNamespace":{"type":"string","id":37},"swiftPrefix":{"type":"string","id":39},"phpClassPrefix":{"type":"string","id":40},"phpNamespace":{"type":"string","id":41},"phpMetadataNamespace":{"type":"string","id":44},"rubyPackage":{"type":"string","id":45},"features":{"type":"FeatureSet","id":50},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[42,42],"php_generic_services",[38,38]],"nested":{"OptimizeMode":{"values":{"SPEED":1,"CODE_SIZE":2,"LITE_RUNTIME":3}}}},"MessageOptions":{"edition":"proto2","fields":{"messageSetWireFormat":{"type":"bool","id":1},"noStandardDescriptorAccessor":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"mapEntry":{"type":"bool","id":7},"deprecatedLegacyJsonFieldConflicts":{"type":"bool","id":11,"options":{"deprecated":true}},"features":{"type":"FeatureSet","id":12},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4],[5,5],[6,6],[8,8],[9,9]]},"FieldOptions":{"edition":"proto2","fields":{"ctype":{"type":"CType","id":1,"options":{"default":"STRING"}},"packed":{"type":"bool","id":2},"jstype":{"type":"JSType","id":6,"options":{"default":"JS_NORMAL"}},"lazy":{"type":"bool","id":5},"unverifiedLazy":{"type":"bool","id":15},"deprecated":{"type":"bool","id":3},"weak":{"type":"bool","id":10,"options":{"deprecated":true}},"debugRedact":{"type":"bool","id":16},"retention":{"type":"OptionRetention","id":17},"targets":{"rule":"repeated","type":"OptionTargetType","id":19},"editionDefaults":{"rule":"repeated","type":"EditionDefault","id":20},"features":{"type":"FeatureSet","id":21},"featureSupport":{"type":"FeatureSupport","id":22},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4],[18,18]],"nested":{"CType":{"values":{"STRING":0,"CORD":1,"STRING_PIECE":2}},"JSType":{"values":{"JS_NORMAL":0,"JS_STRING":1,"JS_NUMBER":2}},"OptionRetention":{"values":{"RETENTION_UNKNOWN":0,"RETENTION_RUNTIME":1,"RETENTION_SOURCE":2}},"OptionTargetType":{"values":{"TARGET_TYPE_UNKNOWN":0,"TARGET_TYPE_FILE":1,"TARGET_TYPE_EXTENSION_RANGE":2,"TARGET_TYPE_MESSAGE":3,"TARGET_TYPE_FIELD":4,"TARGET_TYPE_ONEOF":5,"TARGET_TYPE_ENUM":6,"TARGET_TYPE_ENUM_ENTRY":7,"TARGET_TYPE_SERVICE":8,"TARGET_TYPE_METHOD":9}},"EditionDefault":{"fields":{"edition":{"type":"Edition","id":3},"value":{"type":"string","id":2}}},"FeatureSupport":{"fields":{"editionIntroduced":{"type":"Edition","id":1},"editionDeprecated":{"type":"Edition","id":2},"deprecationWarning":{"type":"string","id":3},"editionRemoved":{"type":"Edition","id":4}}}}},"OneofOptions":{"edition":"proto2","fields":{"features":{"type":"FeatureSet","id":1},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumOptions":{"edition":"proto2","fields":{"allowAlias":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"deprecatedLegacyJsonFieldConflicts":{"type":"bool","id":6,"options":{"deprecated":true}},"features":{"type":"FeatureSet","id":7},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[5,5]]},"EnumValueOptions":{"edition":"proto2","fields":{"deprecated":{"type":"bool","id":1},"features":{"type":"FeatureSet","id":2},"debugRedact":{"type":"bool","id":3},"featureSupport":{"type":"FieldOptions.FeatureSupport","id":4},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"ServiceOptions":{"edition":"proto2","fields":{"features":{"type":"FeatureSet","id":34},"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"MethodOptions":{"edition":"proto2","fields":{"deprecated":{"type":"bool","id":33},"idempotencyLevel":{"type":"IdempotencyLevel","id":34,"options":{"default":"IDEMPOTENCY_UNKNOWN"}},"features":{"type":"FeatureSet","id":35},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"nested":{"IdempotencyLevel":{"values":{"IDEMPOTENCY_UNKNOWN":0,"NO_SIDE_EFFECTS":1,"IDEMPOTENT":2}}}},"UninterpretedOption":{"edition":"proto2","fields":{"name":{"rule":"repeated","type":"NamePart","id":2},"identifierValue":{"type":"string","id":3},"positiveIntValue":{"type":"uint64","id":4},"negativeIntValue":{"type":"int64","id":5},"doubleValue":{"type":"double","id":6},"stringValue":{"type":"bytes","id":7},"aggregateValue":{"type":"string","id":8}},"nested":{"NamePart":{"fields":{"namePart":{"rule":"required","type":"string","id":1},"isExtension":{"rule":"required","type":"bool","id":2}}}}},"FeatureSet":{"edition":"proto2","fields":{"fieldPresence":{"type":"FieldPresence","id":1,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_2023","edition_defaults.value":"EXPLICIT"}},"enumType":{"type":"EnumType","id":2,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"OPEN"}},"repeatedFieldEncoding":{"type":"RepeatedFieldEncoding","id":3,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"PACKED"}},"utf8Validation":{"type":"Utf8Validation","id":4,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"VERIFY"}},"messageEncoding":{"type":"MessageEncoding","id":5,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_LEGACY","edition_defaults.value":"LENGTH_PREFIXED"}},"jsonFormat":{"type":"JsonFormat","id":6,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"ALLOW"}},"enforceNamingStyle":{"type":"EnforceNamingStyle","id":7,"options":{"retention":"RETENTION_SOURCE","targets":"TARGET_TYPE_METHOD","feature_support.edition_introduced":"EDITION_2024","edition_defaults.edition":"EDITION_2024","edition_defaults.value":"STYLE2024"}},"defaultSymbolVisibility":{"type":"VisibilityFeature.DefaultSymbolVisibility","id":8,"options":{"retention":"RETENTION_SOURCE","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2024","edition_defaults.edition":"EDITION_2024","edition_defaults.value":"EXPORT_TOP_LEVEL"}}},"extensions":[[1000,9994],[9995,9999],[10000,10000]],"reserved":[[999,999]],"nested":{"FieldPresence":{"values":{"FIELD_PRESENCE_UNKNOWN":0,"EXPLICIT":1,"IMPLICIT":2,"LEGACY_REQUIRED":3}},"EnumType":{"values":{"ENUM_TYPE_UNKNOWN":0,"OPEN":1,"CLOSED":2}},"RepeatedFieldEncoding":{"values":{"REPEATED_FIELD_ENCODING_UNKNOWN":0,"PACKED":1,"EXPANDED":2}},"Utf8Validation":{"values":{"UTF8_VALIDATION_UNKNOWN":0,"VERIFY":2,"NONE":3}},"MessageEncoding":{"values":{"MESSAGE_ENCODING_UNKNOWN":0,"LENGTH_PREFIXED":1,"DELIMITED":2}},"JsonFormat":{"values":{"JSON_FORMAT_UNKNOWN":0,"ALLOW":1,"LEGACY_BEST_EFFORT":2}},"EnforceNamingStyle":{"values":{"ENFORCE_NAMING_STYLE_UNKNOWN":0,"STYLE2024":1,"STYLE_LEGACY":2}},"VisibilityFeature":{"fields":{},"reserved":[[1,536870911]],"nested":{"DefaultSymbolVisibility":{"values":{"DEFAULT_SYMBOL_VISIBILITY_UNKNOWN":0,"EXPORT_ALL":1,"EXPORT_TOP_LEVEL":2,"LOCAL_ALL":3,"STRICT":4}}}}}},"FeatureSetDefaults":{"edition":"proto2","fields":{"defaults":{"rule":"repeated","type":"FeatureSetEditionDefault","id":1},"minimumEdition":{"type":"Edition","id":4},"maximumEdition":{"type":"Edition","id":5}},"nested":{"FeatureSetEditionDefault":{"fields":{"edition":{"type":"Edition","id":3},"overridableFeatures":{"type":"FeatureSet","id":4},"fixedFeatures":{"type":"FeatureSet","id":5}},"reserved":[[1,1],[2,2],"features"]}}},"SourceCodeInfo":{"edition":"proto2","fields":{"location":{"rule":"repeated","type":"Location","id":1}},"extensions":[[536000000,536000000]],"nested":{"Location":{"fields":{"path":{"rule":"repeated","type":"int32","id":1,"options":{"packed":true}},"span":{"rule":"repeated","type":"int32","id":2,"options":{"packed":true}},"leadingComments":{"type":"string","id":3},"trailingComments":{"type":"string","id":4},"leadingDetachedComments":{"rule":"repeated","type":"string","id":6}}}}},"GeneratedCodeInfo":{"edition":"proto2","fields":{"annotation":{"rule":"repeated","type":"Annotation","id":1}},"nested":{"Annotation":{"fields":{"path":{"rule":"repeated","type":"int32","id":1,"options":{"packed":true}},"sourceFile":{"type":"string","id":2},"begin":{"type":"int32","id":3},"end":{"type":"int32","id":4},"semantic":{"type":"Semantic","id":5}},"nested":{"Semantic":{"values":{"NONE":0,"SET":1,"ALIAS":2}}}}}},"SymbolVisibility":{"edition":"proto2","values":{"VISIBILITY_UNSET":0,"VISIBILITY_LOCAL":1,"VISIBILITY_EXPORT":2}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/source_context.json":
/*!**********************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/source_context.json ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/type.json":
/*!************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/type.json ***!
  \************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Type":{"fields":{"name":{"type":"string","id":1},"fields":{"rule":"repeated","type":"Field","id":2},"oneofs":{"rule":"repeated","type":"string","id":3},"options":{"rule":"repeated","type":"Option","id":4},"sourceContext":{"type":"SourceContext","id":5},"syntax":{"type":"Syntax","id":6}}},"Field":{"fields":{"kind":{"type":"Kind","id":1},"cardinality":{"type":"Cardinality","id":2},"number":{"type":"int32","id":3},"name":{"type":"string","id":4},"typeUrl":{"type":"string","id":6},"oneofIndex":{"type":"int32","id":7},"packed":{"type":"bool","id":8},"options":{"rule":"repeated","type":"Option","id":9},"jsonName":{"type":"string","id":10},"defaultValue":{"type":"string","id":11}},"nested":{"Kind":{"values":{"TYPE_UNKNOWN":0,"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Cardinality":{"values":{"CARDINALITY_UNKNOWN":0,"CARDINALITY_OPTIONAL":1,"CARDINALITY_REQUIRED":2,"CARDINALITY_REPEATED":3}}}},"Enum":{"fields":{"name":{"type":"string","id":1},"enumvalue":{"rule":"repeated","type":"EnumValue","id":2},"options":{"rule":"repeated","type":"Option","id":3},"sourceContext":{"type":"SourceContext","id":4},"syntax":{"type":"Syntax","id":5}}},"EnumValue":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"rule":"repeated","type":"Option","id":3}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}},"Any":{"fields":{"type_url":{"type":"string","id":1},"value":{"type":"bytes","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ })

};
;